var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(v, f, k) {
  v != Array.prototype && v != Object.prototype && (v[f] = k.value);
};
$jscomp.getGlobal = function(v) {
  return "undefined" != typeof window && window === v ? v : "undefined" != typeof global && null != global ? global : v;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.polyfill = function(v, f, k, q) {
  if (f) {
    k = $jscomp.global;
    v = v.split(".");
    for (q = 0; q < v.length - 1; q++) {
      var d = v[q];
      d in k || (k[d] = {});
      k = k[d];
    }
    v = v[v.length - 1];
    q = k[v];
    f = f(q);
    f != q && null != f && $jscomp.defineProperty(k, v, {configurable:!0, writable:!0, value:f});
  }
};
$jscomp.polyfill("Array.prototype.fill", function(v) {
  return v ? v : function(f, k, q) {
    var d = this.length || 0;
    0 > k && (k = Math.max(0, d + k));
    if (null == q || q > d) {
      q = d;
    }
    q = Number(q);
    0 > q && (q = Math.max(0, d + q));
    for (k = Number(k || 0); k < q; k++) {
      this[k] = f;
    }
    return this;
  };
}, "es6", "es3");
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function() {
  $jscomp.initSymbol = function() {
  };
  $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);
};
$jscomp.Symbol = function() {
  var v = 0;
  return function(f) {
    return $jscomp.SYMBOL_PREFIX + (f || "") + v++;
  };
}();
$jscomp.initSymbolIterator = function() {
  $jscomp.initSymbol();
  var v = $jscomp.global.Symbol.iterator;
  v || (v = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));
  "function" != typeof Array.prototype[v] && $jscomp.defineProperty(Array.prototype, v, {configurable:!0, writable:!0, value:function() {
    return $jscomp.arrayIterator(this);
  }});
  $jscomp.initSymbolIterator = function() {
  };
};
$jscomp.arrayIterator = function(v) {
  var f = 0;
  return $jscomp.iteratorPrototype(function() {
    return f < v.length ? {done:!1, value:v[f++]} : {done:!0};
  });
};
$jscomp.iteratorPrototype = function(v) {
  $jscomp.initSymbolIterator();
  v = {next:v};
  v[$jscomp.global.Symbol.iterator] = function() {
    return this;
  };
  return v;
};
$jscomp.iteratorFromArray = function(v, f) {
  $jscomp.initSymbolIterator();
  v instanceof String && (v += "");
  var k = 0, q = {next:function() {
    if (k < v.length) {
      var d = k++;
      return {value:f(d, v[d]), done:!1};
    }
    q.next = function() {
      return {done:!0, value:void 0};
    };
    return q.next();
  }};
  q[Symbol.iterator] = function() {
    return q;
  };
  return q;
};
$jscomp.polyfill("Array.prototype.values", function(v) {
  return v ? v : function() {
    return $jscomp.iteratorFromArray(this, function(f, k) {
      return k;
    });
  };
}, "es8", "es3");
$jscomp.polyfill("Array.prototype.keys", function(v) {
  return v ? v : function() {
    return $jscomp.iteratorFromArray(this, function(f) {
      return f;
    });
  };
}, "es6", "es3");
(function(v) {
  function f(a) {
    h.debug && console.log("Graph created");
    this.list_of_graphcanvas = null;
    this.clear();
    a && this.configure(a);
  }
  function k(a) {
    this._ctor(a);
  }
  function q(a) {
    this._ctor(a);
  }
  function d(a, c, e) {
    e = e || {};
    this.background_image = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=";
    a && a.constructor === String && (a = document.querySelector(a));
    this.max_zoom = 10;
    this.min_zoom = 0.1;
    this.zoom_modify_alpha = !0;
    this.title_text_font = "bold " + h.NODE_TEXT_SIZE + "px Arial";
    this.inner_text_font = "normal " + h.NODE_SUBTEXT_SIZE + "px Arial";
    this.node_title_color = h.NODE_TITLE_COLOR;
    this.default_link_color = h.LINK_COLOR;
    this.default_connection_color = {input_off:"#AAB", input_on:"#7F7", output_off:"#AAB", output_on:"#7F7"};
    this.highquality_render = !0;
    this.use_gradients = !1;
    this.editor_alpha = 1;
    this.pause_rendering = !1;
    this.render_only_selected = this.clear_background = this.render_shadows = !0;
    this.live_mode = !1;
    this.allow_searchbox = this.allow_interaction = this.allow_dragnodes = this.allow_dragcanvas = this.show_info = !0;
    this.drag_mode = this.allow_reconnect_links = !1;
    this.filter = this.dragging_rectangle = null;
    this.always_render_background = !1;
    this.render_canvas_border = !0;
    this.render_connections_shadows = !1;
    this.render_connection_arrows = this.render_curved_connections = this.render_connections_border = !0;
    this.render_execution_order = !1;
    this.canvas_mouse = [0, 0];
    this.onDrawOverlay = this.onDrawForeground = this.onDrawBackground = this.onMouse = this.onSearchBoxSelection = this.onSearchBox = null;
    this.connections_width = 3;
    this.round_radius = 8;
    this.node_widget = this.current_node = null;
    this.last_mouse_position = [0, 0];
    this.visible_area = new Float32Array(4);
    c && c.attachCanvas(this);
    this.setCanvas(a);
    this.clear();
    e.skip_render || this.startRendering();
    this.autoresize = e.autoresize;
  }
  function t(a, c) {
    return Math.sqrt((c[0] - a[0]) * (c[0] - a[0]) + (c[1] - a[1]) * (c[1] - a[1]));
  }
  function u(a, c, e, b, g, l) {
    return e < a && e + g > a && b < c && b + l > c ? !0 : !1;
  }
  function x(a, c) {
    var e = a[0] + a[2], b = a[1] + a[3], g = c[1] + c[3];
    return a[0] > c[0] + c[2] || a[1] > g || e < c[0] || b < c[1] ? !1 : !0;
  }
  function w(a, c) {
    function e(a) {
      var c = parseInt(g.style.top);
      g.style.top = (c + 0.1 * a.deltaY).toFixed() + "px";
      a.preventDefault();
      return !0;
    }
    this.options = c = c || {};
    var b = this;
    c.parentMenu && (c.parentMenu.constructor !== this.constructor ? (console.error("parentMenu must be of class ContextMenu, ignoring it"), c.parentMenu = null) : (this.parentMenu = c.parentMenu, this.parentMenu.lock = !0, this.parentMenu.current_submenu = this));
    c.event && c.event.constructor !== MouseEvent && c.event.constructor !== CustomEvent && (console.error("Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it."), c.event = null);
    var g = document.createElement("div");
    g.className = "litegraph litecontextmenu litemenubar-panel";
    c.className && (g.className += " " + c.className);
    g.style.minWidth = 100;
    g.style.minHeight = 100;
    g.style.pointerEvents = "none";
    setTimeout(function() {
      g.style.pointerEvents = "auto";
    }, 100);
    g.addEventListener("mouseup", function(a) {
      a.preventDefault();
      return !0;
    }, !0);
    g.addEventListener("contextmenu", function(a) {
      if (2 != a.button) {
        return !1;
      }
      a.preventDefault();
      return !1;
    }, !0);
    g.addEventListener("mousedown", function(a) {
      if (2 == a.button) {
        return b.close(), a.preventDefault(), !0;
      }
    }, !0);
    g.addEventListener("wheel", e, !0);
    g.addEventListener("mousewheel", e, !0);
    this.root = g;
    if (c.title) {
      var l = document.createElement("div");
      l.className = "litemenu-title";
      l.innerHTML = c.title;
      g.appendChild(l);
    }
    l = 0;
    for (var n in a) {
      var h = a.constructor == Array ? a[n] : n;
      null != h && h.constructor !== String && (h = void 0 === h.content ? String(h) : h.content);
      this.addItem(h, a[n], c);
      l++;
    }
    g.addEventListener("mouseleave", function(a) {
      b.lock || (g.closing_timer && clearTimeout(g.closing_timer), g.closing_timer = setTimeout(b.close.bind(b, a), 500));
    });
    g.addEventListener("mouseenter", function(a) {
      g.closing_timer && clearTimeout(g.closing_timer);
    });
    a = document;
    c.event && (a = c.event.target.ownerDocument);
    a || (a = document);
    a.body.appendChild(g);
    n = c.left || 0;
    a = c.top || 0;
    c.event && (n = c.event.pageX - 10, a = c.event.pageY - 10, c.title && (a -= 20), c.parentMenu && (c = c.parentMenu.root.getBoundingClientRect(), n = c.left + c.width), c = document.body.getBoundingClientRect(), l = g.getBoundingClientRect(), n > c.width - l.width - 10 && (n = c.width - l.width - 10), a > c.height - l.height - 10 && (a = c.height - l.height - 10));
    g.style.left = n + "px";
    g.style.top = a + "px";
  }
  var h = v.LiteGraph = {CANVAS_GRID_SIZE:10, NODE_TITLE_HEIGHT:20, NODE_SLOT_HEIGHT:15, NODE_WIDGET_HEIGHT:20, NODE_WIDTH:140, NODE_MIN_WIDTH:50, NODE_COLLAPSED_RADIUS:10, NODE_COLLAPSED_WIDTH:80, NODE_TITLE_COLOR:"#999", NODE_TEXT_SIZE:14, NODE_TEXT_COLOR:"#AAA", NODE_SUBTEXT_SIZE:12, NODE_DEFAULT_COLOR:"#333", NODE_DEFAULT_BGCOLOR:"#444", NODE_DEFAULT_BOXCOLOR:"#666", NODE_DEFAULT_SHAPE:"box", DEFAULT_SHADOW_COLOR:"rgba(0,0,0,0.5)", DEFAULT_GROUP_FONT:24, LINK_COLOR:"#AAD", EVENT_LINK_COLOR:"#F85", 
  CONNECTING_LINK_COLOR:"#AFA", MAX_NUMBER_OF_NODES:1000, DEFAULT_POSITION:[100, 100], VALID_SHAPES:["default", "box", "round", "card"], BOX_SHAPE:1, ROUND_SHAPE:2, CIRCLE_SHAPE:3, CARD_SHAPE:4, ARROW_SHAPE:5, INPUT:1, OUTPUT:2, EVENT:-1, ACTION:-1, ALWAYS:0, ON_EVENT:1, NEVER:2, ON_TRIGGER:3, UP:1, DOWN:2, LEFT:3, RIGHT:4, CENTER:5, NORMAL_TITLE:0, NO_TITLE:1, TRANSPARENT_TITLE:2, AUTOHIDE_TITLE:3, proxy:null, node_images_path:"", debug:!1, throw_errors:!0, allow_scripts:!1, registered_node_types:{}, 
  node_types_by_file_extension:{}, Nodes:{}, searchbox_extras:{}, registerNodeType:function(a, c) {
    if (!c.prototype) {
      throw "Cannot register a simple object, it must be a class with a prototype";
    }
    c.type = a;
    h.debug && console.log("Node registered: " + a);
    a.split("/");
    var e = c.name, b = a.lastIndexOf("/");
    c.category = a.substr(0, b);
    c.title || (c.title = e);
    if (c.prototype) {
      for (var g in k.prototype) {
        c.prototype[g] || (c.prototype[g] = k.prototype[g]);
      }
    }
    Object.defineProperty(c.prototype, "shape", {set:function(a) {
      switch(a) {
        case "default":
          delete this._shape;
          break;
        case "box":
          this._shape = h.BOX_SHAPE;
          break;
        case "round":
          this._shape = h.ROUND_SHAPE;
          break;
        case "circle":
          this._shape = h.CIRCLE_SHAPE;
          break;
        case "card":
          this._shape = h.CARD_SHAPE;
          break;
        default:
          this._shape = a;
      }
    }, get:function(a) {
      return this._shape;
    }, enumerable:!0});
    this.registered_node_types[a] = c;
    c.constructor.name && (this.Nodes[e] = c);
    c.prototype.onPropertyChange && console.warn("LiteGraph node class " + a + " has onPropertyChange method, it must be called onPropertyChanged with d at the end");
    if (c.supported_extensions) {
      for (g in c.supported_extensions) {
        this.node_types_by_file_extension[c.supported_extensions[g].toLowerCase()] = c;
      }
    }
  }, wrapFunctionAsNode:function(a, c, e, b) {
    for (var g = Array(c.length), z = "", n = h.getParameterNames(c), d = 0; d < n.length; ++d) {
      z += "this.addInput('" + n[d] + "'," + (e && e[d] ? "'" + e[d] + "'" : "0") + ");\n";
    }
    e = Function(z + ("this.addOutput('out'," + (b ? "'" + b + "'" : 0) + ");\n"));
    e.title = a.split("/").pop();
    e.desc = "Generated from " + c.name;
    e.prototype.onExecute = function() {
      for (var a = 0; a < g.length; ++a) {
        g[a] = this.getInputData(a);
      }
      a = c.apply(this, g);
      this.setOutputData(0, a);
    };
    this.registerNodeType(a, e);
  }, addNodeMethod:function(a, c) {
    k.prototype[a] = c;
    for (var e in this.registered_node_types) {
      var b = this.registered_node_types[e];
      b.prototype[a] && (b.prototype["_" + a] = b.prototype[a]);
      b.prototype[a] = c;
    }
  }, createNode:function(a, c, e) {
    var b = this.registered_node_types[a];
    if (!b) {
      return h.debug && console.log('GraphNode type "' + a + '" not registered.'), null;
    }
    c = c || b.title || a;
    b = new b(c);
    b.type = a;
    !b.title && c && (b.title = c);
    b.properties || (b.properties = {});
    b.properties_info || (b.properties_info = []);
    b.flags || (b.flags = {});
    b.size || (b.size = b.computeSize());
    b.pos || (b.pos = h.DEFAULT_POSITION.concat());
    b.mode || (b.mode = h.ALWAYS);
    if (e) {
      for (var g in e) {
        b[g] = e[g];
      }
    }
    return b;
  }, getNodeType:function(a) {
    return this.registered_node_types[a];
  }, getNodeTypesInCategory:function(a, c) {
    var e = [], b;
    for (b in this.registered_node_types) {
      var g = this.registered_node_types[b];
      c && g.filter && g.filter != c || ("" == a ? null == g.category && e.push(g) : g.category == a && e.push(g));
    }
    return e;
  }, getNodeTypesCategories:function() {
    var a = {"":1}, c;
    for (c in this.registered_node_types) {
      this.registered_node_types[c].category && !this.registered_node_types[c].skip_list && (a[this.registered_node_types[c].category] = 1);
    }
    var e = [];
    for (c in a) {
      e.push(c);
    }
    return e;
  }, reloadNodes:function(a) {
    var c = document.getElementsByTagName("script"), e = [], b;
    for (b in c) {
      e.push(c[b]);
    }
    c = document.getElementsByTagName("head")[0];
    a = document.location.href + a;
    for (b in e) {
      var g = e[b].src;
      if (g && g.substr(0, a.length) == a) {
        try {
          h.debug && console.log("Reloading: " + g);
          var l = document.createElement("script");
          l.type = "text/javascript";
          l.src = g;
          c.appendChild(l);
          c.removeChild(e[b]);
        } catch (n) {
          if (h.throw_errors) {
            throw n;
          }
          h.debug && console.log("Error while reloading " + g);
        }
      }
    }
    h.debug && console.log("Nodes reloaded");
  }, cloneObject:function(a, c) {
    if (null == a) {
      return null;
    }
    a = JSON.parse(JSON.stringify(a));
    if (!c) {
      return a;
    }
    for (var e in a) {
      c[e] = a[e];
    }
    return c;
  }, isValidConnection:function(a, c) {
    if (!a || !c || a == c || a == h.EVENT && c == h.ACTION) {
      return !0;
    }
    a = String(a);
    c = String(c);
    a = a.toLowerCase();
    c = c.toLowerCase();
    if (-1 == a.indexOf(",") && -1 == c.indexOf(",")) {
      return a == c;
    }
    a = a.split(",");
    c = c.split(",");
    for (var e = 0; e < a.length; ++e) {
      for (var b = 0; b < c.length; ++b) {
        if (a[e] == c[b]) {
          return !0;
        }
      }
    }
    return !1;
  }, registerSearchboxExtra:function(a, c, e) {
    this.searchbox_extras[c] = {type:a, desc:c, data:e};
  }};
  h.getTime = "undefined" != typeof performance ? performance.now.bind(performance) : "undefined" != typeof Date && Date.now ? Date.now.bind(Date) : "undefined" != typeof process ? function() {
    var a = process.hrtime();
    return 0.001 * a[0] + 1e-6 * a[1];
  } : function() {
    return (new Date).getTime();
  };
  v.LGraph = h.LGraph = f;
  f.supported_types = ["number", "string", "boolean"];
  f.prototype.getSupportedTypes = function() {
    return this.supported_types || f.supported_types;
  };
  f.STATUS_STOPPED = 1;
  f.STATUS_RUNNING = 2;
  f.prototype.clear = function() {
    this.stop();
    this.status = f.STATUS_STOPPED;
    this.last_link_id = this.last_node_id = 1;
    this._version = -1;
    if (this._nodes) {
      for (var a = 0; a < this._nodes.length; ++a) {
        var c = this._nodes[a];
        if (c.onRemoved) {
          c.onRemoved();
        }
      }
    }
    this._nodes = [];
    this._nodes_by_id = {};
    this._nodes_in_order = [];
    this._nodes_executable = null;
    this._groups = [];
    this.links = {};
    this.iteration = 0;
    this.config = {};
    this.fixedtime = this.runningtime = this.globaltime = 0;
    this.elapsed_time = this.fixedtime_lapse = 0.01;
    this.starttime = this.last_update_time = 0;
    this.catch_errors = !0;
    this.global_inputs = {};
    this.global_outputs = {};
    this.change();
    this.sendActionToCanvas("clear");
  };
  f.prototype.attachCanvas = function(a) {
    if (a.constructor != d) {
      throw "attachCanvas expects a LGraphCanvas instance";
    }
    a.graph && a.graph != this && a.graph.detachCanvas(a);
    a.graph = this;
    this.list_of_graphcanvas || (this.list_of_graphcanvas = []);
    this.list_of_graphcanvas.push(a);
  };
  f.prototype.detachCanvas = function(a) {
    if (this.list_of_graphcanvas) {
      var c = this.list_of_graphcanvas.indexOf(a);
      -1 != c && (a.graph = null, this.list_of_graphcanvas.splice(c, 1));
    }
  };
  f.prototype.start = function(a) {
    if (this.status != f.STATUS_RUNNING) {
      this.status = f.STATUS_RUNNING;
      if (this.onPlayEvent) {
        this.onPlayEvent();
      }
      this.sendEventToAllNodes("onStart");
      this.last_update_time = this.starttime = h.getTime();
      a = a || 0;
      var c = this;
      if (0 == a && "undefined" != typeof window && window.requestAnimationFrame) {
        var e = function() {
          -1 == c.execution_timer_id && (window.requestAnimationFrame(e), c.runStep(1, !this.catch_errors));
        };
        this.execution_timer_id = -1;
        e();
      } else {
        this.execution_timer_id = setInterval(function() {
          c.runStep(1, !this.catch_errors);
        }, a);
      }
    }
  };
  f.prototype.stop = function() {
    if (this.status != f.STATUS_STOPPED) {
      this.status = f.STATUS_STOPPED;
      if (this.onStopEvent) {
        this.onStopEvent();
      }
      null != this.execution_timer_id && (-1 != this.execution_timer_id && clearInterval(this.execution_timer_id), this.execution_timer_id = null);
      this.sendEventToAllNodes("onStop");
    }
  };
  f.prototype.runStep = function(a, c) {
    a = a || 1;
    var e = h.getTime();
    this.globaltime = 0.001 * (e - this.starttime);
    var b = this._nodes_executable ? this._nodes_executable : this._nodes;
    if (b) {
      if (c) {
        for (var g = 0; g < a; g++) {
          for (var l = 0, n = b.length; l < n; ++l) {
            var d = b[l];
            if (d.mode == h.ALWAYS && d.onExecute) {
              d.onExecute();
            }
          }
          this.fixedtime += this.fixedtime_lapse;
          if (this.onExecuteStep) {
            this.onExecuteStep();
          }
        }
        if (this.onAfterExecute) {
          this.onAfterExecute();
        }
      } else {
        try {
          for (g = 0; g < a; g++) {
            l = 0;
            for (n = b.length; l < n; ++l) {
              if (d = b[l], d.mode == h.ALWAYS && d.onExecute) {
                d.onExecute();
              }
            }
            this.fixedtime += this.fixedtime_lapse;
            if (this.onExecuteStep) {
              this.onExecuteStep();
            }
          }
          if (this.onAfterExecute) {
            this.onAfterExecute();
          }
          this.errors_in_execution = !1;
        } catch (G) {
          this.errors_in_execution = !0;
          if (h.throw_errors) {
            throw G;
          }
          h.debug && console.log("Error during execution: " + G);
          this.stop();
        }
      }
      a = h.getTime();
      e = a - e;
      0 == e && (e = 1);
      this.execution_time = 0.001 * e;
      this.globaltime += 0.001 * e;
      this.iteration += 1;
      this.elapsed_time = 0.001 * (a - this.last_update_time);
      this.last_update_time = a;
    }
  };
  f.prototype.updateExecutionOrder = function() {
    this._nodes_in_order = this.computeExecutionOrder(!1);
    this._nodes_executable = [];
    for (var a = 0; a < this._nodes_in_order.length; ++a) {
      this._nodes_in_order[a].onExecute && this._nodes_executable.push(this._nodes_in_order[a]);
    }
  };
  f.prototype.computeExecutionOrder = function(a, c) {
    for (var e = [], b = [], g = {}, l = {}, n = {}, d = 0, m = this._nodes.length; d < m; ++d) {
      var f = this._nodes[d];
      if (!a || f.onExecute) {
        g[f.id] = f;
        var p = 0;
        if (f.inputs) {
          for (var k = 0, q = f.inputs.length; k < q; k++) {
            f.inputs[k] && null != f.inputs[k].link && (p += 1);
          }
        }
        0 == p ? (b.push(f), c && (f._level = 1)) : (c && (f._level = 0), n[f.id] = p);
      }
    }
    for (; 0 != b.length;) {
      if (f = b.shift(), e.push(f), delete g[f.id], f.outputs) {
        for (d = 0; d < f.outputs.length; d++) {
          if (a = f.outputs[d], null != a && null != a.links && 0 != a.links.length) {
            for (k = 0; k < a.links.length; k++) {
              (m = this.links[a.links[k]]) && !l[m.id] && (p = this.getNodeById(m.target_id), null == p ? l[m.id] = !0 : (c && (!p._level || p._level <= f._level) && (p._level = f._level + 1), l[m.id] = !0, --n[p.id], 0 == n[p.id] && b.push(p)));
            }
          }
        }
      }
    }
    for (d in g) {
      e.push(g[d]);
    }
    e.length != this._nodes.length && h.debug && console.warn("something went wrong, nodes missing");
    m = e.length;
    for (d = 0; d < m; ++d) {
      e[d].order = d;
    }
    e = e.sort(function(a, c) {
      var e = a.constructor.priority || a.priority || 0, b = c.constructor.priority || c.priority || 0;
      return e == b ? a.order - c.order : e - b;
    });
    for (d = 0; d < m; ++d) {
      e[d].order = d;
    }
    return e;
  };
  f.prototype.getAncestors = function(a) {
    for (var c = [], e = [a], b = {}; e.length;) {
      var g = e.shift();
      if (g.inputs) {
        b[g.id] || g == a || (b[g.id] = !0, c.push(g));
        for (var l = 0; l < g.inputs.length; ++l) {
          var n = g.getInputNode(l);
          n && -1 == c.indexOf(n) && e.push(n);
        }
      }
    }
    c.sort(function(a, c) {
      return a.order - c.order;
    });
    return c;
  };
  f.prototype.arrange = function(a) {
    a = a || 40;
    for (var c = this.computeExecutionOrder(!1, !0), e = [], b = 0; b < c.length; ++b) {
      var g = c[b], l = g._level || 1;
      e[l] || (e[l] = []);
      e[l].push(g);
    }
    c = a;
    for (b = 0; b < e.length; ++b) {
      if (l = e[b]) {
        for (var n = 100, h = a, d = 0; d < l.length; ++d) {
          g = l[d], g.pos[0] = c, g.pos[1] = h, g.size[0] > n && (n = g.size[0]), h += g.size[1] + a;
        }
        c += n + a;
      }
    }
    this.setDirtyCanvas(!0, !0);
  };
  f.prototype.getTime = function() {
    return this.globaltime;
  };
  f.prototype.getFixedTime = function() {
    return this.fixedtime;
  };
  f.prototype.getElapsedTime = function() {
    return this.elapsed_time;
  };
  f.prototype.sendEventToAllNodes = function(a, c, e) {
    e = e || h.ALWAYS;
    var b = this._nodes_in_order ? this._nodes_in_order : this._nodes;
    if (b) {
      for (var g = 0, l = b.length; g < l; ++g) {
        var n = b[g];
        if (n[a] && n.mode == e) {
          if (void 0 === c) {
            n[a]();
          } else {
            if (c && c.constructor === Array) {
              n[a].apply(n, c);
            } else {
              n[a](c);
            }
          }
        }
      }
    }
  };
  f.prototype.sendActionToCanvas = function(a, c) {
    if (this.list_of_graphcanvas) {
      for (var e = 0; e < this.list_of_graphcanvas.length; ++e) {
        var b = this.list_of_graphcanvas[e];
        b[a] && b[a].apply(b, c);
      }
    }
  };
  f.prototype.add = function(a, c) {
    if (a) {
      if (a.constructor === q) {
        this._groups.push(a), this.setDirtyCanvas(!0), this.change(), a.graph = this, this._version++;
      } else {
        -1 != a.id && null != this._nodes_by_id[a.id] && (console.warn("LiteGraph: there is already a node with this ID, changing it"), a.id = ++this.last_node_id);
        if (this._nodes.length >= h.MAX_NUMBER_OF_NODES) {
          throw "LiteGraph: max number of nodes in a graph reached";
        }
        null == a.id || -1 == a.id ? a.id = ++this.last_node_id : this.last_node_id < a.id && (this.last_node_id = a.id);
        a.graph = this;
        this._version++;
        this._nodes.push(a);
        this._nodes_by_id[a.id] = a;
        if (a.onAdded) {
          a.onAdded(this);
        }
        this.config.align_to_grid && a.alignToGrid();
        c || this.updateExecutionOrder();
        if (this.onNodeAdded) {
          this.onNodeAdded(a);
        }
        this.setDirtyCanvas(!0);
        this.change();
        return a;
      }
    }
  };
  f.prototype.remove = function(a) {
    if (a.constructor === h.LGraphGroup) {
      var c = this._groups.indexOf(a);
      -1 != c && this._groups.splice(c, 1);
      a.graph = null;
      this._version++;
      this.setDirtyCanvas(!0, !0);
      this.change();
    } else {
      if (null != this._nodes_by_id[a.id] && !a.ignore_remove) {
        if (a.inputs) {
          for (c = 0; c < a.inputs.length; c++) {
            var e = a.inputs[c];
            null != e.link && a.disconnectInput(c);
          }
        }
        if (a.outputs) {
          for (c = 0; c < a.outputs.length; c++) {
            e = a.outputs[c], null != e.links && e.links.length && a.disconnectOutput(c);
          }
        }
        if (a.onRemoved) {
          a.onRemoved();
        }
        a.graph = null;
        this._version++;
        if (this.list_of_graphcanvas) {
          for (c = 0; c < this.list_of_graphcanvas.length; ++c) {
            e = this.list_of_graphcanvas[c], e.selected_nodes[a.id] && delete e.selected_nodes[a.id], e.node_dragged == a && (e.node_dragged = null);
          }
        }
        c = this._nodes.indexOf(a);
        -1 != c && this._nodes.splice(c, 1);
        delete this._nodes_by_id[a.id];
        if (this.onNodeRemoved) {
          this.onNodeRemoved(a);
        }
        this.setDirtyCanvas(!0, !0);
        this.change();
        this.updateExecutionOrder();
      }
    }
  };
  f.prototype.getNodeById = function(a) {
    return null == a ? null : this._nodes_by_id[a];
  };
  f.prototype.findNodesByClass = function(a) {
    for (var c = [], e = 0, b = this._nodes.length; e < b; ++e) {
      this._nodes[e].constructor === a && c.push(this._nodes[e]);
    }
    return c;
  };
  f.prototype.findNodesByType = function(a) {
    a = a.toLowerCase();
    for (var c = [], e = 0, b = this._nodes.length; e < b; ++e) {
      this._nodes[e].type.toLowerCase() == a && c.push(this._nodes[e]);
    }
    return c;
  };
  f.prototype.findNodesByTitle = function(a) {
    for (var c = [], e = 0, b = this._nodes.length; e < b; ++e) {
      this._nodes[e].title == a && c.push(this._nodes[e]);
    }
    return c;
  };
  f.prototype.getNodeOnPos = function(a, c, e, b) {
    e = e || this._nodes;
    for (var g = e.length - 1; 0 <= g; g--) {
      var l = e[g];
      if (l.isPointInside(a, c, b)) {
        return l;
      }
    }
    return null;
  };
  f.prototype.getGroupOnPos = function(a, c) {
    for (var e = this._groups.length - 1; 0 <= e; e--) {
      var b = this._groups[e];
      if (b.isPointInside(a, c, 2, !0)) {
        return b;
      }
    }
    return null;
  };
  f.prototype.addGlobalInput = function(a, c, e) {
    this.global_inputs[a] = {name:a, type:c, value:e};
    this._version++;
    if (this.onGlobalInputAdded) {
      this.onGlobalInputAdded(a, c);
    }
    if (this.onGlobalsChange) {
      this.onGlobalsChange();
    }
  };
  f.prototype.setGlobalInputData = function(a, c) {
    if (a = this.global_inputs[a]) {
      a.value = c;
    }
  };
  f.prototype.setInputData = f.prototype.setGlobalInputData;
  f.prototype.getGlobalInputData = function(a) {
    return (a = this.global_inputs[a]) ? a.value : null;
  };
  f.prototype.renameGlobalInput = function(a, c) {
    if (c != a) {
      if (!this.global_inputs[a]) {
        return !1;
      }
      if (this.global_inputs[c]) {
        return console.error("there is already one input with that name"), !1;
      }
      this.global_inputs[c] = this.global_inputs[a];
      delete this.global_inputs[a];
      this._version++;
      if (this.onGlobalInputRenamed) {
        this.onGlobalInputRenamed(a, c);
      }
      if (this.onGlobalsChange) {
        this.onGlobalsChange();
      }
    }
  };
  f.prototype.changeGlobalInputType = function(a, c) {
    if (!this.global_inputs[a]) {
      return !1;
    }
    if (!this.global_inputs[a].type || this.global_inputs[a].type.toLowerCase() != c.toLowerCase()) {
      if (this.global_inputs[a].type = c, this._version++, this.onGlobalInputTypeChanged) {
        this.onGlobalInputTypeChanged(a, c);
      }
    }
  };
  f.prototype.removeGlobalInput = function(a) {
    if (!this.global_inputs[a]) {
      return !1;
    }
    delete this.global_inputs[a];
    this._version++;
    if (this.onGlobalInputRemoved) {
      this.onGlobalInputRemoved(a);
    }
    if (this.onGlobalsChange) {
      this.onGlobalsChange();
    }
    return !0;
  };
  f.prototype.addGlobalOutput = function(a, c, e) {
    this.global_outputs[a] = {name:a, type:c, value:e};
    this._version++;
    if (this.onGlobalOutputAdded) {
      this.onGlobalOutputAdded(a, c);
    }
    if (this.onGlobalsChange) {
      this.onGlobalsChange();
    }
  };
  f.prototype.setGlobalOutputData = function(a, c) {
    if (a = this.global_outputs[a]) {
      a.value = c;
    }
  };
  f.prototype.getGlobalOutputData = function(a) {
    return (a = this.global_outputs[a]) ? a.value : null;
  };
  f.prototype.getOutputData = f.prototype.getGlobalOutputData;
  f.prototype.renameGlobalOutput = function(a, c) {
    if (!this.global_outputs[a]) {
      return !1;
    }
    if (this.global_outputs[c]) {
      return console.error("there is already one output with that name"), !1;
    }
    this.global_outputs[c] = this.global_outputs[a];
    delete this.global_outputs[a];
    this._version++;
    if (this.onGlobalOutputRenamed) {
      this.onGlobalOutputRenamed(a, c);
    }
    if (this.onGlobalsChange) {
      this.onGlobalsChange();
    }
  };
  f.prototype.changeGlobalOutputType = function(a, c) {
    if (!this.global_outputs[a]) {
      return !1;
    }
    if (!this.global_outputs[a].type || this.global_outputs[a].type.toLowerCase() != c.toLowerCase()) {
      if (this.global_outputs[a].type = c, this._version++, this.onGlobalOutputTypeChanged) {
        this.onGlobalOutputTypeChanged(a, c);
      }
    }
  };
  f.prototype.removeGlobalOutput = function(a) {
    if (!this.global_outputs[a]) {
      return !1;
    }
    delete this.global_outputs[a];
    this._version++;
    if (this.onGlobalOutputRemoved) {
      this.onGlobalOutputRemoved(a);
    }
    if (this.onGlobalsChange) {
      this.onGlobalsChange();
    }
    return !0;
  };
  f.prototype.triggerInput = function(a, c) {
    a = this.findNodesByTitle(a);
    for (var e = 0; e < a.length; ++e) {
      a[e].onTrigger(c);
    }
  };
  f.prototype.setCallback = function(a, c) {
    a = this.findNodesByTitle(a);
    for (var e = 0; e < a.length; ++e) {
      a[e].setTrigger(c);
    }
  };
  f.prototype.connectionChange = function(a, c) {
    this.updateExecutionOrder();
    if (this.onConnectionChange) {
      this.onConnectionChange(a);
    }
    this._version++;
    this.sendActionToCanvas("onConnectionChange");
  };
  f.prototype.isLive = function() {
    if (!this.list_of_graphcanvas) {
      return !1;
    }
    for (var a = 0; a < this.list_of_graphcanvas.length; ++a) {
      if (this.list_of_graphcanvas[a].live_mode) {
        return !0;
      }
    }
    return !1;
  };
  f.prototype.clearTriggeredSlots = function() {
    for (var a in this.links) {
      var c = this.links[a];
      c && c._last_time && (c._last_time = 0);
    }
  };
  f.prototype.change = function() {
    h.debug && console.log("Graph changed");
    this.sendActionToCanvas("setDirty", [!0, !0]);
    if (this.on_change) {
      this.on_change(this);
    }
  };
  f.prototype.setDirtyCanvas = function(a, c) {
    this.sendActionToCanvas("setDirty", [a, c]);
  };
  f.prototype.serialize = function() {
    for (var a = [], c = 0, e = this._nodes.length; c < e; ++c) {
      a.push(this._nodes[c].serialize());
    }
    e = [];
    for (c in this.links) {
      var b = this.links[c];
      e.push([b.id, b.origin_id, b.origin_slot, b.target_id, b.target_slot, b.type]);
    }
    b = [];
    for (c = 0; c < this._groups.length; ++c) {
      b.push(this._groups[c].serialize());
    }
    return {last_node_id:this.last_node_id, last_link_id:this.last_link_id, nodes:a, links:e, groups:b, config:this.config};
  };
  f.prototype.configure = function(a, c) {
    if (a) {
      c || this.clear();
      c = a.nodes;
      if (a.links && a.links.constructor === Array) {
        for (var e = [], b = 0; b < a.links.length; ++b) {
          var g = a.links[b];
          e[g[0]] = {id:g[0], origin_id:g[1], origin_slot:g[2], target_id:g[3], target_slot:g[4], type:g[5]};
        }
        a.links = e;
      }
      for (b in a) {
        this[b] = a[b];
      }
      e = !1;
      this._nodes = [];
      if (c) {
        b = 0;
        for (g = c.length; b < g; ++b) {
          var l = c[b], n = h.createNode(l.type, l.title);
          n ? (n.id = l.id, this.add(n, !0)) : (h.debug && console.log("Node not found: " + l.type), e = !0);
        }
        b = 0;
        for (g = c.length; b < g; ++b) {
          l = c[b], (n = this.getNodeById(l.id)) && n.configure(l);
        }
      }
      this._groups.length = 0;
      if (a.groups) {
        for (b = 0; b < a.groups.length; ++b) {
          c = new h.LGraphGroup, c.configure(a.groups[b]), this.add(c);
        }
      }
      this.updateExecutionOrder();
      this._version++;
      this.setDirtyCanvas(!0, !0);
      return e;
    }
  };
  f.prototype.load = function(a) {
    var c = this, e = new XMLHttpRequest;
    e.open("GET", a, !0);
    e.send(null);
    e.onload = function(a) {
      200 !== e.status ? console.error("Error loading graph:", e.status, e.response) : (a = JSON.parse(e.response), c.configure(a));
    };
    e.onerror = function(a) {
      console.error("Error loading graph:", a);
    };
  };
  f.prototype.onNodeTrace = function(a, c, e) {
  };
  v.LGraphNode = h.LGraphNode = k;
  k.prototype._ctor = function(a) {
    this.title = a || "Unnamed";
    this.size = [h.NODE_WIDTH, 60];
    this.graph = null;
    this._pos = new Float32Array(10, 10);
    Object.defineProperty(this, "pos", {set:function(a) {
      !a || 2 > a.length || (this._pos[0] = a[0], this._pos[1] = a[1]);
    }, get:function() {
      return this._pos;
    }, enumerable:!0});
    this.id = -1;
    this.type = null;
    this.inputs = [];
    this.outputs = [];
    this.connections = [];
    this.properties = {};
    this.properties_info = [];
    this.flags = {};
  };
  k.prototype.configure = function(a) {
    this.graph && this.graph._version++;
    for (var c in a) {
      if ("console" != c) {
        if ("properties" == c) {
          for (var e in a.properties) {
            if (this.properties[e] = a.properties[e], this.onPropertyChanged) {
              this.onPropertyChanged(e, a.properties[e]);
            }
          }
        } else {
          null != a[c] && ("object" == typeof a[c] ? this[c] && this[c].configure ? this[c].configure(a[c]) : this[c] = h.cloneObject(a[c], this[c]) : this[c] = a[c]);
        }
      }
    }
    a.title || (this.title = this.constructor.title);
    if (this.onConnectionsChange) {
      if (this.inputs) {
        for (var b = 0; b < this.inputs.length; ++b) {
          e = this.inputs[b];
          var g = this.graph ? this.graph.links[e.link] : null;
          this.onConnectionsChange(h.INPUT, b, !0, g, e);
        }
      }
      if (this.outputs) {
        for (b = 0; b < this.outputs.length; ++b) {
          if (e = this.outputs[b], e.links) {
            for (c = 0; c < e.links.length; ++c) {
              g = this.graph ? this.graph.links[e.links[c]] : null, this.onConnectionsChange(h.OUTPUT, b, !0, g, e);
            }
          }
        }
      }
    }
    for (b in this.inputs) {
      e = this.inputs[b], e.link && e.link.length && (g = e.link, "object" == typeof g && (e.link = g[0], this.graph && (this.graph.links[g[0]] = {id:g[0], origin_id:g[1], origin_slot:g[2], target_id:g[3], target_slot:g[4]})));
    }
    for (b in this.outputs) {
      if (e = this.outputs[b], e.links && 0 != e.links.length) {
        for (c in e.links) {
          g = e.links[c], "object" == typeof g && (e.links[c] = g[0]);
        }
      }
    }
    if (this.onConfigure) {
      this.onConfigure(a);
    }
  };
  k.prototype.serialize = function() {
    var a = {id:this.id, type:this.type, pos:this.pos, size:this.size, flags:h.cloneObject(this.flags), mode:this.mode};
    this.inputs && (a.inputs = this.inputs);
    if (this.outputs) {
      for (var c = 0; c < this.outputs.length; c++) {
        delete this.outputs[c]._data;
      }
      a.outputs = this.outputs;
    }
    this.title && this.title != this.constructor.title && (a.title = this.title);
    this.properties && (a.properties = h.cloneObject(this.properties));
    a.type || (a.type = this.constructor.type);
    this.color && (a.color = this.color);
    this.bgcolor && (a.bgcolor = this.bgcolor);
    this.boxcolor && (a.boxcolor = this.boxcolor);
    this.shape && (a.shape = this.shape);
    this.onSerialize && this.onSerialize(a) && console.warn("node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter");
    return a;
  };
  k.prototype.clone = function() {
    var a = h.createNode(this.type), c = h.cloneObject(this.serialize());
    if (c.inputs) {
      for (var e = 0; e < c.inputs.length; ++e) {
        c.inputs[e].link = null;
      }
    }
    if (c.outputs) {
      for (e = 0; e < c.outputs.length; ++e) {
        c.outputs[e].links && (c.outputs[e].links.length = 0);
      }
    }
    delete c.id;
    a.configure(c);
    return a;
  };
  k.prototype.toString = function() {
    return JSON.stringify(this.serialize());
  };
  k.prototype.getTitle = function() {
    return this.title || this.constructor.title;
  };
  k.prototype.setOutputData = function(a, c) {
    if (this.outputs && !(-1 == a || a >= this.outputs.length)) {
      var e = this.outputs[a];
      if (e && (e._data = c, this.outputs[a].links)) {
        for (e = 0; e < this.outputs[a].links.length; e++) {
          this.graph.links[this.outputs[a].links[e]].data = c;
        }
      }
    }
  };
  k.prototype.getInputData = function(a, c) {
    if (this.inputs && !(a >= this.inputs.length || null == this.inputs[a].link)) {
      a = this.graph.links[this.inputs[a].link];
      if (!a) {
        return null;
      }
      if (!c) {
        return a.data;
      }
      c = this.graph.getNodeById(a.origin_id);
      if (!c) {
        return a.data;
      }
      if (c.updateOutputData) {
        c.updateOutputData(a.origin_slot);
      } else {
        if (c.onExecute) {
          c.onExecute();
        }
      }
      return a.data;
    }
  };
  k.prototype.getInputDataByName = function(a, c) {
    a = this.findInputSlot(a);
    return -1 == a ? null : this.getInputData(a, c);
  };
  k.prototype.isInputConnected = function(a) {
    return this.inputs ? a < this.inputs.length && null != this.inputs[a].link : !1;
  };
  k.prototype.getInputInfo = function(a) {
    return this.inputs ? a < this.inputs.length ? this.inputs[a] : null : null;
  };
  k.prototype.getInputNode = function(a) {
    if (!this.inputs || a >= this.inputs.length) {
      return null;
    }
    a = this.inputs[a];
    return a && null !== a.link ? (a = this.graph.links[a.link]) ? this.graph.getNodeById(a.origin_id) : null : null;
  };
  k.prototype.getInputOrProperty = function(a) {
    if (!this.inputs || !this.inputs.length) {
      return this.properties ? this.properties[a] : null;
    }
    for (var c = 0, e = this.inputs.length; c < e; ++c) {
      if (a == this.inputs[c].name) {
        return (a = this.graph.links[this.inputs[c].link]) ? a.data : null;
      }
    }
    return this.properties[a];
  };
  k.prototype.getOutputData = function(a) {
    return !this.outputs || a >= this.outputs.length ? null : this.outputs[a]._data;
  };
  k.prototype.getOutputInfo = function(a) {
    return this.outputs ? a < this.outputs.length ? this.outputs[a] : null : null;
  };
  k.prototype.isOutputConnected = function(a) {
    return this.outputs ? a < this.outputs.length && this.outputs[a].links && this.outputs[a].links.length : !1;
  };
  k.prototype.isAnyOutputConnected = function() {
    if (!this.outputs) {
      return !1;
    }
    for (var a = 0; a < this.outputs.length; ++a) {
      if (this.outputs[a].links && this.outputs[a].links.length) {
        return !0;
      }
    }
    return !1;
  };
  k.prototype.getOutputNodes = function(a) {
    if (!this.outputs || 0 == this.outputs.length || a >= this.outputs.length) {
      return null;
    }
    a = this.outputs[a];
    if (!a.links || 0 == a.links.length) {
      return null;
    }
    for (var c = [], e = 0; e < a.links.length; e++) {
      var b = this.graph.links[a.links[e]];
      b && (b = this.graph.getNodeById(b.target_id)) && c.push(b);
    }
    return c;
  };
  k.prototype.trigger = function(a, c) {
    if (this.outputs && this.outputs.length) {
      this.graph && (this.graph._last_trigger_time = h.getTime());
      for (var e = 0; e < this.outputs.length; ++e) {
        var b = this.outputs[e];
        !b || b.type !== h.EVENT || a && b.name != a || this.triggerSlot(e, c);
      }
    }
  };
  k.prototype.triggerSlot = function(a, c, e) {
    if (this.outputs && (a = this.outputs[a]) && (a = a.links) && a.length) {
      this.graph && (this.graph._last_trigger_time = h.getTime());
      for (var b = 0; b < a.length; ++b) {
        var g = a[b];
        if (null == e || e == g) {
          var l = this.graph.links[a[b]];
          if (l && (l._last_time = h.getTime(), g = this.graph.getNodeById(l.target_id))) {
            if (l = g.inputs[l.target_slot], g.onAction) {
              g.onAction(l.name, c);
            } else {
              if (g.mode === h.ON_TRIGGER && g.onExecute) {
                g.onExecute(c);
              }
            }
          }
        }
      }
    }
  };
  k.prototype.clearTriggeredSlot = function(a, c) {
    if (this.outputs && (a = this.outputs[a]) && (a = a.links) && a.length) {
      for (var e = 0; e < a.length; ++e) {
        var b = a[e];
        if (null == c || c == b) {
          if (b = this.graph.links[a[e]]) {
            b._last_time = 0;
          }
        }
      }
    }
  };
  k.prototype.addProperty = function(a, c, e, b) {
    e = {name:a, type:e, default_value:c};
    if (b) {
      for (var g in b) {
        e[g] = b[g];
      }
    }
    this.properties_info || (this.properties_info = []);
    this.properties_info.push(e);
    this.properties || (this.properties = {});
    this.properties[a] = c;
    return e;
  };
  k.prototype.addOutput = function(a, c, e) {
    a = {name:a, type:c, links:null};
    if (e) {
      for (var b in e) {
        a[b] = e[b];
      }
    }
    this.outputs || (this.outputs = []);
    this.outputs.push(a);
    if (this.onOutputAdded) {
      this.onOutputAdded(a);
    }
    this.size = this.computeSize();
    this.setDirtyCanvas(!0, !0);
    return a;
  };
  k.prototype.addOutputs = function(a) {
    for (var c = 0; c < a.length; ++c) {
      var e = a[c], b = {name:e[0], type:e[1], link:null};
      if (a[2]) {
        for (var g in e[2]) {
          b[g] = e[2][g];
        }
      }
      this.outputs || (this.outputs = []);
      this.outputs.push(b);
      if (this.onOutputAdded) {
        this.onOutputAdded(b);
      }
    }
    this.size = this.computeSize();
    this.setDirtyCanvas(!0, !0);
  };
  k.prototype.removeOutput = function(a) {
    this.disconnectOutput(a);
    this.outputs.splice(a, 1);
    for (var c = a; c < this.outputs.length; ++c) {
      if (this.outputs[c] && this.outputs[c].links) {
        for (var e = this.outputs[c].links, b = 0; b < e.length; ++b) {
          var g = this.graph.links[e[b]];
          g && --g.origin_slot;
        }
      }
    }
    this.size = this.computeSize();
    if (this.onOutputRemoved) {
      this.onOutputRemoved(a);
    }
    this.setDirtyCanvas(!0, !0);
  };
  k.prototype.addInput = function(a, c, e) {
    a = {name:a, type:c || 0, link:null};
    if (e) {
      for (var b in e) {
        a[b] = e[b];
      }
    }
    this.inputs || (this.inputs = []);
    this.inputs.push(a);
    this.size = this.computeSize();
    if (this.onInputAdded) {
      this.onInputAdded(a);
    }
    this.setDirtyCanvas(!0, !0);
    return a;
  };
  k.prototype.addInputs = function(a) {
    for (var c = 0; c < a.length; ++c) {
      var e = a[c], b = {name:e[0], type:e[1], link:null};
      if (a[2]) {
        for (var g in e[2]) {
          b[g] = e[2][g];
        }
      }
      this.inputs || (this.inputs = []);
      this.inputs.push(b);
      if (this.onInputAdded) {
        this.onInputAdded(b);
      }
    }
    this.size = this.computeSize();
    this.setDirtyCanvas(!0, !0);
  };
  k.prototype.removeInput = function(a) {
    this.disconnectInput(a);
    this.inputs.splice(a, 1);
    for (var c = a; c < this.inputs.length; ++c) {
      if (this.inputs[c]) {
        var e = this.graph.links[this.inputs[c].link];
        e && --e.target_slot;
      }
    }
    this.size = this.computeSize();
    if (this.onInputRemoved) {
      this.onInputRemoved(a);
    }
    this.setDirtyCanvas(!0, !0);
  };
  k.prototype.addConnection = function(a, c, e, b) {
    a = {name:a, type:c, pos:e, direction:b, links:null};
    this.connections.push(a);
    return a;
  };
  k.prototype.computeSize = function(a, c) {
    function e(a) {
      return a ? b * a.length * 0.6 : 0;
    }
    a = Math.max(this.inputs ? this.inputs.length : 1, this.outputs ? this.outputs.length : 1);
    c = c || new Float32Array([0, 0]);
    a = Math.max(a, 1);
    var b = h.NODE_TEXT_SIZE;
    c[1] = (this.constructor.slot_start_y || 0) + a * (b + 1) + 4;
    this.widgets && this.widgets.length && (c[1] += this.widgets.length * (h.NODE_WIDGET_HEIGHT + 4) + 8);
    a = e(this.title);
    var g = 0, l = 0;
    if (this.inputs) {
      for (var n = 0, d = this.inputs.length; n < d; ++n) {
        var m = this.inputs[n];
        m = m.label || m.name || "";
        m = e(m);
        g < m && (g = m);
      }
    }
    if (this.outputs) {
      for (n = 0, d = this.outputs.length; n < d; ++n) {
        m = this.outputs[n], m = m.label || m.name || "", m = e(m), l < m && (l = m);
      }
    }
    c[0] = Math.max(g + l + 10, a);
    c[0] = Math.max(c[0], h.NODE_WIDTH);
    this.widgets && this.widgets.length && (c[0] = Math.max(c[0], 1.5 * h.NODE_WIDTH));
    if (this.onResize) {
      this.onResize(c);
    }
    return c;
  };
  k.prototype.addWidget = function(a, c, e, b, g) {
    this.widgets || (this.widgets = []);
    c = {type:a.toLowerCase(), name:c, value:e, callback:b, options:g || {}};
    void 0 !== c.options.y && (c.y = c.options.y);
    b || console.warn("LiteGraph addWidget('button',...) without a callback");
    if ("combo" == a && !c.options.values) {
      throw "LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }";
    }
    this.widgets.push(c);
    return c;
  };
  k.prototype.addCustomWidget = function(a) {
    this.widgets || (this.widgets = []);
    this.widgets.push(a);
    return a;
  };
  k.prototype.getBounding = function(a) {
    a = a || new Float32Array(4);
    a[0] = this.pos[0] - 4;
    a[1] = this.pos[1] - h.NODE_TITLE_HEIGHT;
    a[2] = this.size[0] + 4;
    a[3] = this.size[1] + h.NODE_TITLE_HEIGHT;
    if (this.onBounding) {
      this.onBounding(a);
    }
    return a;
  };
  k.prototype.isPointInside = function(a, c, e, b) {
    e = e || 0;
    var g = this.graph && this.graph.isLive() ? 0 : 20;
    b && (g = 0);
    if (this.flags && this.flags.collapsed) {
      if (u(a, c, this.pos[0] - e, this.pos[1] - h.NODE_TITLE_HEIGHT - e, (this._collapsed_width || h.NODE_COLLAPSED_WIDTH) + 2 * e, h.NODE_TITLE_HEIGHT + 2 * e)) {
        return !0;
      }
    } else {
      if (this.pos[0] - 4 - e < a && this.pos[0] + this.size[0] + 4 + e > a && this.pos[1] - g - e < c && this.pos[1] + this.size[1] + e > c) {
        return !0;
      }
    }
    return !1;
  };
  k.prototype.getSlotInPosition = function(a, c) {
    var e = new Float32Array(2);
    if (this.inputs) {
      for (var b = 0, g = this.inputs.length; b < g; ++b) {
        var l = this.inputs[b];
        this.getConnectionPos(!0, b, e);
        if (u(a, c, e[0] - 10, e[1] - 5, 20, 10)) {
          return {input:l, slot:b, link_pos:e, locked:l.locked};
        }
      }
    }
    if (this.outputs) {
      for (b = 0, g = this.outputs.length; b < g; ++b) {
        if (l = this.outputs[b], this.getConnectionPos(!1, b, e), u(a, c, e[0] - 10, e[1] - 5, 20, 10)) {
          return {output:l, slot:b, link_pos:e, locked:l.locked};
        }
      }
    }
    return null;
  };
  k.prototype.findInputSlot = function(a) {
    if (!this.inputs) {
      return -1;
    }
    for (var c = 0, e = this.inputs.length; c < e; ++c) {
      if (a == this.inputs[c].name) {
        return c;
      }
    }
    return -1;
  };
  k.prototype.findOutputSlot = function(a) {
    if (!this.outputs) {
      return -1;
    }
    for (var c = 0, e = this.outputs.length; c < e; ++c) {
      if (a == this.outputs[c].name) {
        return c;
      }
    }
    return -1;
  };
  k.prototype.connect = function(a, c, e) {
    e = e || 0;
    if (!this.graph) {
      return console.log("Connect: Error, node doesnt belong to any graph. Nodes must be added first to a graph before connecting them."), null;
    }
    if (a.constructor === String) {
      if (a = this.findOutputSlot(a), -1 == a) {
        return h.debug && console.log("Connect: Error, no slot of name " + a), null;
      }
    } else {
      if (!this.outputs || a >= this.outputs.length) {
        return h.debug && console.log("Connect: Error, slot number not found"), null;
      }
    }
    c && c.constructor === Number && (c = this.graph.getNodeById(c));
    if (!c) {
      throw "target node is null";
    }
    if (c == this) {
      return null;
    }
    if (e.constructor === String) {
      if (e = c.findInputSlot(e), -1 == e) {
        return h.debug && console.log("Connect: Error, no slot of name " + e), null;
      }
    } else {
      if (e === h.EVENT) {
        return null;
      }
      if (!c.inputs || e >= c.inputs.length) {
        return h.debug && console.log("Connect: Error, slot number not found"), null;
      }
    }
    null != c.inputs[e].link && c.disconnectInput(e);
    var b = this.outputs[a];
    if (c.onConnectInput && !1 === c.onConnectInput(e, b.type, b)) {
      return null;
    }
    var g = c.inputs[e], l = null;
    if (h.isValidConnection(b.type, g.type)) {
      l = {id:this.graph.last_link_id++, type:g.type, origin_id:this.id, origin_slot:a, target_id:c.id, target_slot:e};
      this.graph.links[l.id] = l;
      null == b.links && (b.links = []);
      b.links.push(l.id);
      c.inputs[e].link = l.id;
      this.graph && this.graph._version++;
      if (this.onConnectionsChange) {
        this.onConnectionsChange(h.OUTPUT, a, !0, l, b);
      }
      if (c.onConnectionsChange) {
        c.onConnectionsChange(h.INPUT, e, !0, l, g);
      }
      this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(h.INPUT, c, e, this, a), this.graph.onNodeConnectionChange(h.OUTPUT, this, a, c, e));
    }
    this.setDirtyCanvas(!1, !0);
    this.graph.connectionChange(this, l);
    return l;
  };
  k.prototype.disconnectOutput = function(a, c) {
    if (a.constructor === String) {
      if (a = this.findOutputSlot(a), -1 == a) {
        return h.debug && console.log("Connect: Error, no slot of name " + a), !1;
      }
    } else {
      if (!this.outputs || a >= this.outputs.length) {
        return h.debug && console.log("Connect: Error, slot number not found"), !1;
      }
    }
    var e = this.outputs[a];
    if (!e || !e.links || 0 == e.links.length) {
      return !1;
    }
    if (c) {
      c.constructor === Number && (c = this.graph.getNodeById(c));
      if (!c) {
        throw "Target Node not found";
      }
      for (var b = 0, g = e.links.length; b < g; b++) {
        var l = e.links[b], n = this.graph.links[l];
        if (n.target_id == c.id) {
          e.links.splice(b, 1);
          var d = c.inputs[n.target_slot];
          d.link = null;
          delete this.graph.links[l];
          this.graph && this.graph._version++;
          if (c.onConnectionsChange) {
            c.onConnectionsChange(h.INPUT, n.target_slot, !1, n, d);
          }
          if (this.onConnectionsChange) {
            this.onConnectionsChange(h.OUTPUT, a, !1, n, e);
          }
          if (this.graph && this.graph.onNodeConnectionChange) {
            this.graph.onNodeConnectionChange(h.OUTPUT, this, a);
          }
          this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(h.OUTPUT, this, a), this.graph.onNodeConnectionChange(h.INPUT, c, n.target_slot));
          break;
        }
      }
    } else {
      b = 0;
      for (g = e.links.length; b < g; b++) {
        if (l = e.links[b], n = this.graph.links[l]) {
          c = this.graph.getNodeById(n.target_id);
          this.graph && this.graph._version++;
          if (c) {
            d = c.inputs[n.target_slot];
            d.link = null;
            if (c.onConnectionsChange) {
              c.onConnectionsChange(h.INPUT, n.target_slot, !1, n, d);
            }
            if (this.graph && this.graph.onNodeConnectionChange) {
              this.graph.onNodeConnectionChange(h.INPUT, c, n.target_slot);
            }
          }
          delete this.graph.links[l];
          if (this.onConnectionsChange) {
            this.onConnectionsChange(h.OUTPUT, a, !1, n, e);
          }
          this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(h.OUTPUT, this, a), this.graph.onNodeConnectionChange(h.INPUT, c, n.target_slot));
        }
      }
      e.links = null;
    }
    this.setDirtyCanvas(!1, !0);
    this.graph.connectionChange(this);
    return !0;
  };
  k.prototype.disconnectInput = function(a) {
    if (a.constructor === String) {
      if (a = this.findInputSlot(a), -1 == a) {
        return h.debug && console.log("Connect: Error, no slot of name " + a), !1;
      }
    } else {
      if (!this.inputs || a >= this.inputs.length) {
        return h.debug && console.log("Connect: Error, slot number not found"), !1;
      }
    }
    var c = this.inputs[a];
    if (!c) {
      return !1;
    }
    var e = this.inputs[a].link;
    this.inputs[a].link = null;
    var b = this.graph.links[e];
    if (b) {
      var g = this.graph.getNodeById(b.origin_id);
      if (!g) {
        return !1;
      }
      var l = g.outputs[b.origin_slot];
      if (!l || !l.links || 0 == l.links.length) {
        return !1;
      }
      for (var n = 0, d = l.links.length; n < d; n++) {
        if (l.links[n] == e) {
          l.links.splice(n, 1);
          break;
        }
      }
      delete this.graph.links[e];
      this.graph && this.graph._version++;
      if (this.onConnectionsChange) {
        this.onConnectionsChange(h.INPUT, a, !1, b, c);
      }
      if (g.onConnectionsChange) {
        g.onConnectionsChange(h.OUTPUT, n, !1, b, l);
      }
      this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(h.OUTPUT, g, n), this.graph.onNodeConnectionChange(h.INPUT, this, a));
    }
    this.setDirtyCanvas(!1, !0);
    this.graph.connectionChange(this);
    return !0;
  };
  k.prototype.getConnectionPos = function(a, c, e) {
    e = e || new Float32Array(2);
    var b = 0;
    a && this.inputs && (b = this.inputs.length);
    !a && this.outputs && (b = this.outputs.length);
    if (this.flags.collapsed) {
      return c = this._collapsed_width || h.NODE_COLLAPSED_WIDTH, this.flags.horizontal ? (e[0] = this.pos[0] + 0.5 * c, e[1] = a ? this.pos[1] - h.NODE_TITLE_HEIGHT : this.pos[1]) : (e[0] = a ? this.pos[0] : this.pos[0] + c, e[1] = this.pos[1] - 0.5 * h.NODE_TITLE_HEIGHT), e;
    }
    if (a && -1 == c) {
      return e[0] = this.pos[0] + 10, e[1] = this.pos[1] + 10, e;
    }
    if (a && b > c && this.inputs[c].pos) {
      return e[0] = this.pos[0] + this.inputs[c].pos[0], e[1] = this.pos[1] + this.inputs[c].pos[1], e;
    }
    if (!a && b > c && this.outputs[c].pos) {
      return e[0] = this.pos[0] + this.outputs[c].pos[0], e[1] = this.pos[1] + this.outputs[c].pos[1], e;
    }
    if (this.flags.horizontal) {
      return e[0] = this.pos[0] + this.size[0] / b * (c + 0.5), e[1] = a ? this.pos[1] - h.NODE_TITLE_HEIGHT : this.pos[1] + this.size[1], e;
    }
    e[0] = a ? this.pos[0] : this.pos[0] + this.size[0] + 1;
    e[1] = this.pos[1] + 10 + c * h.NODE_SLOT_HEIGHT + (this.constructor.slot_start_y || 0);
    return e;
  };
  k.prototype.alignToGrid = function() {
    this.pos[0] = h.CANVAS_GRID_SIZE * Math.round(this.pos[0] / h.CANVAS_GRID_SIZE);
    this.pos[1] = h.CANVAS_GRID_SIZE * Math.round(this.pos[1] / h.CANVAS_GRID_SIZE);
  };
  k.prototype.trace = function(a) {
    this.console || (this.console = []);
    this.console.push(a);
    this.console.length > k.MAX_CONSOLE && this.console.shift();
    this.graph.onNodeTrace(this, a);
  };
  k.prototype.setDirtyCanvas = function(a, c) {
    this.graph && this.graph.sendActionToCanvas("setDirty", [a, c]);
  };
  k.prototype.loadImage = function(a) {
    var c = new Image;
    c.src = h.node_images_path + a;
    c.ready = !1;
    var e = this;
    c.onload = function() {
      this.ready = !0;
      e.setDirtyCanvas(!0);
    };
    return c;
  };
  k.prototype.captureInput = function(a) {
    if (this.graph && this.graph.list_of_graphcanvas) {
      for (var c = this.graph.list_of_graphcanvas, e = 0; e < c.length; ++e) {
        var b = c[e];
        if (a || b.node_capturing_input == this) {
          b.node_capturing_input = a ? this : null;
        }
      }
    }
  };
  k.prototype.collapse = function(a) {
    this.graph._version++;
    if (!1 !== this.constructor.collapsable || a) {
      this.flags.collapsed = this.flags.collapsed ? !1 : !0, this.setDirtyCanvas(!0, !0);
    }
  };
  k.prototype.pin = function(a) {
    this.graph._version++;
    this.flags.pinned = void 0 === a ? !this.flags.pinned : a;
  };
  k.prototype.localToScreen = function(a, c, e) {
    return [(a + this.pos[0]) * e.scale + e.offset[0], (c + this.pos[1]) * e.scale + e.offset[1]];
  };
  v.LGraphGroup = h.LGraphGroup = q;
  q.prototype._ctor = function(a) {
    this.title = a || "Group";
    this.font_size = 24;
    this.color = d.node_colors.pale_blue ? d.node_colors.pale_blue.groupcolor : "#AAA";
    this._bounding = new Float32Array([10, 10, 140, 80]);
    this._pos = this._bounding.subarray(0, 2);
    this._size = this._bounding.subarray(2, 4);
    this._nodes = [];
    this.graph = null;
    Object.defineProperty(this, "pos", {set:function(a) {
      !a || 2 > a.length || (this._pos[0] = a[0], this._pos[1] = a[1]);
    }, get:function() {
      return this._pos;
    }, enumerable:!0});
    Object.defineProperty(this, "size", {set:function(a) {
      !a || 2 > a.length || (this._size[0] = Math.max(140, a[0]), this._size[1] = Math.max(80, a[1]));
    }, get:function() {
      return this._size;
    }, enumerable:!0});
  };
  q.prototype.configure = function(a) {
    this.title = a.title;
    this._bounding.set(a.bounding);
    this.color = a.color;
    this.font = a.font;
  };
  q.prototype.serialize = function() {
    var a = this._bounding;
    return {title:this.title, bounding:[Math.round(a[0]), Math.round(a[1]), Math.round(a[2]), Math.round(a[3])], color:this.color, font:this.font};
  };
  q.prototype.move = function(a, c, e) {
    this._pos[0] += a;
    this._pos[1] += c;
    if (!e) {
      for (e = 0; e < this._nodes.length; ++e) {
        var b = this._nodes[e];
        b.pos[0] += a;
        b.pos[1] += c;
      }
    }
  };
  q.prototype.recomputeInsideNodes = function() {
    this._nodes.length = 0;
    for (var a = this.graph._nodes, c = new Float32Array(4), e = 0; e < a.length; ++e) {
      var b = a[e];
      b.getBounding(c);
      x(this._bounding, c) && this._nodes.push(b);
    }
  };
  q.prototype.isPointInside = k.prototype.isPointInside;
  q.prototype.setDirtyCanvas = k.prototype.setDirtyCanvas;
  v.LGraphCanvas = h.LGraphCanvas = d;
  d.link_type_colors = {"-1":"#F85", number:"#AAA", node:"#DCA"};
  d.gradients = {};
  d.prototype.clear = function() {
    this.fps = this.render_time = this.last_draw_time = this.frame = 0;
    this.scale = 1;
    this.offset = [0, 0];
    this.dragging_rectangle = null;
    this.selected_nodes = {};
    this.selected_group = null;
    this.visible_nodes = [];
    this.connecting_node = this.node_capturing_input = this.node_over = this.node_dragged = null;
    this.highlighted_links = {};
    this.dirty_bgcanvas = this.dirty_canvas = !0;
    this.node_widget = this.node_in_panel = this.dirty_area = null;
    this.last_mouse = [0, 0];
    this.last_mouseclick = 0;
    this.visible_area.set([0, 0, 0, 0]);
    if (this.onClear) {
      this.onClear();
    }
  };
  d.prototype.setGraph = function(a, c) {
    this.graph != a && (c || this.clear(), !a && this.graph ? this.graph.detachCanvas(this) : (a.attachCanvas(this), this.setDirty(!0, !0)));
  };
  d.prototype.openSubgraph = function(a) {
    if (!a) {
      throw "graph cannot be null";
    }
    if (this.graph == a) {
      throw "graph cannot be the same";
    }
    this.clear();
    this.graph && (this._graph_stack || (this._graph_stack = []), this._graph_stack.push(this.graph));
    a.attachCanvas(this);
    this.setDirty(!0, !0);
  };
  d.prototype.closeSubgraph = function() {
    if (this._graph_stack && 0 != this._graph_stack.length) {
      var a = this.graph._subgraph_node, c = this._graph_stack.pop();
      this.selected_nodes = {};
      this.highlighted_links = {};
      c.attachCanvas(this);
      this.setDirty(!0, !0);
      a && (this.centerOnNode(a), this.selectNodes([a]));
    }
  };
  d.prototype.setCanvas = function(a, c) {
    if (a && a.constructor === String && (a = document.getElementById(a), !a)) {
      throw "Error creating LiteGraph canvas: Canvas not found";
    }
    if (a !== this.canvas && (!a && this.canvas && (c || this.unbindEvents()), this.canvas = a)) {
      a.className += " lgraphcanvas";
      a.data = this;
      this.bgcanvas = null;
      this.bgcanvas || (this.bgcanvas = document.createElement("canvas"), this.bgcanvas.width = this.canvas.width, this.bgcanvas.height = this.canvas.height);
      if (null == a.getContext) {
        if ("canvas" != a.localName) {
          throw "Element supplied for LGraphCanvas must be a <canvas> element, you passed a " + a.localName;
        }
        throw "This browser doesnt support Canvas";
      }
      null == (this.ctx = a.getContext("2d")) && (a.webgl_enabled || console.warn("This canvas seems to be WebGL, enabling WebGL renderer"), this.enableWebGL());
      this._mousemove_callback = this.processMouseMove.bind(this);
      this._mouseup_callback = this.processMouseUp.bind(this);
      c || this.bindEvents();
    }
  };
  d.prototype._doNothing = function(a) {
    a.preventDefault();
    return !1;
  };
  d.prototype._doReturnTrue = function(a) {
    a.preventDefault();
    return !0;
  };
  d.prototype.bindEvents = function() {
    if (this._events_binded) {
      console.warn("LGraphCanvas: events already binded");
    } else {
      var a = this.canvas, c = this.getCanvasWindow().document;
      this._mousedown_callback = this.processMouseDown.bind(this);
      this._mousewheel_callback = this.processMouseWheel.bind(this);
      a.addEventListener("mousedown", this._mousedown_callback, !0);
      a.addEventListener("mousemove", this._mousemove_callback);
      a.addEventListener("mousewheel", this._mousewheel_callback, !1);
      a.addEventListener("contextmenu", this._doNothing);
      a.addEventListener("DOMMouseScroll", this._mousewheel_callback, !1);
      a.addEventListener("touchstart", this.touchHandler, !0);
      a.addEventListener("touchmove", this.touchHandler, !0);
      a.addEventListener("touchend", this.touchHandler, !0);
      a.addEventListener("touchcancel", this.touchHandler, !0);
      this._key_callback = this.processKey.bind(this);
      a.addEventListener("keydown", this._key_callback, !0);
      c.addEventListener("keyup", this._key_callback, !0);
      this._ondrop_callback = this.processDrop.bind(this);
      a.addEventListener("dragover", this._doNothing, !1);
      a.addEventListener("dragend", this._doNothing, !1);
      a.addEventListener("drop", this._ondrop_callback, !1);
      a.addEventListener("dragenter", this._doReturnTrue, !1);
      this._events_binded = !0;
    }
  };
  d.prototype.unbindEvents = function() {
    if (this._events_binded) {
      var a = this.getCanvasWindow().document;
      this.canvas.removeEventListener("mousedown", this._mousedown_callback);
      this.canvas.removeEventListener("mousewheel", this._mousewheel_callback);
      this.canvas.removeEventListener("DOMMouseScroll", this._mousewheel_callback);
      this.canvas.removeEventListener("keydown", this._key_callback);
      a.removeEventListener("keyup", this._key_callback);
      this.canvas.removeEventListener("contextmenu", this._doNothing);
      this.canvas.removeEventListener("drop", this._ondrop_callback);
      this.canvas.removeEventListener("dragenter", this._doReturnTrue);
      this.canvas.removeEventListener("touchstart", this.touchHandler);
      this.canvas.removeEventListener("touchmove", this.touchHandler);
      this.canvas.removeEventListener("touchend", this.touchHandler);
      this.canvas.removeEventListener("touchcancel", this.touchHandler);
      this._ondrop_callback = this._key_callback = this._mousewheel_callback = this._mousedown_callback = null;
      this._events_binded = !1;
    } else {
      console.warn("LGraphCanvas: no events binded");
    }
  };
  d.getFileExtension = function(a) {
    var c = a.indexOf("?");
    -1 != c && (a = a.substr(0, c));
    c = a.lastIndexOf(".");
    return -1 == c ? "" : a.substr(c + 1).toLowerCase();
  };
  d.prototype.enableWebGL = function() {
    this.gl = this.ctx = enableWebGLCanvas(this.canvas);
    this.ctx.webgl = !0;
    this.bgcanvas = this.canvas;
    this.bgctx = this.gl;
    this.canvas.webgl_enabled = !0;
  };
  d.prototype.setDirty = function(a, c) {
    a && (this.dirty_canvas = !0);
    c && (this.dirty_bgcanvas = !0);
  };
  d.prototype.getCanvasWindow = function() {
    if (!this.canvas) {
      return window;
    }
    var a = this.canvas.ownerDocument;
    return a.defaultView || a.parentWindow;
  };
  d.prototype.startRendering = function() {
    function a() {
      this.pause_rendering || this.draw();
      var c = this.getCanvasWindow();
      this.is_rendering && c.requestAnimationFrame(a.bind(this));
    }
    this.is_rendering || (this.is_rendering = !0, a.call(this));
  };
  d.prototype.stopRendering = function() {
    this.is_rendering = !1;
  };
  d.prototype.processMouseDown = function(a) {
    if (this.graph) {
      this.adjustMouseEvent(a);
      var c = this.getCanvasWindow();
      d.active_canvas = this;
      this.canvas.removeEventListener("mousemove", this._mousemove_callback);
      c.document.addEventListener("mousemove", this._mousemove_callback, !0);
      c.document.addEventListener("mouseup", this._mouseup_callback, !0);
      var e = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes, 5), b = !1, g = 300 > h.getTime() - this.last_mouseclick;
      this.canvas_mouse[0] = a.canvasX;
      this.canvas_mouse[1] = a.canvasY;
      h.closeAllContextMenus(c);
      if (!this.onMouse || 1 != this.onMouse(a)) {
        if (1 == a.which) {
          a.ctrlKey && (this.dragging_rectangle = new Float32Array(4), this.dragging_rectangle[0] = a.canvasX, this.dragging_rectangle[1] = a.canvasY, this.dragging_rectangle[2] = 1, this.dragging_rectangle[3] = 1, b = !0);
          var l = !1;
          if (e && this.allow_interaction && !b) {
            this.live_mode || e.flags.pinned || this.bringToFront(e);
            if (!this.connecting_node && !e.flags.collapsed && !this.live_mode) {
              if (!b && !1 !== e.flags.resizable && u(a.canvasX, a.canvasY, e.pos[0] + e.size[0] - 5, e.pos[1] + e.size[1] - 5, 10, 10)) {
                this.resizing_node = e, this.canvas.style.cursor = "se-resize", b = !0;
              } else {
                if (e.outputs) {
                  for (var n = 0, m = e.outputs.length; n < m; ++n) {
                    var f = e.outputs[n], p = e.getConnectionPos(!1, n);
                    if (u(a.canvasX, a.canvasY, p[0] - 15, p[1] - 10, 30, 20)) {
                      this.connecting_node = e;
                      this.connecting_output = f;
                      this.connecting_pos = e.getConnectionPos(!1, n);
                      this.connecting_slot = n;
                      a.shiftKey && e.disconnectOutput(n);
                      if (g) {
                        if (e.onOutputDblClick) {
                          e.onOutputDblClick(n, a);
                        }
                      } else {
                        if (e.onOutputClick) {
                          e.onOutputClick(n, a);
                        }
                      }
                      b = !0;
                      break;
                    }
                  }
                }
                if (e.inputs) {
                  for (n = 0, m = e.inputs.length; n < m; ++n) {
                    if (f = e.inputs[n], p = e.getConnectionPos(!0, n), u(a.canvasX, a.canvasY, p[0] - 15, p[1] - 10, 30, 20)) {
                      if (g) {
                        if (e.onInputDblClick) {
                          e.onInputDblClick(n, a);
                        }
                      } else {
                        if (e.onInputClick) {
                          e.onInputClick(n, a);
                        }
                      }
                      if (null !== f.link) {
                        b = this.graph.links[f.link];
                        e.disconnectInput(n);
                        if (this.allow_reconnect_links || a.shiftKey) {
                          this.connecting_node = this.graph._nodes_by_id[b.origin_id], this.connecting_slot = b.origin_slot, this.connecting_output = this.connecting_node.outputs[this.connecting_slot], this.connecting_pos = this.connecting_node.getConnectionPos(!1, this.connecting_slot);
                        }
                        b = this.dirty_bgcanvas = !0;
                      }
                    }
                  }
                }
              }
            }
            !b && u(a.canvasX, a.canvasY, e.pos[0], e.pos[1] - h.NODE_TITLE_HEIGHT, h.NODE_TITLE_HEIGHT, h.NODE_TITLE_HEIGHT) && (e.collapse(), b = !0);
            if (!b) {
              n = !1;
              if (m = this.processNodeWidgets(e, this.canvas_mouse, a)) {
                n = !0, this.node_widget = [e, m];
              }
              if (g && this.selected_nodes[e.id]) {
                if (e.onDblClick) {
                  e.onDblClick(a, [a.canvasX - e.pos[0], a.canvasY - e.pos[1]], graphcanvas);
                }
                this.processNodeDblClicked(e);
                n = !0;
              }
              e.onMouseDown && e.onMouseDown(a, [a.canvasX - e.pos[0], a.canvasY - e.pos[1]], this) ? n = !0 : this.live_mode && (n = l = !0);
              n || (this.allow_dragnodes && (this.node_dragged = e), this.selected_nodes[e.id] || this.processNodeSelected(e, a));
              this.dirty_canvas = !0;
            }
          } else {
            this.selected_group = this.graph.getGroupOnPos(a.canvasX, a.canvasY), this.selected_group_resizing = !1, this.selected_group && (a.ctrlKey && (this.dragging_rectangle = null), 10 > t([a.canvasX, a.canvasY], [this.selected_group.pos[0] + this.selected_group.size[0], this.selected_group.pos[1] + this.selected_group.size[1]]) * this.scale ? this.selected_group_resizing = !0 : this.selected_group.recomputeInsideNodes()), g && this.showSearchBox(a), l = !0;
          }
          !b && l && this.allow_dragcanvas && (this.dragging_canvas = !0);
        } else {
          2 != a.which && 3 == a.which && this.processContextMenu(e, a);
        }
        this.last_mouse[0] = a.localX;
        this.last_mouse[1] = a.localY;
        this.last_mouseclick = h.getTime();
        this.last_mouse_dragging = !0;
        this.graph.change();
        (!c.document.activeElement || "input" != c.document.activeElement.nodeName.toLowerCase() && "textarea" != c.document.activeElement.nodeName.toLowerCase()) && a.preventDefault();
        a.stopPropagation();
        if (this.onMouseDown) {
          this.onMouseDown(a);
        }
        return !1;
      }
    }
  };
  d.prototype.processMouseMove = function(a) {
    this.autoresize && this.resize();
    if (this.graph) {
      d.active_canvas = this;
      this.adjustMouseEvent(a);
      var c = [a.localX, a.localY], e = [c[0] - this.last_mouse[0], c[1] - this.last_mouse[1]];
      this.last_mouse = c;
      this.canvas_mouse[0] = a.canvasX;
      this.canvas_mouse[1] = a.canvasY;
      a.dragging = this.last_mouse_dragging;
      this.node_widget && (this.processNodeWidgets(this.node_widget[0], this.canvas_mouse, a, this.node_widget[1]), this.dirty_canvas = !0);
      if (this.dragging_rectangle) {
        this.dragging_rectangle[2] = a.canvasX - this.dragging_rectangle[0], this.dragging_rectangle[3] = a.canvasY - this.dragging_rectangle[1], this.dirty_canvas = !0;
      } else {
        if (this.selected_group) {
          this.selected_group_resizing ? this.selected_group.size = [a.canvasX - this.selected_group.pos[0], a.canvasY - this.selected_group.pos[1]] : (this.selected_group.move(e[0] / this.scale, e[1] / this.scale, a.ctrlKey), this.selected_group._nodes.length && (this.dirty_canvas = !0)), this.dirty_bgcanvas = !0;
        } else {
          if (this.dragging_canvas) {
            this.offset[0] += e[0] / this.scale, this.offset[1] += e[1] / this.scale, this.dirty_bgcanvas = this.dirty_canvas = !0;
          } else {
            if (this.allow_interaction) {
              this.connecting_node && (this.dirty_canvas = !0);
              var b = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes);
              c = 0;
              for (var g = this.graph._nodes.length; c < g; ++c) {
                if (this.graph._nodes[c].mouseOver && b != this.graph._nodes[c]) {
                  this.graph._nodes[c].mouseOver = !1;
                  if (this.node_over && this.node_over.onMouseLeave) {
                    this.node_over.onMouseLeave(a);
                  }
                  this.node_over = null;
                  this.dirty_canvas = !0;
                }
              }
              if (b) {
                if (!b.mouseOver && (b.mouseOver = !0, this.node_over = b, this.dirty_canvas = !0, b.onMouseEnter)) {
                  b.onMouseEnter(a);
                }
                if (b.onMouseMove) {
                  b.onMouseMove(a, [a.canvasX - b.pos[0], a.canvasY - b.pos[1]], this);
                }
                if (this.connecting_node && (g = this._highlight_input || [0, 0], !this.isOverNodeBox(b, a.canvasX, a.canvasY))) {
                  var l = this.isOverNodeInput(b, a.canvasX, a.canvasY, g);
                  -1 != l && b.inputs[l] ? h.isValidConnection(this.connecting_output.type, b.inputs[l].type) && (this._highlight_input = g) : this._highlight_input = null;
                }
                this.canvas && (u(a.canvasX, a.canvasY, b.pos[0] + b.size[0] - 5, b.pos[1] + b.size[1] - 5, 5, 5) ? this.canvas.style.cursor = "se-resize" : this.canvas.style.cursor = "");
              } else {
                this.canvas && (this.canvas.style.cursor = "");
              }
              if (this.node_capturing_input && this.node_capturing_input != b && this.node_capturing_input.onMouseMove) {
                this.node_capturing_input.onMouseMove(a);
              }
              if (this.node_dragged && !this.live_mode) {
                for (c in this.selected_nodes) {
                  b = this.selected_nodes[c], b.pos[0] += e[0] / this.scale, b.pos[1] += e[1] / this.scale;
                }
                this.dirty_bgcanvas = this.dirty_canvas = !0;
              }
              this.resizing_node && !this.live_mode && (this.resizing_node.size[0] = a.canvasX - this.resizing_node.pos[0], this.resizing_node.size[1] = a.canvasY - this.resizing_node.pos[1], e = Math.max(this.resizing_node.inputs ? this.resizing_node.inputs.length : 0, this.resizing_node.outputs ? this.resizing_node.outputs.length : 0) * h.NODE_SLOT_HEIGHT + (this.resizing_node.widgets ? this.resizing_node.widgets.length : 0) * (h.NODE_WIDGET_HEIGHT + 4) + 4, this.resizing_node.size[1] < e && (this.resizing_node.size[1] = 
              e), this.resizing_node.size[0] < h.NODE_MIN_WIDTH && (this.resizing_node.size[0] = h.NODE_MIN_WIDTH), this.canvas.style.cursor = "se-resize", this.dirty_bgcanvas = this.dirty_canvas = !0);
            }
          }
        }
      }
      a.preventDefault();
      return !1;
    }
  };
  d.prototype.processMouseUp = function(a) {
    if (this.graph) {
      var c = this.getCanvasWindow().document;
      d.active_canvas = this;
      c.removeEventListener("mousemove", this._mousemove_callback, !0);
      this.canvas.addEventListener("mousemove", this._mousemove_callback, !0);
      c.removeEventListener("mouseup", this._mouseup_callback, !0);
      this.adjustMouseEvent(a);
      c = h.getTime();
      a.click_time = c - this.last_mouseclick;
      this.last_mouse_dragging = !1;
      if (1 == a.which) {
        if (this.node_widget = null, this.selected_group && (this.selected_group.move(this.selected_group.pos[0] - Math.round(this.selected_group.pos[0]), this.selected_group.pos[1] - Math.round(this.selected_group.pos[1]), a.ctrlKey), this.selected_group.pos[0] = Math.round(this.selected_group.pos[0]), this.selected_group.pos[1] = Math.round(this.selected_group.pos[1]), this.selected_group._nodes.length && (this.dirty_canvas = !0), this.selected_group = null), this.selected_group_resizing = !1, 
        this.dragging_rectangle) {
          if (this.graph) {
            c = this.graph._nodes;
            var e = new Float32Array(4);
            this.deselectAllNodes();
            var b = Math.abs(this.dragging_rectangle[2]), g = Math.abs(this.dragging_rectangle[3]), l = 0 > this.dragging_rectangle[3] ? this.dragging_rectangle[1] - g : this.dragging_rectangle[1];
            this.dragging_rectangle[0] = 0 > this.dragging_rectangle[2] ? this.dragging_rectangle[0] - b : this.dragging_rectangle[0];
            this.dragging_rectangle[1] = l;
            this.dragging_rectangle[2] = b;
            this.dragging_rectangle[3] = g;
            g = [];
            for (l = 0; l < c.length; ++l) {
              b = c[l], b.getBounding(e), x(this.dragging_rectangle, e) && g.push(b);
            }
            g.length && this.selectNodes(g);
          }
          this.dragging_rectangle = null;
        } else {
          if (this.connecting_node) {
            this.dirty_bgcanvas = this.dirty_canvas = !0;
            if (b = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes)) {
              this.connecting_output.type == h.EVENT && this.isOverNodeBox(b, a.canvasX, a.canvasY) ? this.connecting_node.connect(this.connecting_slot, b, h.EVENT) : (c = this.isOverNodeInput(b, a.canvasX, a.canvasY), -1 != c ? this.connecting_node.connect(this.connecting_slot, b, c) : (c = b.getInputInfo(0), this.connecting_output.type == h.EVENT ? this.connecting_node.connect(this.connecting_slot, b, h.EVENT) : c && !c.link && h.isValidConnection(c.type && this.connecting_output.type) && this.connecting_node.connect(this.connecting_slot, 
              b, 0)));
            }
            this.connecting_node = this.connecting_pos = this.connecting_output = null;
            this.connecting_slot = -1;
          } else {
            if (this.resizing_node) {
              this.dirty_bgcanvas = this.dirty_canvas = !0, this.resizing_node = null;
            } else {
              if (this.node_dragged) {
                this.dirty_bgcanvas = this.dirty_canvas = !0, this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]), this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]), this.graph.config.align_to_grid && this.node_dragged.alignToGrid(), this.node_dragged = null;
              } else {
                b = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes);
                !b && 300 > a.click_time && this.deselectAllNodes();
                this.dirty_canvas = !0;
                this.dragging_canvas = !1;
                if (this.node_over && this.node_over.onMouseUp) {
                  this.node_over.onMouseUp(a, [a.canvasX - this.node_over.pos[0], a.canvasY - this.node_over.pos[1]], this);
                }
                if (this.node_capturing_input && this.node_capturing_input.onMouseUp) {
                  this.node_capturing_input.onMouseUp(a, [a.canvasX - this.node_capturing_input.pos[0], a.canvasY - this.node_capturing_input.pos[1]]);
                }
              }
            }
          }
        }
      } else {
        2 == a.which ? (this.dirty_canvas = !0, this.dragging_canvas = !1) : 3 == a.which && (this.dirty_canvas = !0, this.dragging_canvas = !1);
      }
      this.graph.change();
      a.stopPropagation();
      a.preventDefault();
      return !1;
    }
  };
  d.prototype.processMouseWheel = function(a) {
    if (this.graph && this.allow_dragcanvas) {
      var c = null != a.wheelDeltaY ? a.wheelDeltaY : -60 * a.detail;
      this.adjustMouseEvent(a);
      var b = this.scale;
      0 < c ? b *= 1.1 : 0 > c && (b *= 1 / 1.1);
      this.setZoom(b, [a.localX, a.localY]);
      this.graph.change();
      a.preventDefault();
      return !1;
    }
  };
  d.prototype.isOverNodeBox = function(a, c, b) {
    var e = h.NODE_TITLE_HEIGHT;
    return u(c, b, a.pos[0] + 2, a.pos[1] + 2 - e, e - 4, e - 4) ? !0 : !1;
  };
  d.prototype.isOverNodeInput = function(a, c, b, d) {
    if (a.inputs) {
      for (var e = 0, l = a.inputs.length; e < l; ++e) {
        var n = a.getConnectionPos(!0, e);
        if (u(c, b, n[0] - 10, n[1] - 5, 20, 10)) {
          return d && (d[0] = n[0], d[1] = n[1]), e;
        }
      }
    }
    return -1;
  };
  d.prototype.processKey = function(a) {
    if (this.graph) {
      var c = !1;
      if ("input" != a.target.localName) {
        if ("keydown" == a.type) {
          if (32 == a.keyCode && (c = this.dragging_canvas = !0), 65 == a.keyCode && a.ctrlKey && (this.selectNodes(), c = !0), "KeyC" == a.code && (a.metaKey || a.ctrlKey) && !a.shiftKey && this.selected_nodes && (this.copyToClipboard(), c = !0), "KeyV" != a.code || !a.metaKey && !a.ctrlKey || a.shiftKey || this.pasteFromClipboard(), 46 != a.keyCode && 8 != a.keyCode || "input" == a.target.localName || "textarea" == a.target.localName || (this.deleteSelectedNodes(), c = !0), this.selected_nodes) {
            for (var b in this.selected_nodes) {
              if (this.selected_nodes[b].onKeyDown) {
                this.selected_nodes[b].onKeyDown(a);
              }
            }
          }
        } else {
          if ("keyup" == a.type && (32 == a.keyCode && (this.dragging_canvas = !1), this.selected_nodes)) {
            for (b in this.selected_nodes) {
              if (this.selected_nodes[b].onKeyUp) {
                this.selected_nodes[b].onKeyUp(a);
              }
            }
          }
        }
        this.graph.change();
        if (c) {
          return a.preventDefault(), !1;
        }
      }
    }
  };
  d.prototype.copyToClipboard = function() {
    var a = {nodes:[], links:[]}, c = 0, b = [], d;
    for (d in this.selected_nodes) {
      var g = this.selected_nodes[d];
      g._relative_id = c;
      b.push(g);
      c += 1;
    }
    for (d = 0; d < b.length; ++d) {
      if (g = b[d], a.nodes.push(g.clone().serialize()), g.inputs && g.inputs.length) {
        for (c = 0; c < g.inputs.length; ++c) {
          var l = g.inputs[c];
          if (l && null != l.link && (l = this.graph.links[l.link])) {
            var n = this.graph.getNodeById(l.origin_id);
            n && this.selected_nodes[n.id] && a.links.push([n._relative_id, c, g._relative_id, l.target_slot]);
          }
        }
      }
    }
    localStorage.setItem("litegrapheditor_clipboard", JSON.stringify(a));
  };
  d.prototype.pasteFromClipboard = function() {
    var a = localStorage.getItem("litegrapheditor_clipboard");
    if (a) {
      a = JSON.parse(a);
      for (var c = [], b = 0; b < a.nodes.length; ++b) {
        var d = a.nodes[b], g = h.createNode(d.type);
        g && (g.configure(d), g.pos[0] += 5, g.pos[1] += 5, this.graph.add(g), c.push(g));
      }
      for (b = 0; b < a.links.length; ++b) {
        d = a.links[b], c[d[0]].connect(d[1], c[d[2]], d[3]);
      }
      this.selectNodes(c);
    }
  };
  d.prototype.processDrop = function(a) {
    a.preventDefault();
    this.adjustMouseEvent(a);
    var c = [a.canvasX, a.canvasY], b = this.graph.getNodeOnPos(c[0], c[1]);
    if (b) {
      if ((b.onDropFile || b.onDropData) && (c = a.dataTransfer.files) && c.length) {
        for (var h = 0; h < c.length; h++) {
          var g = a.dataTransfer.files[0], l = g.name;
          d.getFileExtension(l);
          if (b.onDropFile) {
            b.onDropFile(g);
          }
          if (b.onDropData) {
            var n = new FileReader;
            n.onload = function(a) {
              b.onDropData(a.target.result, l, g);
            };
            var m = g.type.split("/")[0];
            "text" == m || "" == m ? n.readAsText(g) : "image" == m ? n.readAsDataURL(g) : n.readAsArrayBuffer(g);
          }
        }
      }
      return b.onDropItem && b.onDropItem(event) ? !0 : this.onDropItem ? this.onDropItem(event) : !1;
    }
    c = null;
    this.onDropItem && (c = this.onDropItem(event));
    c || this.checkDropItem(a);
  };
  d.prototype.checkDropItem = function(a) {
    if (a.dataTransfer.files.length) {
      var c = a.dataTransfer.files[0], b = d.getFileExtension(c.name).toLowerCase();
      if (b = h.node_types_by_file_extension[b]) {
        if (b = h.createNode(b.type), b.pos = [a.canvasX, a.canvasY], this.graph.add(b), b.onDropFile) {
          b.onDropFile(c);
        }
      }
    }
  };
  d.prototype.processNodeDblClicked = function(a) {
    if (this.onShowNodePanel) {
      this.onShowNodePanel(a);
    }
    if (this.onNodeDblClicked) {
      this.onNodeDblClicked(a);
    }
    this.setDirty(!0);
  };
  d.prototype.processNodeSelected = function(a, c) {
    this.selectNode(a, c && c.shiftKey);
    if (this.onNodeSelected) {
      this.onNodeSelected(a);
    }
  };
  d.prototype.processNodeDeselected = function(a) {
    this.deselectNode(a);
    if (this.onNodeDeselected) {
      this.onNodeDeselected(a);
    }
  };
  d.prototype.selectNode = function(a, c) {
    null == a ? this.deselectAllNodes() : this.selectNodes([a], c);
  };
  d.prototype.selectNodes = function(a, c) {
    c || this.deselectAllNodes();
    a = a || this.graph._nodes;
    for (c = 0; c < a.length; ++c) {
      var b = a[c];
      if (!b.selected) {
        if (!b.selected && b.onSelected) {
          b.onSelected();
        }
        b.selected = !0;
        this.selected_nodes[b.id] = b;
        if (b.inputs) {
          for (var d = 0; d < b.inputs.length; ++d) {
            this.highlighted_links[b.inputs[d].link] = !0;
          }
        }
        if (b.outputs) {
          for (d = 0; d < b.outputs.length; ++d) {
            var g = b.outputs[d];
            if (g.links) {
              for (var l = 0; l < g.links.length; ++l) {
                this.highlighted_links[g.links[l]] = !0;
              }
            }
          }
        }
      }
    }
    this.setDirty(!0);
  };
  d.prototype.deselectNode = function(a) {
    if (a.selected) {
      if (a.onDeselected) {
        a.onDeselected();
      }
      a.selected = !1;
      if (a.inputs) {
        for (var c = 0; c < a.inputs.length; ++c) {
          delete this.highlighted_links[a.inputs[c].link];
        }
      }
      if (a.outputs) {
        for (c = 0; c < a.outputs.length; ++c) {
          var b = a.outputs[c];
          if (b.links) {
            for (var d = 0; d < b.links.length; ++d) {
              delete this.highlighted_links[b.links[d]];
            }
          }
        }
      }
    }
  };
  d.prototype.deselectAllNodes = function() {
    if (this.graph) {
      for (var a = this.graph._nodes, c = 0, b = a.length; c < b; ++c) {
        var d = a[c];
        if (d.selected) {
          if (d.onDeselected) {
            d.onDeselected();
          }
          d.selected = !1;
        }
      }
      this.selected_nodes = {};
      this.highlighted_links = {};
      this.setDirty(!0);
    }
  };
  d.prototype.deleteSelectedNodes = function() {
    for (var a in this.selected_nodes) {
      this.graph.remove(this.selected_nodes[a]);
    }
    this.selected_nodes = {};
    this.highlighted_links = {};
    this.setDirty(!0);
  };
  d.prototype.centerOnNode = function(a) {
    this.offset[0] = -a.pos[0] - 0.5 * a.size[0] + 0.5 * this.canvas.width / this.scale;
    this.offset[1] = -a.pos[1] - 0.5 * a.size[1] + 0.5 * this.canvas.height / this.scale;
    this.setDirty(!0, !0);
  };
  d.prototype.adjustMouseEvent = function(a) {
    if (this.canvas) {
      var c = this.canvas.getBoundingClientRect();
      a.localX = a.pageX - c.left;
      a.localY = a.pageY - c.top;
    } else {
      a.localX = a.pageX, a.localY = a.pageY;
    }
    a.deltaX = a.localX - this.last_mouse_position[0];
    a.deltaY = a.localY - this.last_mouse_position[1];
    this.last_mouse_position[0] = a.localX;
    this.last_mouse_position[1] = a.localY;
    a.canvasX = a.localX / this.scale - this.offset[0];
    a.canvasY = a.localY / this.scale - this.offset[1];
  };
  d.prototype.setZoom = function(a, c) {
    !c && this.canvas && (c = [0.5 * this.canvas.width, 0.5 * this.canvas.height]);
    var b = this.convertOffsetToCanvas(c);
    this.scale = a;
    this.scale > this.max_zoom ? this.scale = this.max_zoom : this.scale < this.min_zoom && (this.scale = this.min_zoom);
    a = this.convertOffsetToCanvas(c);
    b = [a[0] - b[0], a[1] - b[1]];
    this.offset[0] += b[0];
    this.offset[1] += b[1];
    this.dirty_bgcanvas = this.dirty_canvas = !0;
  };
  d.prototype.convertOffsetToCanvas = function(a, c) {
    c = c || [];
    c[0] = a[0] / this.scale - this.offset[0];
    c[1] = a[1] / this.scale - this.offset[1];
    return c;
  };
  d.prototype.convertCanvasToOffset = function(a, c) {
    c = c || [];
    c[0] = (a[0] + this.offset[0]) * this.scale;
    c[1] = (a[1] + this.offset[1]) * this.scale;
    return c;
  };
  d.prototype.convertEventToCanvas = function(a) {
    var c = this.canvas.getBoundingClientRect();
    return this.convertOffsetToCanvas([a.pageX - c.left, a.pageY - c.top]);
  };
  d.prototype.bringToFront = function(a) {
    var c = this.graph._nodes.indexOf(a);
    -1 != c && (this.graph._nodes.splice(c, 1), this.graph._nodes.push(a));
  };
  d.prototype.sendToBack = function(a) {
    var c = this.graph._nodes.indexOf(a);
    -1 != c && (this.graph._nodes.splice(c, 1), this.graph._nodes.unshift(a));
  };
  var m = new Float32Array(4);
  d.prototype.computeVisibleNodes = function(a, c) {
    c = c || [];
    c.length = 0;
    a = a || this.graph._nodes;
    for (var b = 0, d = a.length; b < d; ++b) {
      var g = a[b];
      (!this.live_mode || g.onDrawBackground || g.onDrawForeground) && x(this.visible_area, g.getBounding(m)) && c.push(g);
    }
    return c;
  };
  d.prototype.draw = function(a, c) {
    if (this.canvas) {
      var b = h.getTime();
      this.render_time = 0.001 * (b - this.last_draw_time);
      this.last_draw_time = b;
      if (this.graph) {
        var d = -this.offset[0], g = -this.offset[1], l = d + this.canvas.width / this.scale, n = g + this.canvas.height / this.scale;
        this.visible_area[0] = d;
        this.visible_area[1] = g;
        this.visible_area[2] = l - d;
        this.visible_area[3] = n - g;
      }
      (this.dirty_bgcanvas || c || this.always_render_background || this.graph && this.graph._last_trigger_time && 1000 > b - this.graph._last_trigger_time) && this.drawBackCanvas();
      (this.dirty_canvas || a) && this.drawFrontCanvas();
      this.fps = this.render_time ? 1.0 / this.render_time : 0;
      this.frame += 1;
    }
  };
  d.prototype.drawFrontCanvas = function() {
    this.dirty_canvas = !1;
    this.ctx || (this.ctx = this.bgcanvas.getContext("2d"));
    var a = this.ctx;
    if (a) {
      a.start2D && a.start2D();
      var c = this.canvas;
      a.restore();
      a.setTransform(1, 0, 0, 1, 0, 0);
      this.dirty_area && (a.save(), a.beginPath(), a.rect(this.dirty_area[0], this.dirty_area[1], this.dirty_area[2], this.dirty_area[3]), a.clip());
      this.clear_background && a.clearRect(0, 0, c.width, c.height);
      this.bgcanvas == this.canvas ? this.drawBackCanvas() : a.drawImage(this.bgcanvas, 0, 0);
      if (this.onRender) {
        this.onRender(c, a);
      }
      this.show_info && this.renderInfo(a);
      if (this.graph) {
        a.save();
        a.scale(this.scale, this.scale);
        a.translate(this.offset[0], this.offset[1]);
        c = this.computeVisibleNodes(null, this.visible_nodes);
        for (var b = 0; b < c.length; ++b) {
          var d = c[b];
          a.save();
          a.translate(d.pos[0], d.pos[1]);
          this.drawNode(d, a);
          a.restore();
        }
        this.render_execution_order && this.drawExecutionOrder(a);
        this.graph.config.links_ontop && (this.live_mode || this.drawConnections(a));
        if (null != this.connecting_pos) {
          a.lineWidth = this.connections_width;
          switch(this.connecting_output.type) {
            case h.EVENT:
              c = h.EVENT_LINK_COLOR;
              break;
            default:
              c = h.CONNECTING_LINK_COLOR;
          }
          this.renderLink(a, this.connecting_pos, [this.canvas_mouse[0], this.canvas_mouse[1]], null, !1, null, c, this.connecting_output.dir || (this.connecting_node.flags.horizontal ? h.DOWN : h.RIGHT), h.CENTER);
          a.beginPath();
          this.connecting_output.type === h.EVENT || this.connecting_output.shape === h.BOX_SHAPE ? a.rect(this.connecting_pos[0] - 6 + 0.5, this.connecting_pos[1] - 5 + 0.5, 14, 10) : a.arc(this.connecting_pos[0], this.connecting_pos[1], 4, 0, 2 * Math.PI);
          a.fill();
          a.fillStyle = "#ffcc00";
          this._highlight_input && (a.beginPath(), a.arc(this._highlight_input[0], this._highlight_input[1], 6, 0, 2 * Math.PI), a.fill());
        }
        this.dragging_rectangle && (a.strokeStyle = "#FFF", a.strokeRect(this.dragging_rectangle[0], this.dragging_rectangle[1], this.dragging_rectangle[2], this.dragging_rectangle[3]));
        if (this.onDrawForeground) {
          this.onDrawForeground(a, this.visible_rect);
        }
        a.restore();
      }
      if (this.onDrawOverlay) {
        this.onDrawOverlay(a);
      }
      this.dirty_area && a.restore();
      a.finish2D && a.finish2D();
    }
  };
  d.prototype.renderInfo = function(a, c, b) {
    c = c || 0;
    b = b || 0;
    a.save();
    a.translate(c, b);
    a.font = "10px Arial";
    a.fillStyle = "#888";
    this.graph ? (a.fillText("T: " + this.graph.globaltime.toFixed(2) + "s", 5, 13), a.fillText("I: " + this.graph.iteration, 5, 26), a.fillText("N: " + this.graph._nodes.length + " [" + this.visible_nodes.length + "]", 5, 39), a.fillText("V: " + this.graph._version, 5, 52), a.fillText("FPS:" + this.fps.toFixed(2), 5, 65)) : a.fillText("No graph selected", 5, 13);
    a.restore();
  };
  d.prototype.drawBackCanvas = function() {
    var a = this.bgcanvas;
    if (a.width != this.canvas.width || a.height != this.canvas.height) {
      a.width = this.canvas.width, a.height = this.canvas.height;
    }
    this.bgctx || (this.bgctx = this.bgcanvas.getContext("2d"));
    var c = this.bgctx;
    c.start && c.start();
    this.clear_background && c.clearRect(0, 0, a.width, a.height);
    if (this._graph_stack && this._graph_stack.length) {
      c.save();
      var b = this.graph._subgraph_node;
      c.strokeStyle = b.bgcolor;
      c.lineWidth = 10;
      c.strokeRect(1, 1, a.width - 2, a.height - 2);
      c.lineWidth = 1;
      c.font = "40px Arial";
      c.textAlign = "center";
      c.fillStyle = b.bgcolor;
      for (var d = "", g = 1; g < this._graph_stack.length; ++g) {
        d += this._graph_stack[g]._subgraph_node.getTitle() + " >> ";
      }
      c.fillText(d + b.getTitle(), 0.5 * a.width, 40);
      c.restore();
    }
    b = !1;
    this.onRenderBackground && (b = this.onRenderBackground(a, c));
    c.restore();
    c.setTransform(1, 0, 0, 1, 0, 0);
    if (this.graph) {
      c.save();
      c.scale(this.scale, this.scale);
      c.translate(this.offset[0], this.offset[1]);
      if (this.background_image && 0.5 < this.scale && !b) {
        c.globalAlpha = this.zoom_modify_alpha ? (1.0 - 0.5 / this.scale) * this.editor_alpha : this.editor_alpha;
        c.imageSmoothingEnabled = c.mozImageSmoothingEnabled = c.imageSmoothingEnabled = !1;
        if (!this._bg_img || this._bg_img.name != this.background_image) {
          this._bg_img = new Image;
          this._bg_img.name = this.background_image;
          this._bg_img.src = this.background_image;
          var l = this;
          this._bg_img.onload = function() {
            l.draw(!0, !0);
          };
        }
        b = null;
        null == this._pattern && 0 < this._bg_img.width ? (b = c.createPattern(this._bg_img, "repeat"), this._pattern_img = this._bg_img, this._pattern = b) : b = this._pattern;
        b && (c.fillStyle = b, c.fillRect(this.visible_area[0], this.visible_area[1], this.visible_area[2], this.visible_area[3]), c.fillStyle = "transparent");
        c.globalAlpha = 1.0;
        c.imageSmoothingEnabled = c.mozImageSmoothingEnabled = c.imageSmoothingEnabled = !0;
      }
      this.graph._groups.length && !this.live_mode && this.drawGroups(a, c);
      if (this.onDrawBackground) {
        this.onDrawBackground(c, this.visible_area);
      }
      this.onBackgroundRender && (console.error("WARNING! onBackgroundRender deprecated, now is named onDrawBackground "), this.onBackgroundRender = null);
      this.render_canvas_border && (c.strokeStyle = "#235", c.strokeRect(0, 0, a.width, a.height));
      this.render_connections_shadows ? (c.shadowColor = "#000", c.shadowOffsetX = 0, c.shadowOffsetY = 0, c.shadowBlur = 6) : c.shadowColor = "rgba(0,0,0,0)";
      this.live_mode || this.drawConnections(c);
      c.shadowColor = "rgba(0,0,0,0)";
      c.restore();
    }
    c.finish && c.finish();
    this.dirty_bgcanvas = !1;
    this.dirty_canvas = !0;
  };
  var b = new Float32Array(2);
  d.prototype.drawNode = function(a, c) {
    this.current_node = a;
    var e = a.color || a.constructor.color || h.NODE_DEFAULT_COLOR, d = a.bgcolor || a.constructor.bgcolor || h.NODE_DEFAULT_BGCOLOR;
    if (this.live_mode) {
      if (!a.flags.collapsed && (c.shadowColor = "transparent", a.onDrawForeground)) {
        a.onDrawForeground(c, this, this.canvas);
      }
    } else {
      var g = this.editor_alpha;
      c.globalAlpha = g;
      this.render_shadows ? (c.shadowColor = h.DEFAULT_SHADOW_COLOR, c.shadowOffsetX = 2 * this.scale, c.shadowOffsetY = 2 * this.scale, c.shadowBlur = 3 * this.scale) : c.shadowColor = "transparent";
      if (!a.flags.collapsed || !a.onDrawCollaped || 1 != a.onDrawCollapsed(c, this)) {
        var l = a._shape || h.BOX_SHAPE;
        b.set(a.size);
        if (a.flags.collapsed) {
          c.font = this.inner_text_font;
          var n = a.getTitle ? a.getTitle() : a.title;
          a._collapsed_width = Math.min(a.size[0], c.measureText(n).width + 40);
          b[0] = a._collapsed_width;
          b[1] = 0;
        }
        a.flags.clip_area && (c.save(), c.beginPath(), l == h.BOX_SHAPE ? c.rect(0, 0, b[0], b[1]) : l == h.ROUND_SHAPE ? c.roundRect(0, 0, b[0], b[1], 10) : l == h.CIRCLE_SHAPE && c.arc(0.5 * b[0], 0.5 * b[1], 0.5 * b[0], 0, 2 * Math.PI), c.clip());
        this.drawNodeShape(a, c, b, e, d, a.selected, a.mouseOver);
        c.shadowColor = "transparent";
        c.textAlign = a.flags.horizontal ? "center" : "left";
        c.font = this.inner_text_font;
        d = 0.6 < this.scale;
        l = this.connecting_output;
        c.lineWidth = 1;
        n = 0;
        var m = new Float32Array(2);
        if (a.flags.collapsed) {
          g = d = null;
          if (a.inputs) {
            for (e = 0; e < a.inputs.length; e++) {
              if (f = a.inputs[e], null != f.link) {
                d = f;
                break;
              }
            }
          }
          if (a.outputs) {
            for (e = 0; e < a.outputs.length; e++) {
              f = a.outputs[e], f.links && f.links.length && (g = f);
            }
          }
          d && (e = 0, d = -0.5 * h.NODE_TITLE_HEIGHT, a.flags.horizontal && (e = 0.5 * a._collapsed_width, d = -h.NODE_TITLE_HEIGHT), c.fillStyle = f.color_on || this.default_connection_color.input_on, c.beginPath(), f.type === h.EVENT || f.shape === h.BOX_SHAPE ? c.rect(e - 7 + 0.5, d + 4 - 0.5 * h.NODE_TITLE_HEIGHT + 0.5, 14, h.NODE_TITLE_HEIGHT - 8) : f.shape === h.ARROW_SHAPE ? (c.moveTo(e + 8, d), c.lineTo(e + -4, d - 4), c.lineTo(e + -4, d + 4), c.closePath()) : c.arc(e, d, 4, 0, 2 * Math.PI), 
          c.fill());
          g && (e = a._collapsed_width, d = -0.5 * h.NODE_TITLE_HEIGHT, a.flags.horizontal && (e = 0.5 * a._collapsed_width, d = 0), c.fillStyle = f.color_on || this.default_connection_color.output_on, c.strokeStyle = "black", c.beginPath(), f.type === h.EVENT || f.shape === h.BOX_SHAPE ? c.rect(e - 7 + 0.5, d + 4 - 0.5 * h.NODE_TITLE_HEIGHT + 0.5, 14, h.NODE_TITLE_HEIGHT - 8) : f.shape === h.ARROW_SHAPE ? (c.moveTo(e + 6, d), c.lineTo(e - 6, d - 4), c.lineTo(e - 6, d + 4), c.closePath()) : c.arc(e, 
          d, 4, 0, 2 * Math.PI), c.fill(), c.stroke());
        } else {
          if (a.inputs) {
            for (e = 0; e < a.inputs.length; e++) {
              var f = a.inputs[e];
              c.globalAlpha = g;
              this.connecting_node && h.isValidConnection(f.type && l.type) && (c.globalAlpha = 0.4 * g);
              c.fillStyle = null != f.link ? f.color_on || this.default_connection_color.input_on : f.color_off || this.default_connection_color.input_off;
              var p = a.getConnectionPos(!0, e, m);
              p[0] -= a.pos[0];
              p[1] -= a.pos[1];
              n < p[1] + 0.5 * h.NODE_SLOT_HEIGHT && (n = p[1] + 0.5 * h.NODE_SLOT_HEIGHT);
              c.beginPath();
              f.type === h.EVENT || f.shape === h.BOX_SHAPE ? c.rect(p[0] - 6 + 0.5, p[1] - 5 + 0.5, 14, 10) : f.shape === h.ARROW_SHAPE ? (c.moveTo(p[0] + 8, p[1] + 0.5), c.lineTo(p[0] - 4, p[1] + 6 + 0.5), c.lineTo(p[0] - 4, p[1] - 6 + 0.5), c.closePath()) : c.arc(p[0], p[1], 4, 0, 2 * Math.PI);
              c.fill();
              if (d) {
                var k = null != f.label ? f.label : f.name;
                k && (c.fillStyle = h.NODE_TEXT_COLOR, a.flags.horizontal || f.dir == h.UP ? c.fillText(k, p[0], p[1] - 10) : c.fillText(k, p[0] + 10, p[1] + 5));
              }
            }
          }
          this.connecting_node && (c.globalAlpha = 0.4 * g);
          c.textAlign = a.flags.horizontal ? "center" : "right";
          c.strokeStyle = "black";
          if (a.outputs) {
            for (e = 0; e < a.outputs.length; e++) {
              if (f = a.outputs[e], p = a.getConnectionPos(!1, e, m), p[0] -= a.pos[0], p[1] -= a.pos[1], n < p[1] + 0.5 * h.NODE_SLOT_HEIGHT && (n = p[1] + 0.5 * h.NODE_SLOT_HEIGHT), c.fillStyle = f.links && f.links.length ? f.color_on || this.default_connection_color.output_on : f.color_off || this.default_connection_color.output_off, c.beginPath(), f.type === h.EVENT || f.shape === h.BOX_SHAPE ? c.rect(p[0] - 6 + 0.5, p[1] - 5 + 0.5, 14, 10) : f.shape === h.ARROW_SHAPE ? (c.moveTo(p[0] + 8, p[1] + 
              0.5), c.lineTo(p[0] - 4, p[1] + 6 + 0.5), c.lineTo(p[0] - 4, p[1] - 6 + 0.5), c.closePath()) : c.arc(p[0], p[1], 4, 0, 2 * Math.PI), c.fill(), c.stroke(), d && (k = null != f.label ? f.label : f.name)) {
                c.fillStyle = h.NODE_TEXT_COLOR, a.flags.horizontal || f.dir == h.DOWN ? c.fillText(k, p[0], p[1] - 8) : c.fillText(k, p[0] - 10, p[1] + 5);
              }
            }
          }
          c.textAlign = "left";
          c.globalAlpha = 1;
          if (a.widgets) {
            if (a.flags.horizontal || a.flags.widgets_up) {
              n = 2;
            }
            this.drawNodeWidgets(a, n, c, this.node_widget && this.node_widget[0] == a ? this.node_widget[1] : null);
          }
          if (a.onDrawForeground) {
            a.onDrawForeground(c, this, this.canvas);
          }
        }
        a.flags.clip_area && c.restore();
        c.globalAlpha = 1.0;
      }
    }
  };
  var p = new Float32Array(4);
  d.prototype.drawNodeShape = function(a, c, b, m, g, l, n) {
    c.strokeStyle = m;
    c.fillStyle = g;
    g = h.NODE_TITLE_HEIGHT;
    var e = a._shape || a.constructor.shape || h.BOX_SHAPE, f = a.constructor.title_mode, k = !0;
    f == h.TRANSPARENT_TITLE ? k = !1 : f == h.AUTOHIDE_TITLE && n && (k = !0);
    p[0] = 0;
    p[1] = k ? -g : 0;
    p[2] = b[0] + 1;
    p[3] = k ? b[1] + g : b[1];
    a.flags.collapsed || (c.beginPath(), e == h.BOX_SHAPE || 0.5 > this.scale ? c.fillRect(p[0], p[1], p[2], p[3]) : e == h.ROUND_SHAPE || e == h.CARD_SHAPE ? c.roundRect(p[0], p[1], p[2], p[3], this.round_radius, e == h.CARD_SHAPE ? 0 : this.round_radius) : e == h.CIRCLE_SHAPE && c.arc(0.5 * b[0], 0.5 * b[1], 0.5 * b[0], 0, 2 * Math.PI), c.fill());
    c.shadowColor = "transparent";
    a.bgImage && a.bgImage.width && c.drawImage(a.bgImage, 0.5 * (b[0] - a.bgImage.width), 0.5 * (b[1] - a.bgImage.height));
    a.bgImageUrl && !a.bgImage && (a.bgImage = a.loadImage(a.bgImageUrl));
    if (a.onDrawBackground) {
      a.onDrawBackground(c, this, this.canvas);
    }
    if (k || f == h.TRANSPARENT_TITLE) {
      if (a.onDrawTitleBar) {
        a.onDrawTitleBar(c, g, b, this.scale, m);
      } else {
        if (f != h.TRANSPARENT_TITLE) {
          a.flags.collapsed && (c.shadowColor = h.DEFAULT_SHADOW_COLOR);
          this.use_gradients ? (n = d.gradients[m], n || (n = d.gradients[m] = c.createLinearGradient(0, 0, 400, 0), n.addColorStop(0, m), n.addColorStop(1, "#000")), c.fillStyle = n) : c.fillStyle = m;
          var q = c.globalAlpha;
          c.beginPath();
          e == h.BOX_SHAPE || 0.5 > this.scale ? c.rect(0, -g, b[0] + 1, g) : (e == h.ROUND_SHAPE || e == h.CARD_SHAPE) && c.roundRect(0, -g, b[0] + 1, g, this.round_radius, a.flags.collapsed ? this.round_radius : 0);
          c.fill();
          c.shadowColor = "transparent";
        }
      }
      if (a.onDrawTitleBox) {
        a.onDrawTitleBox(c, g, b, this.scale);
      } else {
        e == h.ROUND_SHAPE || e == h.CIRCLE_SHAPE || e == h.CARD_SHAPE ? (0.5 < this.scale && (c.fillStyle = "black", c.beginPath(), c.arc(0.5 * g, -0.5 * g, 0.5 * (g - 8), 0, 2 * Math.PI), c.fill()), c.fillStyle = a.boxcolor || h.NODE_DEFAULT_BOXCOLOR, c.beginPath(), c.arc(0.5 * g, -0.5 * g, 0.4 * (g - 8), 0, 2 * Math.PI), c.fill()) : (0.5 < this.scale && (c.fillStyle = "black", c.fillRect(4, -g + 4, g - 8, g - 8)), c.fillStyle = a.boxcolor || h.NODE_DEFAULT_BOXCOLOR, c.fillRect(5, -g + 5, g - 10, 
        g - 10));
      }
      c.globalAlpha = q;
      if (a.onDrawTitleText) {
        a.onDrawTitleText(c, g, b, this.scale, this.title_text_font, l);
      }
      0.5 < this.scale && (c.font = this.title_text_font, n = a.getTitle()) && (c.fillStyle = l ? "white" : a.constructor.title_text_color || this.node_title_color, a.flags.collapsed ? (c.textAlign = "center", q = c.measureText(n), c.fillText(n, g + 0.5 * q.width, 0.2 * -g), c.textAlign = "left") : (c.textAlign = "left", c.fillText(n, g, 0.2 * -g)));
      if (a.onDrawTitle) {
        a.onDrawTitle(c);
      }
    }
    if (l) {
      if (a.onBounding) {
        a.onBounding(p);
      }
      f == h.TRANSPARENT_TITLE && (p[1] -= g, p[3] += g);
      c.lineWidth = 1;
      c.globalAlpha = 0.8;
      c.beginPath();
      e == h.BOX_SHAPE ? c.rect(-6 + p[0], -6 + p[1], 12 + p[2], 12 + p[3]) : e == h.ROUND_SHAPE || e == h.CARD_SHAPE && a.flags.collapsed ? c.roundRect(-6 + p[0], -6 + p[1], 12 + p[2], 12 + p[3], 2 * this.round_radius) : e == h.CARD_SHAPE ? c.roundRect(-6 + p[0], -6 + p[1], 12 + p[2], 12 + p[3], 2 * this.round_radius, 2) : e == h.CIRCLE_SHAPE && c.arc(0.5 * b[0], 0.5 * b[1], 0.5 * b[0] + 6, 0, 2 * Math.PI);
      c.strokeStyle = "#FFF";
      c.stroke();
      c.strokeStyle = m;
      c.globalAlpha = 1;
    }
  };
  d.prototype.drawConnections = function(a) {
    var c = h.getTime(), b = this.visible_area;
    b = new Float32Array([b[0] - 20, b[1] - 20, b[2] + 40, b[3] + 40]);
    var d = new Float32Array(4), g = new Float32Array(2), l = new Float32Array(2);
    a.lineWidth = this.connections_width;
    a.fillStyle = "#AAA";
    a.strokeStyle = "#AAA";
    a.globalAlpha = this.editor_alpha;
    for (var n = this.graph._nodes, m = 0, f = n.length; m < f; ++m) {
      var p = n[m];
      if (p.inputs && p.inputs.length) {
        for (var k = 0; k < p.inputs.length; ++k) {
          var q = p.inputs[k];
          if (q && null != q.link && (q = this.graph.links[q.link])) {
            var t = this.graph.getNodeById(q.origin_id);
            if (null != t) {
              var u = q.origin_slot;
              var v = -1 == u ? [t.pos[0] + 10, t.pos[1] + 10] : t.getConnectionPos(!1, u, g);
              var w = p.getConnectionPos(!0, k, l);
              d[0] = v[0];
              d[1] = v[1];
              d[2] = w[0] - v[0];
              d[3] = w[1] - v[1];
              0 > d[2] && (d[0] += d[2], d[2] = Math.abs(d[2]));
              0 > d[3] && (d[1] += d[3], d[3] = Math.abs(d[3]));
              if (x(d, b)) {
                var C = t.outputs[u];
                u = p.inputs[k];
                if (C && u && (t = C.dir || (t.flags.horizontal ? h.DOWN : h.RIGHT), u = u.dir || (p.flags.horizontal ? h.UP : h.LEFT), this.renderLink(a, v, w, q, !1, 0, null, t, u), q && q._last_time && 1000 > c - q._last_time)) {
                  C = 2.0 - 0.002 * (c - q._last_time);
                  var I = a.globalAlpha;
                  a.globalAlpha = I * C;
                  this.renderLink(a, v, w, q, !0, C, "white", t, u);
                  a.globalAlpha = I;
                }
              }
            }
          }
        }
      }
    }
    a.globalAlpha = 1;
  };
  d.prototype.renderLink = function(a, c, b, m, g, l, n, f, p) {
    if (this.highquality_render) {
      f = f || h.RIGHT;
      p = p || h.LEFT;
      var e = t(c, b);
      this.render_connections_border && 0.6 < this.scale && (a.lineWidth = this.connections_width + 4);
      !n && m && (n = m.color || d.link_type_colors[m.type]);
      n || (n = this.default_link_color);
      null != m && this.highlighted_links[m.id] && (n = "#FFF");
      a.beginPath();
      if (this.render_curved_connections) {
        a.moveTo(c[0], c[1]);
        var k = m = 0, q = 0, A = 0;
        switch(f) {
          case h.LEFT:
            m = -0.25 * e;
            break;
          case h.RIGHT:
            m = 0.25 * e;
            break;
          case h.UP:
            k = -0.25 * e;
            break;
          case h.DOWN:
            k = 0.25 * e;
        }
        switch(p) {
          case h.LEFT:
            q = -0.25 * e;
            break;
          case h.RIGHT:
            q = 0.25 * e;
            break;
          case h.UP:
            A = -0.25 * e;
            break;
          case h.DOWN:
            A = 0.25 * e;
        }
        a.bezierCurveTo(c[0] + m, c[1] + k, b[0] + q, b[1] + A, b[0], b[1]);
      } else {
        a.moveTo(c[0] + 10, c[1]), a.lineTo(0.5 * (c[0] + 10 + (b[0] - 10)), c[1]), a.lineTo(0.5 * (c[0] + 10 + (b[0] - 10)), b[1]), a.lineTo(b[0] - 10, b[1]);
      }
      this.render_connections_border && 0.6 < this.scale && !g && (a.strokeStyle = "rgba(0,0,0,0.5)", a.stroke());
      a.lineWidth = this.connections_width;
      a.fillStyle = a.strokeStyle = n;
      a.stroke();
      this.render_connection_arrows && 0.6 <= this.scale && this.render_connection_arrows && 0.6 < this.scale && (g = this.computeConnectionPoint(c, b, 0.5, f, p), n = this.computeConnectionPoint(c, b, 0.51, f, p), n = this.render_curved_connections ? -Math.atan2(n[0] - g[0], n[1] - g[1]) : b[1] > c[1] ? 0 : Math.PI, a.save(), a.translate(g[0], g[1]), a.rotate(n), a.beginPath(), a.moveTo(-5, -5), a.lineTo(0, 5), a.lineTo(5, -5), a.fill(), a.restore());
      if (l) {
        for (l = 0; 5 > l; ++l) {
          g = (0.001 * h.getTime() + 0.2 * l) % 1, g = this.computeConnectionPoint(c, b, g, f, p), a.beginPath(), a.arc(g[0], g[1], 5, 0, 2 * Math.PI), a.fill();
        }
      }
    } else {
      a.beginPath(), a.moveTo(c[0], c[1]), a.lineTo(b[0], b[1]), a.stroke();
    }
  };
  d.prototype.computeConnectionPoint = function(a, c, b, d, g) {
    d = d || h.RIGHT;
    g = g || h.LEFT;
    var e = t(a, c), n = [a[0], a[1]], m = [c[0], c[1]];
    switch(d) {
      case h.LEFT:
        n[0] += -0.25 * e;
        break;
      case h.RIGHT:
        n[0] += 0.25 * e;
        break;
      case h.UP:
        n[1] += -0.25 * e;
        break;
      case h.DOWN:
        n[1] += 0.25 * e;
    }
    switch(g) {
      case h.LEFT:
        m[0] += -0.25 * e;
        break;
      case h.RIGHT:
        m[0] += 0.25 * e;
        break;
      case h.UP:
        m[1] += -0.25 * e;
        break;
      case h.DOWN:
        m[1] += 0.25 * e;
    }
    d = (1 - b) * (1 - b) * (1 - b);
    g = 3 * (1 - b) * (1 - b) * b;
    e = 3 * (1 - b) * b * b;
    b *= b * b;
    return [d * a[0] + g * n[0] + e * m[0] + b * c[0], d * a[1] + g * n[1] + e * m[1] + b * c[1]];
  };
  d.prototype.drawExecutionOrder = function(a) {
    a.shadowColor = "transparent";
    a.globalAlpha = 0.25;
    a.textAlign = "center";
    a.strokeStyle = "white";
    a.globalAlpha = 0.75;
    for (var c = this.visible_nodes, b = 0; b < c.length; ++b) {
      var d = c[b];
      a.fillStyle = "black";
      a.fillRect(d.pos[0] - h.NODE_TITLE_HEIGHT, d.pos[1] - h.NODE_TITLE_HEIGHT, h.NODE_TITLE_HEIGHT, h.NODE_TITLE_HEIGHT);
      0 == d.order && a.strokeRect(d.pos[0] - h.NODE_TITLE_HEIGHT + 0.5, d.pos[1] - h.NODE_TITLE_HEIGHT + 0.5, h.NODE_TITLE_HEIGHT, h.NODE_TITLE_HEIGHT);
      a.fillStyle = "#FFF";
      a.fillText(d.order, d.pos[0] + -0.5 * h.NODE_TITLE_HEIGHT, d.pos[1] - 6);
    }
    a.globalAlpha = 1;
  };
  d.prototype.drawNodeWidgets = function(a, c, b, d) {
    if (!a.widgets || !a.widgets.length) {
      return 0;
    }
    var e = a.size[0], l = a.widgets;
    c += 2;
    var n = h.NODE_WIDGET_HEIGHT, m = 0.5 < this.scale;
    b.save();
    b.globalAlpha = this.editor_alpha;
    for (var f = 0; f < l.length; ++f) {
      var p = l[f], k = c;
      p.y && (k = p.y);
      p.last_y = k;
      b.strokeStyle = "#AAA";
      b.fillStyle = "#222";
      b.textAlign = "left";
      switch(p.type) {
        case "button":
          p.clicked && (b.fillStyle = "#AAA", p.clicked = !1, this.dirty_canvas = !0);
          b.fillRect(10, k, e - 20, n);
          b.strokeRect(10, k, e - 20, n);
          m && (b.textAlign = "center", b.fillStyle = "#AAA", b.fillText(p.name, 0.5 * e, k + 0.7 * n));
          break;
        case "toggle":
          b.textAlign = "left";
          b.strokeStyle = "#AAA";
          b.fillStyle = "#111";
          b.beginPath();
          b.roundRect(10, c, e - 20, n, 0.5 * n);
          b.fill();
          b.stroke();
          b.fillStyle = p.value ? "#89A" : "#333";
          b.beginPath();
          b.arc(e - 20, k + 0.5 * n, 0.36 * n, 0, 2 * Math.PI);
          b.fill();
          m && (b.fillStyle = "#999", null != p.name && b.fillText(p.name, 20, k + 0.7 * n), b.fillStyle = p.value ? "#DDD" : "#888", b.textAlign = "right", b.fillText(p.value ? p.options.on || "true" : p.options.off || "false", e - 30, k + 0.7 * n));
          break;
        case "slider":
          b.fillStyle = "#111";
          b.fillRect(10, k, e - 20, n);
          var q = (p.value - p.options.min) / (p.options.max - p.options.min);
          b.fillStyle = d == p ? "#89A" : "#678";
          b.fillRect(10, k, q * (e - 20), n);
          b.strokeRect(10, k, e - 20, n);
          m && (b.textAlign = "center", b.fillStyle = "#DDD", b.fillText(p.name + "  " + Number(p.value).toFixed(3), 0.5 * e, k + 0.7 * n));
          break;
        case "number":
        case "combo":
          b.textAlign = "left";
          b.strokeStyle = "#AAA";
          b.fillStyle = "#111";
          b.beginPath();
          b.roundRect(10, c, e - 20, n, 0.5 * n);
          b.fill();
          b.stroke();
          m && (b.fillStyle = "#AAA", b.beginPath(), b.moveTo(26, c + 5), b.lineTo(16, c + 0.5 * n), b.lineTo(26, c + n - 5), b.moveTo(e - 26, c + 5), b.lineTo(e - 16, c + 0.5 * n), b.lineTo(e - 26, c + n - 5), b.fill(), b.fillStyle = "#999", b.fillText(p.name, 30, k + 0.7 * n), b.fillStyle = "#DDD", b.textAlign = "right", "number" == p.type ? b.fillText(Number(p.value).toFixed(void 0 !== p.options.precision ? p.options.precision : 3), e - 40, k + 0.7 * n) : b.fillText(p.value, e - 40, k + 0.7 * 
          n));
          break;
        case "text":
          b.textAlign = "left";
          b.strokeStyle = "#AAA";
          b.fillStyle = "#111";
          b.beginPath();
          b.roundRect(10, c, e - 20, n, 0.5 * n);
          b.fill();
          b.stroke();
          m && (b.fillStyle = "#999", null != p.name && b.fillText(p.name, 20, k + 0.7 * n), b.fillStyle = "#DDD", b.textAlign = "right", b.fillText(p.value, e - 20, k + 0.7 * n));
          break;
        default:
          p.draw && p.draw(b, a, p, k, n);
      }
      c += n + 4;
    }
    b.restore();
  };
  d.prototype.processNodeWidgets = function(a, c, b, d) {
    if (!a.widgets || !a.widgets.length) {
      return null;
    }
    for (var e = c[0] - a.pos[0], l = c[1] - a.pos[1], n = a.size[0], m = this, p = this.getCanvasWindow(), f = 0; f < a.widgets.length; ++f) {
      var k = a.widgets[f];
      if (k == d || 6 < e && e < n - 12 && l > k.last_y && l < k.last_y + h.NODE_WIDGET_HEIGHT) {
        switch(k.type) {
          case "button":
            k.callback && setTimeout(function() {
              k.callback(k, m, a, c);
            }, 20);
            this.dirty_canvas = k.clicked = !0;
            break;
          case "slider":
            b = Math.clamp((e - 10) / (n - 20), 0, 1);
            k.value = k.options.min + (k.options.max - k.options.min) * b;
            k.callback && setTimeout(function() {
              k.callback(k.value, m, a, c);
            }, 20);
            this.dirty_canvas = !0;
            break;
          case "number":
          case "combo":
            "mousemove" == b.type && "number" == k.type ? (k.value += 0.1 * b.deltaX * (k.options.step || 1), null != k.options.min && k.value < k.options.min && (k.value = k.options.min), null != k.options.max && k.value > k.options.max && (k.value = k.options.max)) : "mousedown" == b.type && ((d = k.options.values) && d.constructor === Function && (d = k.options.values(k, a)), e = 40 > e ? -1 : e > n - 40 ? 1 : 0, "number" == k.type ? (k.value += 0.1 * e * (k.options.step || 1), null != k.options.min && 
            k.value < k.options.min && (k.value = k.options.min), null != k.options.max && k.value > k.options.max && (k.value = k.options.max)) : e ? (b = d.indexOf(k.value) + e, b >= d.length && (b = 0), 0 > b && (b = d.length - 1), k.value = d[b]) : new h.ContextMenu(d, {event:b, className:"dark", callback:function(a, c, b) {
              this.value = a;
              m.dirty_canvas = !0;
              return !1;
            }.bind(k)}, p));
            k.callback && setTimeout(function() {
              this.callback(this.value, m, a, c);
            }.bind(k), 20);
            this.dirty_canvas = !0;
            break;
          case "toggle":
            "mousedown" == b.type && (k.value = !k.value, k.callback && setTimeout(function() {
              k.callback(k.value, m, a, c);
            }, 20));
            break;
          case "text":
            "mousedown" == b.type && this.prompt("Value", k.value, function(c) {
              this.value = c;
              k.callback && k.callback(c, m, a);
            }.bind(k), b);
            break;
          default:
            k.mouse && k.mouse(ctx, b, [e, l], a);
        }
        return k;
      }
    }
    return null;
  };
  d.prototype.drawGroups = function(a, c) {
    if (this.graph) {
      a = this.graph._groups;
      c.save();
      c.globalAlpha = 0.5 * this.editor_alpha;
      for (var b = 0; b < a.length; ++b) {
        var d = a[b];
        if (x(this.visible_area, d._bounding)) {
          c.fillStyle = d.color || "#335";
          c.strokeStyle = d.color || "#335";
          var g = d._pos, l = d._size;
          c.globalAlpha = 0.25 * this.editor_alpha;
          c.beginPath();
          c.rect(g[0] + 0.5, g[1] + 0.5, l[0], l[1]);
          c.fill();
          c.globalAlpha = this.editor_alpha;
          c.stroke();
          c.beginPath();
          c.moveTo(g[0] + l[0], g[1] + l[1]);
          c.lineTo(g[0] + l[0] - 10, g[1] + l[1]);
          c.lineTo(g[0] + l[0], g[1] + l[1] - 10);
          c.fill();
          l = d.font_size || h.DEFAULT_GROUP_FONT_SIZE;
          c.font = l + "px Arial";
          c.fillText(d.title, g[0] + 4, g[1] + l);
        }
      }
      c.restore();
    }
  };
  d.prototype.resize = function(a, c) {
    a || c || (c = this.canvas.parentNode, a = c.offsetWidth, c = c.offsetHeight);
    if (this.canvas.width != a || this.canvas.height != c) {
      this.canvas.width = a, this.canvas.height = c, this.bgcanvas.width = this.canvas.width, this.bgcanvas.height = this.canvas.height, this.setDirty(!0, !0);
    }
  };
  d.prototype.switchLiveMode = function(a) {
    if (a) {
      var c = this, b = this.live_mode ? 1.1 : 0.9;
      this.live_mode && (this.live_mode = !1, this.editor_alpha = 0.1);
      var d = setInterval(function() {
        c.editor_alpha *= b;
        c.dirty_canvas = !0;
        c.dirty_bgcanvas = !0;
        1 > b && 0.01 > c.editor_alpha && (clearInterval(d), 1 > b && (c.live_mode = !0));
        1 < b && 0.99 < c.editor_alpha && (clearInterval(d), c.editor_alpha = 1);
      }, 1);
    } else {
      this.live_mode = !this.live_mode, this.dirty_bgcanvas = this.dirty_canvas = !0;
    }
  };
  d.prototype.onNodeSelectionChange = function(a) {
  };
  d.prototype.touchHandler = function(a) {
    var c = a.changedTouches[0];
    switch(a.type) {
      case "touchstart":
        var b = "mousedown";
        break;
      case "touchmove":
        b = "mousemove";
        break;
      case "touchend":
        b = "mouseup";
        break;
      default:
        return;
    }
    var d = this.getCanvasWindow(), g = d.document.createEvent("MouseEvent");
    g.initMouseEvent(b, !0, !0, d, 1, c.screenX, c.screenY, c.clientX, c.clientY, !1, !1, !1, !1, 0, null);
    c.target.dispatchEvent(g);
    a.preventDefault();
  };
  d.onGroupAdd = function(a, c, b) {
    a = d.active_canvas;
    a.getCanvasWindow();
    c = new h.LGraphGroup;
    c.pos = a.convertEventToCanvas(b);
    a.graph.add(c);
  };
  d.onMenuAdd = function(a, c, b, m) {
    function e(a, c) {
      c = m.getFirstEvent();
      if (a = h.createNode(a.value)) {
        a.pos = l.convertEventToCanvas(c), l.graph.add(a);
      }
    }
    var l = d.active_canvas, n = l.getCanvasWindow();
    a = h.getNodeTypesCategories();
    c = [];
    for (var p in a) {
      a[p] && c.push({value:a[p], content:a[p], has_submenu:!0});
    }
    var f = new h.ContextMenu(c, {event:b, callback:function(a, c, b) {
      a = h.getNodeTypesInCategory(a.value, l.filter);
      c = [];
      for (var g in a) {
        a[g].skip_list || c.push({content:a[g].title, value:a[g].type});
      }
      new h.ContextMenu(c, {event:b, callback:e, parentMenu:f}, n);
      return !1;
    }, parentMenu:m}, n);
    return !1;
  };
  d.onMenuCollapseAll = function() {
  };
  d.onMenuNodeEdit = function() {
  };
  d.showMenuNodeOptionalInputs = function(a, c, b, m, g) {
    if (g) {
      var e = this;
      a = d.active_canvas.getCanvasWindow();
      c = g.optional_inputs;
      g.onGetInputs && (c = g.onGetInputs());
      var n = [];
      if (c) {
        for (var p in c) {
          var f = c[p];
          if (f) {
            var k = f[0];
            f[2] && f[2].label && (k = f[2].label);
            k = {content:k, value:f};
            f[1] == h.ACTION && (k.className = "event");
            n.push(k);
          } else {
            n.push(null);
          }
        }
      }
      this.onMenuNodeInputs && (n = this.onMenuNodeInputs(n));
      if (n.length) {
        return new h.ContextMenu(n, {event:b, callback:function(a, c, b) {
          g && (a.callback && a.callback.call(e, g, a, c, b), a.value && (g.addInput(a.value[0], a.value[1], a.value[2]), g.setDirtyCanvas(!0, !0)));
        }, parentMenu:m, node:g}, a), !1;
      }
    }
  };
  d.showMenuNodeOptionalOutputs = function(a, c, b, m, g) {
    function e(a, c, b) {
      if (g && (a.callback && a.callback.call(n, g, a, c, b), a.value)) {
        if (b = a.value[1], !b || b.constructor !== Object && b.constructor !== Array) {
          g.addOutput(a.value[0], a.value[1], a.value[2]), g.setDirtyCanvas(!0, !0);
        } else {
          a = [];
          for (var d in b) {
            a.push({content:d, value:b[d]});
          }
          new h.ContextMenu(a, {event:c, callback:e, parentMenu:m, node:g});
          return !1;
        }
      }
    }
    if (g) {
      var n = this;
      a = d.active_canvas.getCanvasWindow();
      c = g.optional_outputs;
      g.onGetOutputs && (c = g.onGetOutputs());
      var p = [];
      if (c) {
        for (var f in c) {
          var k = c[f];
          if (!k) {
            p.push(null);
          } else {
            if (!g.flags || !g.flags.skip_repeated_outputs || -1 == g.findOutputSlot(k[0])) {
              var q = k[0];
              k[2] && k[2].label && (q = k[2].label);
              q = {content:q, value:k};
              k[1] == h.EVENT && (q.className = "event");
              p.push(q);
            }
          }
        }
      }
      this.onMenuNodeOutputs && (p = this.onMenuNodeOutputs(p));
      if (p.length) {
        return new h.ContextMenu(p, {event:b, callback:e, parentMenu:m, node:g}, a), !1;
      }
    }
  };
  d.onShowMenuNodeProperties = function(a, c, b, m, g) {
    if (g && g.properties) {
      var e = d.active_canvas;
      c = e.getCanvasWindow();
      var n = [], p;
      for (p in g.properties) {
        a = void 0 !== g.properties[p] ? g.properties[p] : " ", a = d.decodeHTML(a), n.push({content:"<span class='property_name'>" + p + "</span><span class='property_value'>" + a + "</span>", value:p});
      }
      if (n.length) {
        return new h.ContextMenu(n, {event:b, callback:function(a, c, b, d) {
          g && (c = this.getBoundingClientRect(), e.showEditPropertyValue(g, a.value, {position:[c.left, c.top]}));
        }, parentMenu:m, allow_html:!0, node:g}, c), !1;
      }
    }
  };
  d.decodeHTML = function(a) {
    var c = document.createElement("div");
    c.innerText = a;
    return c.innerHTML;
  };
  d.onResizeNode = function(a, c, b, d, g) {
    g && (g.size = g.computeSize(), g.setDirtyCanvas(!0, !0));
  };
  d.onShowPropertyEditor = function(a, c, b, p, g) {
    function e() {
      var c = f.value;
      "Number" == a.type ? c = Number(c) : "Boolean" == a.type && (c = !!c);
      g[m] = c;
      h.parentNode.removeChild(h);
      g.setDirtyCanvas(!0, !0);
    }
    var m = a.property || "title";
    c = g[m];
    var h = document.createElement("div");
    h.className = "graphdialog";
    h.innerHTML = "<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>";
    h.querySelector(".name").innerText = m;
    var f = h.querySelector("input");
    f && (f.value = c, f.addEventListener("blur", function(a) {
      this.focus();
    }), f.addEventListener("keydown", function(a) {
      13 == a.keyCode && (e(), a.preventDefault(), a.stopPropagation());
    }));
    c = d.active_canvas.canvas;
    b = c.getBoundingClientRect();
    var k = p = -20;
    b && (p -= b.left, k -= b.top);
    event ? (h.style.left = event.pageX + p + "px", h.style.top = event.pageY + k + "px") : (h.style.left = 0.5 * c.width + p + "px", h.style.top = 0.5 * c.height + k + "px");
    h.querySelector("button").addEventListener("click", e);
    c.parentNode.appendChild(h);
  };
  d.prototype.prompt = function(a, c, b, p) {
    var e = this;
    a = a || "";
    var l = document.createElement("div");
    l.className = "graphdialog rounded";
    l.innerHTML = "<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>";
    l.close = function() {
      e.prompt_box = null;
      l.parentNode.removeChild(l);
    };
    l.addEventListener("mouseleave", function(a) {
      l.close();
    });
    e.prompt_box && e.prompt_box.close();
    e.prompt_box = l;
    l.querySelector(".name").innerText = a;
    l.querySelector(".value").value = c;
    var m = l.querySelector("input");
    m.addEventListener("keydown", function(a) {
      if (27 == a.keyCode) {
        l.close();
      } else {
        if (13 == a.keyCode) {
          b && b(this.value), l.close();
        } else {
          return;
        }
      }
      a.preventDefault();
      a.stopPropagation();
    });
    l.querySelector("button").addEventListener("click", function(a) {
      b && b(m.value);
      e.setDirty(!0);
      l.close();
    });
    a = d.active_canvas.canvas;
    c = a.getBoundingClientRect();
    var h = -20, f = -20;
    c && (h -= c.left, f -= c.top);
    p ? (l.style.left = p.pageX + h + "px", l.style.top = p.pageY + f + "px") : (l.style.left = 0.5 * a.width + h + "px", l.style.top = 0.5 * a.height + f + "px");
    a.parentNode.appendChild(l);
    setTimeout(function() {
      m.focus();
    }, 10);
    return l;
  };
  d.search_limit = -1;
  d.prototype.showSearchBox = function(a) {
    function c(c) {
      if (c) {
        if (g.onSearchBoxSelection) {
          g.onSearchBoxSelection(c, a, u);
        } else {
          var b = h.searchbox_extras[c];
          b && (c = b.type);
          if (c = h.createNode(c)) {
            c.pos = u.convertEventToCanvas(a), u.graph.add(c);
          }
          if (b && b.data) {
            if (b.data.properties) {
              for (var e in b.data.properties) {
                c.addProperty(b.data.properties[e][0], b.data.properties[e][0]);
              }
            }
            if (b.data.inputs) {
              for (e in c.inputs = [], b.data.inputs) {
                c.addOutput(b.data.inputs[e][0], b.data.inputs[e][1]);
              }
            }
            if (b.data.outputs) {
              for (e in c.outputs = [], b.data.outputs) {
                c.addOutput(b.data.outputs[e][0], b.data.outputs[e][1]);
              }
            }
            b.data.title && (c.title = b.data.title);
            b.data.json && c.configure(b.data.json);
          }
        }
      }
      l.close();
    }
    function b(a) {
      var c = q;
      q && q.classList.remove("selected");
      q ? (q = a ? q.nextSibling : q.previousSibling) || (q = c) : q = a ? m.childNodes[0] : m.childNodes[m.childNodes.length];
      q && (q.classList.add("selected"), q.scrollIntoView());
    }
    function p() {
      function a(a, b) {
        var e = document.createElement("div");
        f || (f = a);
        e.innerText = a;
        e.dataset.type = escape(a);
        e.className = "litegraph lite-search-item";
        b && (e.className += " " + b);
        e.addEventListener("click", function(a) {
          c(unescape(this.dataset.type));
        });
        m.appendChild(e);
      }
      k = null;
      var b = t.value;
      f = null;
      m.innerHTML = "";
      if (b) {
        if (g.onSearchBox) {
          var e = g.onSearchBox(help, b, u);
          if (e) {
            for (var l = 0; l < e.length; ++l) {
              a(e[l]);
            }
          }
        } else {
          e = 0;
          b = b.toLowerCase();
          for (l in h.searchbox_extras) {
            var L = h.searchbox_extras[l];
            if (-1 !== L.desc.toLowerCase().indexOf(b) && (a(L.desc, "searchbox_extra"), -1 !== d.search_limit && e++ > d.search_limit)) {
              break;
            }
          }
          if (Array.prototype.filter) {
            for (L = Object.keys(h.registered_node_types).filter(function(a) {
              return -1 !== a.toLowerCase().indexOf(b);
            }), l = 0; l < L.length && !(a(L[l]), -1 !== d.search_limit && e++ > d.search_limit); l++) {
            }
          } else {
            for (l in h.registered_node_types) {
              if (-1 != l.indexOf(b) && (a(l), -1 !== d.search_limit && e++ > d.search_limit)) {
                break;
              }
            }
          }
        }
      }
    }
    var g = this, l = document.createElement("div");
    l.className = "litegraph litesearchbox graphdialog rounded";
    l.innerHTML = "<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/><div class='helper'></div>";
    l.close = function() {
      g.search_box = null;
      l.parentNode.removeChild(l);
    };
    l.addEventListener("mouseleave", function(a) {
      l.close();
    });
    g.search_box && g.search_box.close();
    g.search_box = l;
    var m = l.querySelector(".helper"), f = null, k = null, q = null, t = l.querySelector("input");
    t && (t.addEventListener("blur", function(a) {
      this.focus();
    }), t.addEventListener("keydown", function(a) {
      if (38 == a.keyCode) {
        b(!1);
      } else {
        if (40 == a.keyCode) {
          b(!0);
        } else {
          if (27 == a.keyCode) {
            l.close();
          } else {
            if (13 == a.keyCode) {
              q ? c(q.innerHTML) : f ? c(f) : l.close();
            } else {
              k && clearInterval(k);
              k = setTimeout(p, 10);
              return;
            }
          }
        }
      }
      a.preventDefault();
      a.stopPropagation();
    }));
    var u = d.active_canvas, x = u.canvas, v = x.getBoundingClientRect(), w = -20, D = -20;
    v && (w -= v.left, D -= v.top);
    a ? (l.style.left = a.pageX + w + "px", l.style.top = a.pageY + D + "px") : (l.style.left = 0.5 * x.width + w + "px", l.style.top = 0.5 * x.height + D + "px");
    x.parentNode.appendChild(l);
    t.focus();
    return l;
  };
  d.prototype.showEditPropertyValue = function(a, b, e) {
    function c() {
      g(q.value);
    }
    function g(c) {
      "number" == typeof a.properties[b] && (c = Number(c));
      "array" == d && (c = c.split(",").map(Number));
      a.properties[b] = c;
      a._graph && a._graph._version++;
      if (a.onPropertyChanged) {
        a.onPropertyChanged(b, c);
      }
      k.close();
      a.setDirtyCanvas(!0, !0);
    }
    if (a && void 0 !== a.properties[b]) {
      e = e || {};
      var d = "string";
      null !== a.properties[b] && (d = typeof a.properties[b]);
      "object" == d && a.properties[b].length && (d = "array");
      var p = null;
      a.getPropertyInfo && (p = a.getPropertyInfo(b));
      if (a.properties_info) {
        for (var m = 0; m < a.properties_info.length; ++m) {
          if (a.properties_info[m].name == b) {
            p = a.properties_info[m];
            break;
          }
        }
      }
      void 0 !== p && null !== p && p.type && (d = p.type);
      var h = "";
      if ("string" == d || "number" == d || "array" == d) {
        h = "<input autofocus type='text' class='value'/>";
      } else {
        if ("enum" == d && p.values) {
          h = "<select autofocus type='text' class='value'>";
          for (m in p.values) {
            var f = p.values.constructor === Array ? p.values[m] : m;
            h += "<option value='" + f + "' " + (f == a.properties[b] ? "selected" : "") + ">" + p.values[m] + "</option>";
          }
          h += "</select>";
        } else {
          if ("boolean" == d) {
            h = "<input autofocus type='checkbox' class='value' " + (a.properties[b] ? "checked" : "") + "/>";
          } else {
            console.warn("unknown type: " + d);
            return;
          }
        }
      }
      var k = this.createDialog("<span class='name'>" + b + "</span>" + h + "<button>OK</button>", e);
      if ("enum" == d && p.values) {
        var q = k.querySelector("select");
        q.addEventListener("change", function(a) {
          g(a.target.value);
        });
      } else {
        if ("boolean" == d) {
          (q = k.querySelector("input")) && q.addEventListener("click", function(a) {
            g(!!q.checked);
          });
        } else {
          if (q = k.querySelector("input")) {
            q.addEventListener("blur", function(a) {
              this.focus();
            }), q.value = void 0 !== a.properties[b] ? a.properties[b] : "", q.addEventListener("keydown", function(a) {
              13 == a.keyCode && (c(), a.preventDefault(), a.stopPropagation());
            });
          }
        }
      }
      k.querySelector("button").addEventListener("click", c);
    }
  };
  d.prototype.createDialog = function(a, b) {
    b = b || {};
    var c = document.createElement("div");
    c.className = "graphdialog";
    c.innerHTML = a;
    a = this.canvas.getBoundingClientRect();
    var d = -20, g = -20;
    a && (d -= a.left, g -= a.top);
    b.position ? (d += b.position[0], g += b.position[1]) : b.event ? (d += b.event.pageX, g += b.event.pageY) : (d += 0.5 * this.canvas.width, g += 0.5 * this.canvas.height);
    c.style.left = d + "px";
    c.style.top = g + "px";
    this.canvas.parentNode.appendChild(c);
    c.close = function() {
      this.parentNode && this.parentNode.removeChild(this);
    };
    return c;
  };
  d.onMenuNodeCollapse = function(a, b, e, d, g) {
    g.collapse();
  };
  d.onMenuNodePin = function(a, b, e, d, g) {
    g.pin();
  };
  d.onMenuNodeMode = function(a, b, e, d, g) {
    new h.ContextMenu(["Always", "On Event", "On Trigger", "Never"], {event:e, callback:function(a) {
      if (g) {
        switch(a) {
          case "On Event":
            g.mode = h.ON_EVENT;
            break;
          case "On Trigger":
            g.mode = h.ON_TRIGGER;
            break;
          case "Never":
            g.mode = h.NEVER;
            break;
          default:
            g.mode = h.ALWAYS;
        }
      }
    }, parentMenu:d, node:g});
    return !1;
  };
  d.onMenuNodeColors = function(a, b, e, p, g) {
    if (!g) {
      throw "no node for color";
    }
    b = [];
    b.push({value:null, content:"<span style='display: block; padding-left: 4px;'>No color</span>"});
    for (var c in d.node_colors) {
      a = d.node_colors[c], a = {value:c, content:"<span style='display: block; color: #999; padding-left: 4px; border-left: 8px solid " + a.color + "; background-color:" + a.bgcolor + "'>" + c + "</span>"}, b.push(a);
    }
    new h.ContextMenu(b, {event:e, callback:function(a) {
      g && ((a = a.value ? d.node_colors[a.value] : null) ? g.constructor === h.LGraphGroup ? g.color = a.groupcolor : (g.color = a.color, g.bgcolor = a.bgcolor) : (delete g.color, delete g.bgcolor), g.setDirtyCanvas(!0, !0));
    }, parentMenu:p, node:g});
    return !1;
  };
  d.onMenuNodeShapes = function(a, b, e, d, g) {
    if (!g) {
      throw "no node passed";
    }
    new h.ContextMenu(h.VALID_SHAPES, {event:e, callback:function(a) {
      g && (g.shape = a, g.setDirtyCanvas(!0));
    }, parentMenu:d, node:g});
    return !1;
  };
  d.onMenuNodeRemove = function(a, b, e, d, g) {
    if (!g) {
      throw "no node passed";
    }
    !1 !== g.removable && (g.graph.remove(g), g.setDirtyCanvas(!0, !0));
  };
  d.onMenuNodeClone = function(a, b, e, d, g) {
    0 != g.clonable && (a = g.clone()) && (a.pos = [g.pos[0] + 5, g.pos[1] + 5], g.graph.add(a), g.setDirtyCanvas(!0, !0));
  };
  d.node_colors = {red:{color:"#322", bgcolor:"#533", groupcolor:"#A88"}, brown:{color:"#332922", bgcolor:"#593930", groupcolor:"#b06634"}, green:{color:"#232", bgcolor:"#353", groupcolor:"#8A8"}, blue:{color:"#223", bgcolor:"#335", groupcolor:"#88A"}, pale_blue:{color:"#2a363b", bgcolor:"#3f5159", groupcolor:"#3f789e"}, cyan:{color:"#233", bgcolor:"#355", groupcolor:"#8AA"}, purple:{color:"#323", bgcolor:"#535", groupcolor:"#a1309b"}, yellow:{color:"#432", bgcolor:"#653", groupcolor:"#b58b2a"}, 
  black:{color:"#222", bgcolor:"#000", groupcolor:"#444"}};
  d.prototype.getCanvasMenuOptions = function() {
    if (this.getMenuOptions) {
      var a = this.getMenuOptions();
    } else {
      a = [{content:"Add Node", has_submenu:!0, callback:d.onMenuAdd}, {content:"Add Group", callback:d.onGroupAdd}], this._graph_stack && 0 < this._graph_stack.length && a.push(null, {content:"Close subgraph", callback:this.closeSubgraph.bind(this)});
    }
    if (this.getExtraMenuOptions) {
      var b = this.getExtraMenuOptions(this, a);
      b && (a = a.concat(b));
    }
    return a;
  };
  d.prototype.getNodeMenuOptions = function(a) {
    var b = a.getMenuOptions ? a.getMenuOptions(this) : [{content:"Inputs", has_submenu:!0, disabled:!0, callback:d.showMenuNodeOptionalInputs}, {content:"Outputs", has_submenu:!0, disabled:!0, callback:d.showMenuNodeOptionalOutputs}, null, {content:"Properties", has_submenu:!0, callback:d.onShowMenuNodeProperties}, null, {content:"Title", callback:d.onShowPropertyEditor}, {content:"Mode", has_submenu:!0, callback:d.onMenuNodeMode}, {content:"Resize", callback:d.onResizeNode}, {content:"Collapse", 
    callback:d.onMenuNodeCollapse}, {content:"Pin", callback:d.onMenuNodePin}, {content:"Colors", has_submenu:!0, callback:d.onMenuNodeColors}, {content:"Shapes", has_submenu:!0, callback:d.onMenuNodeShapes}, null];
    if (a.onGetInputs) {
      var e = a.onGetInputs();
      e && e.length && (b[0].disabled = !1);
    }
    a.onGetOutputs && (e = a.onGetOutputs()) && e.length && (b[1].disabled = !1);
    a.getExtraMenuOptions && (e = a.getExtraMenuOptions(this)) && (e.push(null), b = e.concat(b));
    !1 !== a.clonable && b.push({content:"Clone", callback:d.onMenuNodeClone});
    !1 !== a.removable && b.push(null, {content:"Remove", callback:d.onMenuNodeRemove});
    if (a.graph && a.graph.onGetNodeMenuOptions) {
      a.graph.onGetNodeMenuOptions(b, a);
    }
    return b;
  };
  d.prototype.getGroupMenuOptions = function(a) {
    return [{content:"Title", callback:d.onShowPropertyEditor}, {content:"Color", has_submenu:!0, callback:d.onMenuNodeColors}, {content:"Font size", property:"font_size", type:"Number", callback:d.onShowPropertyEditor}, null, {content:"Remove", callback:d.onMenuNodeRemove}];
  };
  d.prototype.processContextMenu = function(a, b) {
    var c = this, p = d.active_canvas.getCanvasWindow(), g = null, l = {event:b, callback:function(b, e, d) {
      if (b) {
        if ("Remove Slot" == b.content) {
          b = b.slot, b.input ? a.removeInput(b.slot) : b.output && a.removeOutput(b.slot);
        } else {
          if ("Disconnect Links" == b.content) {
            b = b.slot, b.output ? a.disconnectOutput(b.slot) : b.input && a.disconnectInput(b.slot);
          } else {
            if ("Rename Slot" == b.content) {
              b = b.slot;
              var g = b.input ? a.getInputInfo(b.slot) : a.getOutputInfo(b.slot), l = c.createDialog("<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>", e), m = l.querySelector("input");
              m && g && (m.value = g.label);
              l.querySelector("button").addEventListener("click", function(a) {
                m.value && (g && (g.label = m.value), c.setDirty(!0));
                l.close();
              });
            }
          }
        }
      }
    }, extra:a}, m = null;
    a && (m = a.getSlotInPosition(b.canvasX, b.canvasY), d.active_node = a);
    m ? (g = [], m && m.output && m.output.links && m.output.links.length && g.push({content:"Disconnect Links", slot:m}), g.push(m.locked ? "Cannot remove" : {content:"Remove Slot", slot:m}), g.push(m.nameLocked ? "Cannot rename" : {content:"Rename Slot", slot:m}), l.title = (m.input ? m.input.type : m.output.type) || "*", m.input && m.input.type == h.ACTION && (l.title = "Action"), m.output && m.output.type == h.EVENT && (l.title = "Event")) : a ? g = this.getNodeMenuOptions(a) : (g = this.getCanvasMenuOptions(), 
    (b = this.graph.getGroupOnPos(b.canvasX, b.canvasY)) && g.push(null, {content:"Edit Group", has_submenu:!0, submenu:{title:"Group", extra:b, options:this.getGroupMenuOptions(b)}}));
    g && new h.ContextMenu(g, l, p);
  };
  this.CanvasRenderingContext2D && (CanvasRenderingContext2D.prototype.roundRect = function(a, b, e, d, g, l) {
    void 0 === g && (g = 5);
    void 0 === l && (l = g);
    this.moveTo(a + g, b);
    this.lineTo(a + e - g, b);
    this.quadraticCurveTo(a + e, b, a + e, b + g);
    this.lineTo(a + e, b + d - l);
    this.quadraticCurveTo(a + e, b + d, a + e - l, b + d);
    this.lineTo(a + l, b + d);
    this.quadraticCurveTo(a, b + d, a, b + d - l);
    this.lineTo(a, b + g);
    this.quadraticCurveTo(a, b, a + g, b);
  });
  h.compareObjects = function(a, b) {
    for (var c in a) {
      if (a[c] != b[c]) {
        return !1;
      }
    }
    return !0;
  };
  h.distance = t;
  h.colorToString = function(a) {
    return "rgba(" + Math.round(255 * a[0]).toFixed() + "," + Math.round(255 * a[1]).toFixed() + "," + Math.round(255 * a[2]).toFixed() + "," + (4 == a.length ? a[3].toFixed(2) : "1.0") + ")";
  };
  h.isInsideRectangle = u;
  h.growBounding = function(a, b, e) {
    b < a[0] ? a[0] = b : b > a[2] && (a[2] = b);
    e < a[1] ? a[1] = e : e > a[3] && (a[3] = e);
  };
  h.isInsideBounding = function(a, b) {
    return a[0] < b[0][0] || a[1] < b[0][1] || a[0] > b[1][0] || a[1] > b[1][1] ? !1 : !0;
  };
  h.overlapBounding = x;
  h.hex2num = function(a) {
    "#" == a.charAt(0) && (a = a.slice(1));
    a = a.toUpperCase();
    for (var b = Array(3), e = 0, d, g, l = 0; 6 > l; l += 2) {
      d = "0123456789ABCDEF".indexOf(a.charAt(l)), g = "0123456789ABCDEF".indexOf(a.charAt(l + 1)), b[e] = 16 * d + g, e++;
    }
    return b;
  };
  h.num2hex = function(a) {
    for (var b = "#", e, d, g = 0; 3 > g; g++) {
      e = a[g] / 16, d = a[g] % 16, b += "0123456789ABCDEF".charAt(e) + "0123456789ABCDEF".charAt(d);
    }
    return b;
  };
  w.prototype.addItem = function(a, b, e) {
    function c(a) {
      var b = this.value;
      b && b.has_submenu && d.call(this, a);
    }
    function d(a) {
      var b = this.value, c = !0;
      l.current_submenu && l.current_submenu.close(a);
      if (e.callback) {
        var d = e.callback.call(this, b, e, a, l, e.node);
        !0 === d && (c = !1);
      }
      if (b && (b.callback && !e.ignore_item_callbacks && !0 !== b.disabled && (d = b.callback.call(this, b, e, a, l, e.extra), !0 === d && (c = !1)), b.submenu)) {
        if (!b.submenu.options) {
          throw "ContextMenu submenu needs options";
        }
        new l.constructor(b.submenu.options, {callback:b.submenu.callback, event:a, parentMenu:l, ignore_item_callbacks:b.submenu.ignore_item_callbacks, title:b.submenu.title, extra:b.submenu.extra, autoopen:e.autoopen});
        c = !1;
      }
      c && !l.lock && l.close();
    }
    var l = this;
    e = e || {};
    var m = document.createElement("div");
    m.className = "litemenu-entry submenu";
    var p = !1;
    if (null === b) {
      m.classList.add("separator");
    } else {
      m.innerHTML = b && b.title ? b.title : a;
      if (m.value = b) {
        b.disabled && (p = !0, m.classList.add("disabled")), (b.submenu || b.has_submenu) && m.classList.add("has_submenu");
      }
      "function" == typeof b ? (m.dataset.value = a, m.onclick_callback = b) : m.dataset.value = b;
      b.className && (m.className += " " + b.className);
    }
    this.root.appendChild(m);
    p || m.addEventListener("click", d);
    e.autoopen && m.addEventListener("mouseenter", c);
    return m;
  };
  w.prototype.close = function(a, b) {
    this.root.parentNode && this.root.parentNode.removeChild(this.root);
    this.parentMenu && !b && (this.parentMenu.lock = !1, this.parentMenu.current_submenu = null, void 0 === a ? this.parentMenu.close() : a && !w.isCursorOverElement(a, this.parentMenu.root) && w.trigger(this.parentMenu.root, "mouseleave", a));
    this.current_submenu && this.current_submenu.close(a, !0);
    this.root.closing_timer && clearTimeout(this.root.closing_timer);
  };
  w.trigger = function(a, b, e, d) {
    var c = document.createEvent("CustomEvent");
    c.initCustomEvent(b, !0, !0, e);
    c.srcElement = d;
    a.dispatchEvent ? a.dispatchEvent(c) : a.__events && a.__events.dispatchEvent(c);
    return c;
  };
  w.prototype.getTopMenu = function() {
    return this.options.parentMenu ? this.options.parentMenu.getTopMenu() : this;
  };
  w.prototype.getFirstEvent = function() {
    return this.options.parentMenu ? this.options.parentMenu.getFirstEvent() : this.options.event;
  };
  w.isCursorOverElement = function(a, b) {
    var c = a.pageX;
    a = a.pageY;
    return (b = b.getBoundingClientRect()) ? a > b.top && a < b.top + b.height && c > b.left && c < b.left + b.width ? !0 : !1 : !1;
  };
  h.ContextMenu = w;
  h.closeAllContextMenus = function(a) {
    a = a || window;
    a = a.document.querySelectorAll(".litecontextmenu");
    if (a.length) {
      for (var b = [], e = 0; e < a.length; e++) {
        b.push(a[e]);
      }
      for (e in b) {
        b[e].close ? b[e].close() : b[e].parentNode && b[e].parentNode.removeChild(b[e]);
      }
    }
  };
  h.extendClass = function(a, b) {
    for (var c in b) {
      a.hasOwnProperty(c) || (a[c] = b[c]);
    }
    if (b.prototype) {
      for (c in b.prototype) {
        b.prototype.hasOwnProperty(c) && !a.prototype.hasOwnProperty(c) && (b.prototype.__lookupGetter__(c) ? a.prototype.__defineGetter__(c, b.prototype.__lookupGetter__(c)) : a.prototype[c] = b.prototype[c], b.prototype.__lookupSetter__(c) && a.prototype.__defineSetter__(c, b.prototype.__lookupSetter__(c)));
      }
    }
  };
  h.getParameterNames = function(a) {
    return (a + "").replace(/[/][/].*$/mg, "").replace(/\s+/g, "").replace(/[/][*][^/*]*[*][/]/g, "").split("){", 1)[0].replace(/^[^(]*[(]/, "").replace(/=[^,]+/g, "").split(",").filter(Boolean);
  };
  Math.clamp = function(a, b, e) {
    return b > a ? b : e < a ? e : a;
  };
  "undefined" == typeof window || window.requestAnimationFrame || (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(a) {
    window.setTimeout(a, 1000 / 60);
  });
})(this);
"undefined" != typeof exports && (exports.LiteGraph = this.LiteGraph);
(function(v) {
  function f() {
    this.addOutput("in ms", "number");
    this.addOutput("in sec", "number");
  }
  function k() {
    this.size = [120, 80];
    this.subgraph = new LGraph;
    this.subgraph._subgraph_node = this;
    this.subgraph._is_subgraph = !0;
    this.subgraph.onGlobalInputAdded = this.onSubgraphNewGlobalInput.bind(this);
    this.subgraph.onGlobalInputRenamed = this.onSubgraphRenamedGlobalInput.bind(this);
    this.subgraph.onGlobalInputTypeChanged = this.onSubgraphTypeChangeGlobalInput.bind(this);
    this.subgraph.onGlobalOutputAdded = this.onSubgraphNewGlobalOutput.bind(this);
    this.subgraph.onGlobalOutputRenamed = this.onSubgraphRenamedGlobalOutput.bind(this);
    this.subgraph.onGlobalOutputTypeChanged = this.onSubgraphTypeChangeGlobalOutput.bind(this);
    this.color = "#335";
    this.bgcolor = "#557";
  }
  function q() {
    var b = "input_" + (1000 * Math.random()).toFixed();
    this.addOutput(b, null);
    this.properties = {name:b, type:null};
    var d = this;
    Object.defineProperty(this.properties, "name", {get:function() {
      return b;
    }, set:function(a) {
      if ("" != a) {
        var c = d.getOutputInfo(0);
        c.name != a && (c.name = a, d.graph && d.graph.renameGlobalInput(b, a), b = a);
      }
    }, enumerable:!0});
    Object.defineProperty(this.properties, "type", {get:function() {
      return d.outputs[0].type;
    }, set:function(a) {
      d.outputs[0].type = a;
      d.graph && d.graph.changeGlobalInputType(b, d.outputs[0].type);
    }, enumerable:!0});
  }
  function d() {
    var b = "output_" + (1000 * Math.random()).toFixed();
    this.addInput(b, null);
    this._value = null;
    this.properties = {name:b, type:null};
    var d = this;
    Object.defineProperty(this.properties, "name", {get:function() {
      return b;
    }, set:function(a) {
      if ("" != a) {
        var c = d.getInputInfo(0);
        c.name != a && (c.name = a, d.graph && d.graph.renameGlobalOutput(b, a), b = a);
      }
    }, enumerable:!0});
    Object.defineProperty(this.properties, "type", {get:function() {
      return d.inputs[0].type;
    }, set:function(a) {
      d.inputs[0].type = a;
      d.graph && d.graph.changeGlobalInputType(b, d.inputs[0].type);
    }, enumerable:!0});
  }
  function t() {
    this.addOutput("value", "number");
    this.addProperty("value", 1.0);
    this.editable = {property:"value", type:"number"};
  }
  function u() {
    this.size = [60, 20];
    this.addInput("value", 0, {label:""});
    this.value = 0;
  }
  function x() {
    this.addInput("in", 0);
    this.addOutput("out", 0);
    this.size = [40, 20];
  }
  function w() {
    this.mode = m.ON_EVENT;
    this.size = [60, 20];
    this.addProperty("msg", "");
    this.addInput("log", m.EVENT);
    this.addInput("msg", 0);
  }
  function h() {
    this.size = [60, 20];
    this.addProperty("onExecute", "");
    this.addInput("in", "");
    this.addInput("in2", "");
    this.addOutput("out", "");
    this.addOutput("out2", "");
    this._func = null;
  }
  var m = v.LiteGraph;
  f.title = "Time";
  f.desc = "Time";
  f.prototype.onExecute = function() {
    this.setOutputData(0, 1000 * this.graph.globaltime);
    this.setOutputData(1, this.graph.globaltime);
  };
  m.registerNodeType("basic/time", f);
  k.title = "Subgraph";
  k.desc = "Graph inside a node";
  k.prototype.onDrawTitle = function(b) {
    if (!this.flags.collapsed) {
      b.fillStyle = "#AAA";
      var d = m.NODE_TITLE_HEIGHT, a = this.size[0] - d;
      b.fillRect(a, -d, d, d);
      b.fillStyle = "#333";
      b.beginPath();
      b.moveTo(a + 0.2 * d, 0.6 * -d);
      b.lineTo(a + 0.8 * d, 0.6 * -d);
      b.lineTo(a + 0.5 * d, 0.3 * -d);
      b.fill();
    }
  };
  k.prototype.onDblClick = function(b, d, a) {
    var c = this;
    setTimeout(function() {
      a.openSubgraph(c.subgraph);
    }, 10);
  };
  k.prototype.onMouseDown = function(b, d, a) {
    if (!this.flags.collapsed && d[0] > this.size[0] - m.NODE_TITLE_HEIGHT && 0 > d[1]) {
      var c = this;
      setTimeout(function() {
        a.openSubgraph(c.subgraph);
      }, 10);
    }
  };
  k.prototype.onSubgraphNewGlobalInput = function(b, d) {
    this.addInput(b, d);
  };
  k.prototype.onSubgraphRenamedGlobalInput = function(b, d) {
    b = this.findInputSlot(b);
    -1 != b && (this.getInputInfo(b).name = d);
  };
  k.prototype.onSubgraphTypeChangeGlobalInput = function(b, d) {
    b = this.findInputSlot(b);
    -1 != b && (this.getInputInfo(b).type = d);
  };
  k.prototype.onSubgraphNewGlobalOutput = function(b, d) {
    this.addOutput(b, d);
  };
  k.prototype.onSubgraphRenamedGlobalOutput = function(b, d) {
    b = this.findOutputSlot(b);
    -1 != b && (this.getOutputInfo(b).name = d);
  };
  k.prototype.onSubgraphTypeChangeGlobalOutput = function(b, d) {
    b = this.findOutputSlot(b);
    -1 != b && (this.getOutputInfo(b).type = d);
  };
  k.prototype.getExtraMenuOptions = function(b) {
    var d = this;
    return [{content:"Open", callback:function() {
      b.openSubgraph(d.subgraph);
    }}];
  };
  k.prototype.onResize = function(b) {
    b[1] += 20;
  };
  k.prototype.onExecute = function() {
    if (this.inputs) {
      for (var b = 0; b < this.inputs.length; b++) {
        var d = this.inputs[b], a = this.getInputData(b);
        this.subgraph.setGlobalInputData(d.name, a);
      }
    }
    this.subgraph.runStep();
    if (this.outputs) {
      for (b = 0; b < this.outputs.length; b++) {
        a = this.subgraph.getGlobalOutputData(this.outputs[b].name), this.setOutputData(b, a);
      }
    }
  };
  k.prototype.configure = function(b) {
    LGraphNode.prototype.configure.call(this, b);
  };
  k.prototype.serialize = function() {
    var b = LGraphNode.prototype.serialize.call(this);
    b.subgraph = this.subgraph.serialize();
    return b;
  };
  k.prototype.clone = function() {
    var b = m.createNode(this.type), d = this.serialize();
    delete d.id;
    delete d.inputs;
    delete d.outputs;
    b.configure(d);
    return b;
  };
  m.registerNodeType("graph/subgraph", k);
  q.title = "Input";
  q.desc = "Input of the graph";
  q.prototype.onAdded = function() {
    this.graph.addGlobalInput(this.properties.name, this.properties.type);
  };
  q.prototype.onExecute = function() {
    var b = this.graph.global_inputs[this.properties.name];
    b && this.setOutputData(0, b.value);
  };
  m.registerNodeType("graph/input", q);
  d.title = "Output";
  d.desc = "Output of the graph";
  d.prototype.onAdded = function() {
    this.graph.addGlobalOutput(this.properties.name, this.properties.type);
  };
  d.prototype.getValue = function() {
    return this._value;
  };
  d.prototype.onExecute = function() {
    this._value = this.getInputData(0);
    this.graph.setGlobalOutputData(this.properties.name, this._value);
  };
  m.registerNodeType("graph/output", d);
  t.title = "Const";
  t.desc = "Constant value";
  t.prototype.setValue = function(b) {
    "string" == typeof b && (b = parseFloat(b));
    this.properties.value = b;
    this.setDirtyCanvas(!0);
  };
  t.prototype.onExecute = function() {
    this.setOutputData(0, parseFloat(this.properties.value));
  };
  t.prototype.onDrawBackground = function(b) {
    this.outputs[0].label = this.properties.value.toFixed(3);
  };
  m.registerNodeType("basic/const", t);
  u.title = "Watch";
  u.desc = "Show value of input";
  u.prototype.onExecute = function() {
    this.inputs[0] && (this.value = this.getInputData(0));
  };
  u.toString = function(b) {
    if (null == b) {
      return "null";
    }
    if (b.constructor === Number) {
      return b.toFixed(3);
    }
    if (b.constructor === Array) {
      for (var d = "[", a = 0; a < b.length; ++a) {
        d += u.toString(b[a]) + (a + 1 != b.length ? "," : "");
      }
      return d + "]";
    }
    return String(b);
  };
  u.prototype.onDrawBackground = function(b) {
    this.inputs[0].label = u.toString(this.value);
  };
  m.registerNodeType("basic/watch", u);
  x.title = "Pass";
  x.desc = "Allows to connect different types";
  x.prototype.onExecute = function() {
    this.setOutputData(0, this.getInputData(0));
  };
  m.registerNodeType("basic/pass", x);
  w.title = "Console";
  w.desc = "Show value inside the console";
  w.prototype.onAction = function(b, d) {
    "log" == b ? console.log(d) : "warn" == b ? console.warn(d) : "error" == b && console.error(d);
  };
  w.prototype.onExecute = function() {
    var b = this.getInputData(1);
    null !== b && (this.properties.msg = b);
    console.log(b);
  };
  w.prototype.onGetInputs = function() {
    return [["log", m.ACTION], ["warn", m.ACTION], ["error", m.ACTION]];
  };
  m.registerNodeType("basic/console", w);
  h.title = "Script";
  h.desc = "executes a code";
  h.widgets_info = {onExecute:{type:"code"}};
  h.prototype.onPropertyChanged = function(b, d) {
    if ("onExecute" == b && m.allow_scripts) {
      this._func = null;
      try {
        this._func = new Function(d);
      } catch (a) {
        console.error("Error parsing script"), console.error(a);
      }
    }
  };
  h.prototype.onExecute = function() {
    if (this._func) {
      try {
        this._func.call(this);
      } catch (b) {
        console.error("Error in script"), console.error(b);
      }
    }
  };
  m.registerNodeType("basic/script", h);
})(this);
(function(v) {
  function f() {
    this.size = [60, 20];
    this.addInput("event", t.ACTION);
  }
  function k() {
    this.size = [60, 20];
    this.addInput("event", t.ACTION);
    this.addOutput("event", t.EVENT);
    this.properties = {equal_to:"", has_property:"", property_equal_to:""};
  }
  function q() {
    this.size = [60, 20];
    this.addProperty("time", 1000);
    this.addInput("event", t.ACTION);
    this.addOutput("on_time", t.EVENT);
    this._pending = [];
  }
  function d() {
    this.addProperty("interval", 1000);
    this.addProperty("event", "tick");
    this.addOutput("on_tick", t.EVENT);
    this.time = 0;
    this.last_interval = 1000;
    this.triggered = !1;
  }
  var t = v.LiteGraph;
  f.title = "Log Event";
  f.desc = "Log event in console";
  f.prototype.onAction = function(d, f) {
    console.log(d, f);
  };
  t.registerNodeType("events/log", f);
  k.title = "Filter Event";
  k.desc = "Blocks events that do not match the filter";
  k.prototype.onAction = function(d, f) {
    if (null != f && (!this.properties.equal_to || this.properties.equal_to == f)) {
      if (this.properties.has_property && (d = f[this.properties.has_property], null == d || this.properties.property_equal_to && this.properties.property_equal_to != d)) {
        return;
      }
      this.triggerSlot(0, f);
    }
  };
  t.registerNodeType("events/filter", k);
  q.title = "Delay";
  q.desc = "Delays one event";
  q.prototype.onAction = function(d, f) {
    this._pending.push([this.properties.time, f]);
  };
  q.prototype.onExecute = function() {
    for (var d = 1000 * this.graph.elapsed_time, f = 0; f < this._pending.length; ++f) {
      var k = this._pending[f];
      k[0] -= d;
      0 < k[0] || (this._pending.splice(f, 1), --f, this.trigger(null, k[1]));
    }
  };
  q.prototype.onGetInputs = function() {
    return [["event", t.ACTION]];
  };
  t.registerNodeType("events/delay", q);
  d.title = "Timer";
  d.desc = "Sends an event every N milliseconds";
  d.prototype.onStart = function() {
    this.time = 0;
  };
  d.prototype.getTitle = function() {
    return "Timer: " + this.last_interval.toString() + "ms";
  };
  d.on_color = "#AAA";
  d.off_color = "#222";
  d.prototype.onDrawBackground = function() {
    this.boxcolor = this.triggered ? d.on_color : d.off_color;
    this.triggered = !1;
  };
  d.prototype.onExecute = function() {
    this.time += 1000 * this.graph.elapsed_time;
    this.last_interval = Math.max(1, this.getInputOrProperty("interval") | 0);
    this.time < this.last_interval || isNaN(this.last_interval) ? this.inputs && 1 < this.inputs.length && this.inputs[1] && this.setOutputData(1, !1) : (this.triggered = !0, this.time %= this.last_interval, this.trigger("on_tick", this.properties.event), this.inputs && 1 < this.inputs.length && this.inputs[1] && this.setOutputData(1, !0));
  };
  d.prototype.onGetInputs = function() {
    return [["interval", "number"]];
  };
  d.prototype.onGetOutputs = function() {
    return [["tick", "boolean"]];
  };
  t.registerNodeType("events/timer", d);
})(this);
(function(v) {
  function f() {
    this.addOutput("clicked", m.EVENT);
    this.addProperty("text", "");
    this.addProperty("font_size", 40);
    this.addProperty("message", "");
    this.size = [64, 84];
  }
  function k() {
    this.addInput("", "boolean");
    this.addInput("e", m.ACTION);
    this.addOutput("v", "boolean");
    this.addOutput("e", m.EVENT);
    this.properties = {font:"", value:!1};
    this.size = [124, 64];
  }
  function q() {
    this.addOutput("", "number");
    this.size = [74, 54];
    this.properties = {min:-1000, max:1000, value:1, step:1};
    this.old_y = -1;
    this._precision = this._remainder = 0;
    this.mouse_captured = !1;
  }
  function d() {
    this.addOutput("", "number");
    this.size = [64, 84];
    this.properties = {min:0, max:1, value:0.5, wcolor:"#7AF", size:50};
  }
  function t() {
    this.addOutput("", "number");
    this.properties = {value:0.5, min:0, max:1, text:"V"};
    var b = this;
    this.size = [80, 60];
    this.slider = this.addWidget("slider", "V", this.properties.value, function(d) {
      b.properties.value = d;
    }, this.properties);
  }
  function u() {
    this.size = [160, 26];
    this.addOutput("", "number");
    this.properties = {wcolor:"#7AF", min:0, max:1, value:0.5};
  }
  function x() {
    this.size = [160, 26];
    this.addInput("", "number");
    this.properties = {min:0, max:1, value:0, wcolor:"#AAF"};
  }
  function w() {
    this.addInputs("", 0);
    this.properties = {value:"...", font:"Arial", fontsize:18, color:"#AAA", align:"left", glowSize:0, decimals:1};
  }
  function h() {
    this.size = [200, 100];
    this.properties = {borderColor:"#ffffff", bgcolorTop:"#f0f0f0", bgcolorBottom:"#e0e0e0", shadowSize:2, borderRadius:3};
  }
  var m = v.LiteGraph;
  f.title = "Button";
  f.desc = "Triggers an event";
  f.font = "Arial";
  f.prototype.onDrawForeground = function(b) {
    if (!this.flags.collapsed && (b.fillStyle = "black", b.fillRect(1, 1, this.size[0] - 3, this.size[1] - 3), b.fillStyle = "#AAF", b.fillRect(0, 0, this.size[0] - 3, this.size[1] - 3), b.fillStyle = this.clicked ? "white" : this.mouseOver ? "#668" : "#334", b.fillRect(1, 1, this.size[0] - 4, this.size[1] - 4), this.properties.text || 0 === this.properties.text)) {
      var d = this.properties.font_size || 30;
      b.textAlign = "center";
      b.fillStyle = this.clicked ? "black" : "white";
      b.font = d + "px " + f.font;
      b.fillText(this.properties.text, 0.5 * this.size[0], 0.5 * this.size[1] + 0.3 * d);
      b.textAlign = "left";
    }
  };
  f.prototype.onMouseDown = function(b, d) {
    if (1 < d[0] && 1 < d[1] && d[0] < this.size[0] - 2 && d[1] < this.size[1] - 2) {
      return this.clicked = !0, this.trigger("clicked", this.properties.message), !0;
    }
  };
  f.prototype.onMouseUp = function(b) {
    this.clicked = !1;
  };
  m.registerNodeType("widget/button", f);
  k.title = "Toggle";
  k.desc = "Toggles between true or false";
  k.prototype.onDrawForeground = function(b) {
    if (!this.flags.collapsed) {
      var d = 0.5 * this.size[1], a = 0.8 * this.size[1];
      b.fillStyle = "#AAA";
      b.fillRect(10, a - d, d, d);
      b.fillStyle = this.properties.value ? "#AEF" : "#000";
      b.fillRect(10 + 0.25 * d, a - d + 0.25 * d, .5 * d, .5 * d);
      b.textAlign = "left";
      b.font = this.properties.font || (0.8 * d).toFixed(0) + "px Arial";
      b.fillStyle = "#AAA";
      b.fillText(this.title, d + 20, 0.85 * a);
      b.textAlign = "left";
    }
  };
  k.prototype.onAction = function(b) {
    this.properties.value = !this.properties.value;
    this.trigger("e", this.properties.value);
  };
  k.prototype.onExecute = function() {
    var b = this.getInputData(0);
    null != b && (this.properties.value = b);
    this.setOutputData(0, this.properties.value);
  };
  k.prototype.onMouseDown = function(b, d) {
    if (1 < d[0] && 1 < d[1] && d[0] < this.size[0] - 2 && d[1] < this.size[1] - 2) {
      return this.properties.value = !this.properties.value, this.graph._version++, this.trigger("e", this.properties.value), !0;
    }
  };
  m.registerNodeType("widget/toggle", k);
  q.title = "Number";
  q.desc = "Widget to select number value";
  q.pixels_threshold = 10;
  q.markers_color = "#666";
  q.prototype.onDrawForeground = function(b) {
    var d = 0.5 * this.size[0], a = this.size[1];
    30 < a ? (b.fillStyle = q.markers_color, b.beginPath(), b.moveTo(d, 0.1 * a), b.lineTo(d + 0.1 * a, 0.2 * a), b.lineTo(d + -0.1 * a, 0.2 * a), b.fill(), b.beginPath(), b.moveTo(d, 0.9 * a), b.lineTo(d + 0.1 * a, 0.8 * a), b.lineTo(d + -0.1 * a, 0.8 * a), b.fill(), b.font = (0.7 * a).toFixed(1) + "px Arial") : b.font = (0.8 * a).toFixed(1) + "px Arial";
    b.textAlign = "center";
    b.font = (0.7 * a).toFixed(1) + "px Arial";
    b.fillStyle = "#EEE";
    b.fillText(this.properties.value.toFixed(this._precision), d, 0.75 * a);
  };
  q.prototype.onExecute = function() {
    this.setOutputData(0, this.properties.value);
  };
  q.prototype.onPropertyChanged = function(b, d) {
    b = (this.properties.step + "").split(".");
    this._precision = 1 < b.length ? b[1].length : 0;
  };
  q.prototype.onMouseDown = function(b, d) {
    if (!(0 > d[1])) {
      return this.old_y = b.canvasY, this.captureInput(!0), this.mouse_captured = !0;
    }
  };
  q.prototype.onMouseMove = function(b) {
    if (this.mouse_captured) {
      var d = this.old_y - b.canvasY;
      b.shiftKey && (d *= 10);
      if (b.metaKey || b.altKey) {
        d *= 0.1;
      }
      this.old_y = b.canvasY;
      b = this._remainder + d / q.pixels_threshold;
      this._remainder = b % 1;
      b = Math.clamp(this.properties.value + (b | 0) * this.properties.step, this.properties.min, this.properties.max);
      this.properties.value = b;
      this.graph._version++;
      this.setDirtyCanvas(!0);
    }
  };
  q.prototype.onMouseUp = function(b, d) {
    200 > b.click_time && (this.properties.value = Math.clamp(this.properties.value + (d[1] > 0.5 * this.size[1] ? -1 : 1) * this.properties.step, this.properties.min, this.properties.max), this.graph._version++, this.setDirtyCanvas(!0));
    this.mouse_captured && (this.mouse_captured = !1, this.captureInput(!1));
  };
  m.registerNodeType("widget/number", q);
  d.title = "Knob";
  d.desc = "Circular controller";
  d.widgets = [{name:"increase", text:"+", type:"minibutton"}, {name:"decrease", text:"-", type:"minibutton"}];
  d.prototype.onAdded = function() {
    this.value = (this.properties.value - this.properties.min) / (this.properties.max - this.properties.min);
    this.imgbg = this.loadImage("imgs/knob_bg.png");
    this.imgfg = this.loadImage("imgs/knob_fg.png");
  };
  d.prototype.onDrawImageKnob = function(b) {
    if (this.imgfg && this.imgfg.width) {
      var d = 0.5 * this.imgbg.width, a = this.size[0] / this.imgfg.width;
      b.save();
      b.translate(0, 20);
      b.scale(a, a);
      b.drawImage(this.imgbg, 0, 0);
      b.translate(d, d);
      b.rotate(2 * this.value * Math.PI * 6 / 8 + 10 * Math.PI / 8);
      b.translate(-d, -d);
      b.drawImage(this.imgfg, 0, 0);
      b.restore();
      this.title && (b.font = "bold 16px Criticized,Tahoma", b.fillStyle = "rgba(100,100,100,0.8)", b.textAlign = "center", b.fillText(this.title.toUpperCase(), 0.5 * this.size[0], 18), b.textAlign = "left");
    }
  };
  d.prototype.onDrawVectorKnob = function(b) {
    if (this.imgfg && this.imgfg.width) {
      b.lineWidth = 1;
      b.strokeStyle = this.mouseOver ? "#FFF" : "#AAA";
      b.fillStyle = "#000";
      b.beginPath();
      b.arc(0.5 * this.size[0], 0.5 * this.size[1] + 10, 0.5 * this.properties.size, 0, 2 * Math.PI, !0);
      b.stroke();
      0 < this.value && (b.strokeStyle = this.properties.wcolor, b.lineWidth = 0.2 * this.properties.size, b.beginPath(), b.arc(0.5 * this.size[0], 0.5 * this.size[1] + 10, 0.35 * this.properties.size, -0.5 * Math.PI + 2 * Math.PI * this.value, -0.5 * Math.PI, !0), b.stroke(), b.lineWidth = 1);
      b.font = 0.2 * this.properties.size + "px Arial";
      b.fillStyle = "#AAA";
      b.textAlign = "center";
      var d = this.properties.value;
      "number" == typeof d && (d = d.toFixed(2));
      b.fillText(d, 0.5 * this.size[0], 0.65 * this.size[1]);
      b.textAlign = "left";
    }
  };
  d.prototype.onDrawForeground = function(b) {
    this.onDrawImageKnob(b);
  };
  d.prototype.onExecute = function() {
    this.setOutputData(0, this.properties.value);
    this.boxcolor = m.colorToString([this.value, this.value, this.value]);
  };
  d.prototype.onMouseDown = function(b) {
    if (this.imgfg && this.imgfg.width) {
      this.center = [0.5 * this.size[0], 0.5 * this.size[1] + 20];
      this.radius = 0.5 * this.size[0];
      if (20 > b.canvasY - this.pos[1] || m.distance([b.canvasX, b.canvasY], [this.pos[0] + this.center[0], this.pos[1] + this.center[1]]) > this.radius) {
        return !1;
      }
      this.oldmouse = [b.canvasX - this.pos[0], b.canvasY - this.pos[1]];
      this.captureInput(!0);
      return !0;
    }
  };
  d.prototype.onMouseMove = function(b) {
    if (this.oldmouse) {
      b = [b.canvasX - this.pos[0], b.canvasY - this.pos[1]];
      var d = this.value;
      d -= 0.01 * (b[1] - this.oldmouse[1]);
      1.0 < d ? d = 1.0 : 0.0 > d && (d = 0.0);
      this.value = d;
      this.properties.value = this.properties.min + (this.properties.max - this.properties.min) * this.value;
      this.oldmouse = b;
      this.setDirtyCanvas(!0);
    }
  };
  d.prototype.onMouseUp = function(b) {
    this.oldmouse && (this.oldmouse = null, this.captureInput(!1));
  };
  d.prototype.onMouseLeave = function(b) {
  };
  d.prototype.onPropertyChanged = function(b, d) {
    if ("wcolor" == b) {
      this.properties[b] = d;
    } else {
      if ("size" == b) {
        d = parseInt(d), this.properties[b] = d, this.size = [d + 4, d + 24], this.setDirtyCanvas(!0, !0);
      } else {
        if ("min" == b || "max" == b || "value" == b) {
          this.properties[b] = parseFloat(d);
        } else {
          return !1;
        }
      }
    }
    return !0;
  };
  m.registerNodeType("widget/knob", d);
  t.title = "Internal Slider";
  t.prototype.onPropertyChanged = function(b, d) {
    "value" == b && (this.slider.value = d);
  };
  t.prototype.onExecute = function() {
    this.setOutputData(0, this.properties.value);
  };
  m.registerNodeType("widget/internal_slider", t);
  u.title = "H.Slider";
  u.desc = "Linear slider controller";
  u.prototype.onAdded = function() {
    this.value = 0.5;
    this.imgfg = this.loadImage("imgs/slider_fg.png");
  };
  u.prototype.onDrawVectorial = function(b) {
    this.imgfg && this.imgfg.width && (b.lineWidth = 1, b.strokeStyle = this.mouseOver ? "#FFF" : "#AAA", b.fillStyle = "#000", b.beginPath(), b.rect(2, 0, this.size[0] - 4, 20), b.stroke(), b.fillStyle = this.properties.wcolor, b.beginPath(), b.rect(2 + (this.size[0] - 4 - 20) * this.value, 0, 20, 20), b.fill());
  };
  u.prototype.onDrawImage = function(b) {
    this.imgfg && this.imgfg.width && (b.lineWidth = 1, b.fillStyle = "#000", b.fillRect(2, 9, this.size[0] - 4, 2), b.strokeStyle = "#333", b.beginPath(), b.moveTo(2, 9), b.lineTo(this.size[0] - 4, 9), b.stroke(), b.strokeStyle = "#AAA", b.beginPath(), b.moveTo(2, 11), b.lineTo(this.size[0] - 4, 11), b.stroke(), b.drawImage(this.imgfg, 2 + (this.size[0] - 4) * this.value - 0.5 * this.imgfg.width, 0.5 * -this.imgfg.height + 10));
  };
  u.prototype.onDrawForeground = function(b) {
    this.onDrawImage(b);
  };
  u.prototype.onExecute = function() {
    this.properties.value = this.properties.min + (this.properties.max - this.properties.min) * this.value;
    this.setOutputData(0, this.properties.value);
    this.boxcolor = m.colorToString([this.value, this.value, this.value]);
  };
  u.prototype.onMouseDown = function(b) {
    if (0 > b.canvasY - this.pos[1]) {
      return !1;
    }
    this.oldmouse = [b.canvasX - this.pos[0], b.canvasY - this.pos[1]];
    this.captureInput(!0);
    return !0;
  };
  u.prototype.onMouseMove = function(b) {
    if (this.oldmouse) {
      b = [b.canvasX - this.pos[0], b.canvasY - this.pos[1]];
      var d = this.value;
      d += (b[0] - this.oldmouse[0]) / this.size[0];
      1.0 < d ? d = 1.0 : 0.0 > d && (d = 0.0);
      this.value = d;
      this.oldmouse = b;
      this.setDirtyCanvas(!0);
    }
  };
  u.prototype.onMouseUp = function(b) {
    this.oldmouse = null;
    this.captureInput(!1);
  };
  u.prototype.onMouseLeave = function(b) {
  };
  u.prototype.onPropertyChanged = function(b, d) {
    if ("wcolor" == b) {
      this.properties[b] = d;
    } else {
      return !1;
    }
    return !0;
  };
  m.registerNodeType("widget/hslider", u);
  x.title = "Progress";
  x.desc = "Shows data in linear progress";
  x.prototype.onExecute = function() {
    var b = this.getInputData(0);
    void 0 != b && (this.properties.value = b);
  };
  x.prototype.onDrawForeground = function(b) {
    b.lineWidth = 1;
    b.fillStyle = this.properties.wcolor;
    var d = (this.properties.value - this.properties.min) / (this.properties.max - this.properties.min);
    d = Math.min(1, d);
    d = Math.max(0, d);
    b.fillRect(2, 2, (this.size[0] - 4) * d, this.size[1] - 4);
  };
  m.registerNodeType("widget/progress", x);
  w.title = "Text";
  w.desc = "Shows the input value";
  w.widgets = [{name:"resize", text:"Resize box", type:"button"}, {name:"led_text", text:"LED", type:"minibutton"}, {name:"normal_text", text:"Normal", type:"minibutton"}];
  w.prototype.onDrawForeground = function(b) {
    b.fillStyle = this.properties.color;
    var d = this.properties.value;
    this.properties.glowSize ? (b.shadowColor = this.properties.color, b.shadowOffsetX = 0, b.shadowOffsetY = 0, b.shadowBlur = this.properties.glowSize) : b.shadowColor = "transparent";
    var a = this.properties.fontsize;
    b.textAlign = this.properties.align;
    b.font = a.toString() + "px " + this.properties.font;
    this.str = "number" == typeof d ? d.toFixed(this.properties.decimals) : d;
    if ("string" == typeof this.str) {
      d = this.str.split("\\n");
      for (var c in d) {
        b.fillText(d[c], "left" == this.properties.align ? 15 : this.size[0] - 15, -0.15 * a + a * (parseInt(c) + 1));
      }
    }
    b.shadowColor = "transparent";
    this.last_ctx = b;
    b.textAlign = "left";
  };
  w.prototype.onExecute = function() {
    var b = this.getInputData(0);
    null != b && (this.properties.value = b);
  };
  w.prototype.resize = function() {
    if (this.last_ctx) {
      var b = this.str.split("\\n");
      this.last_ctx.font = this.properties.fontsize + "px " + this.properties.font;
      var d = 0, a;
      for (a in b) {
        var c = this.last_ctx.measureText(b[a]).width;
        d < c && (d = c);
      }
      this.size[0] = d + 20;
      this.size[1] = 4 + b.length * this.properties.fontsize;
      this.setDirtyCanvas(!0);
    }
  };
  w.prototype.onPropertyChanged = function(b, d) {
    this.properties[b] = d;
    this.str = "number" == typeof d ? d.toFixed(3) : d;
    return !0;
  };
  m.registerNodeType("widget/text", w);
  h.title = "Panel";
  h.desc = "Non interactive panel";
  h.widgets = [{name:"update", text:"Update", type:"button"}];
  h.prototype.createGradient = function(b) {
    "" == this.properties.bgcolorTop || "" == this.properties.bgcolorBottom ? this.lineargradient = 0 : (this.lineargradient = b.createLinearGradient(0, 0, 0, this.size[1]), this.lineargradient.addColorStop(0, this.properties.bgcolorTop), this.lineargradient.addColorStop(1, this.properties.bgcolorBottom));
  };
  h.prototype.onDrawForeground = function(b) {
    null == this.lineargradient && this.createGradient(b);
    this.lineargradient && (b.lineWidth = 1, b.strokeStyle = this.properties.borderColor, b.fillStyle = this.lineargradient, this.properties.shadowSize ? (b.shadowColor = "#000", b.shadowOffsetX = 0, b.shadowOffsetY = 0, b.shadowBlur = this.properties.shadowSize) : b.shadowColor = "transparent", b.roundRect(0, 0, this.size[0] - 1, this.size[1] - 1, this.properties.shadowSize), b.fill(), b.shadowColor = "transparent", b.stroke());
  };
  m.registerNodeType("widget/panel", h);
})(this);
(function(v) {
  function f() {
    this.addOutput("left_x_axis", "number");
    this.addOutput("left_y_axis", "number");
    this.addOutput("button_pressed", k.EVENT);
    this.properties = {gamepad_index:0, threshold:0.1};
    this._left_axis = new Float32Array(2);
    this._right_axis = new Float32Array(2);
    this._triggers = new Float32Array(2);
    this._previous_buttons = new Uint8Array(17);
    this._current_buttons = new Uint8Array(17);
  }
  var k = v.LiteGraph;
  f.title = "Gamepad";
  f.desc = "gets the input of the gamepad";
  f.zero = new Float32Array(2);
  f.buttons = "a b x y lb rb lt rt back start ls rs home".split(" ");
  f.prototype.onExecute = function() {
    var k = this.getGamepad(), d = this.properties.threshold || 0.0;
    k && (this._left_axis[0] = Math.abs(k.xbox.axes.lx) > d ? k.xbox.axes.lx : 0, this._left_axis[1] = Math.abs(k.xbox.axes.ly) > d ? k.xbox.axes.ly : 0, this._right_axis[0] = Math.abs(k.xbox.axes.rx) > d ? k.xbox.axes.rx : 0, this._right_axis[1] = Math.abs(k.xbox.axes.ry) > d ? k.xbox.axes.ry : 0, this._triggers[0] = Math.abs(k.xbox.axes.ltrigger) > d ? k.xbox.axes.ltrigger : 0, this._triggers[1] = Math.abs(k.xbox.axes.rtrigger) > d ? k.xbox.axes.rtrigger : 0);
    if (this.outputs) {
      for (d = 0; d < this.outputs.length; d++) {
        var t = this.outputs[d];
        if (t.links && t.links.length) {
          var u = null;
          if (k) {
            switch(t.name) {
              case "left_axis":
                u = this._left_axis;
                break;
              case "right_axis":
                u = this._right_axis;
                break;
              case "left_x_axis":
                u = this._left_axis[0];
                break;
              case "left_y_axis":
                u = this._left_axis[1];
                break;
              case "right_x_axis":
                u = this._right_axis[0];
                break;
              case "right_y_axis":
                u = this._right_axis[1];
                break;
              case "trigger_left":
                u = this._triggers[0];
                break;
              case "trigger_right":
                u = this._triggers[1];
                break;
              case "a_button":
                u = k.xbox.buttons.a ? 1 : 0;
                break;
              case "b_button":
                u = k.xbox.buttons.b ? 1 : 0;
                break;
              case "x_button":
                u = k.xbox.buttons.x ? 1 : 0;
                break;
              case "y_button":
                u = k.xbox.buttons.y ? 1 : 0;
                break;
              case "lb_button":
                u = k.xbox.buttons.lb ? 1 : 0;
                break;
              case "rb_button":
                u = k.xbox.buttons.rb ? 1 : 0;
                break;
              case "ls_button":
                u = k.xbox.buttons.ls ? 1 : 0;
                break;
              case "rs_button":
                u = k.xbox.buttons.rs ? 1 : 0;
                break;
              case "start_button":
                u = k.xbox.buttons.start ? 1 : 0;
                break;
              case "back_button":
                u = k.xbox.buttons.back ? 1 : 0;
                break;
              case "button_pressed":
                for (t = 0; t < this._current_buttons.length; ++t) {
                  this._current_buttons[t] && !this._previous_buttons[t] && this.triggerSlot(d, f.buttons[t]);
                }
            }
          } else {
            switch(t.name) {
              case "button_pressed":
                break;
              case "left_axis":
              case "right_axis":
                u = f.zero;
                break;
              default:
                u = 0;
            }
          }
          this.setOutputData(d, u);
        }
      }
    }
  };
  f.prototype.getGamepad = function() {
    var f = navigator.getGamepads || navigator.webkitGetGamepads || navigator.mozGetGamepads;
    if (!f) {
      return null;
    }
    f = f.call(navigator);
    this._previous_buttons.set(this._current_buttons);
    for (var d = this.properties.gamepad_index; 4 > d; d++) {
      if (f[d]) {
        f = f[d];
        d = this.xbox_mapping;
        d || (d = this.xbox_mapping = {axes:[], buttons:{}, hat:""});
        d.axes.lx = f.axes[0];
        d.axes.ly = f.axes[1];
        d.axes.rx = f.axes[2];
        d.axes.ry = f.axes[3];
        d.axes.ltrigger = f.buttons[6].value;
        d.axes.rtrigger = f.buttons[7].value;
        for (var k = 0; k < f.buttons.length; k++) {
          switch(this._current_buttons[k] = f.buttons[k].pressed, k) {
            case 0:
              d.buttons.a = f.buttons[k].pressed;
              break;
            case 1:
              d.buttons.b = f.buttons[k].pressed;
              break;
            case 2:
              d.buttons.x = f.buttons[k].pressed;
              break;
            case 3:
              d.buttons.y = f.buttons[k].pressed;
              break;
            case 4:
              d.buttons.lb = f.buttons[k].pressed;
              break;
            case 5:
              d.buttons.rb = f.buttons[k].pressed;
              break;
            case 6:
              d.buttons.lt = f.buttons[k].pressed;
              break;
            case 7:
              d.buttons.rt = f.buttons[k].pressed;
              break;
            case 8:
              d.buttons.back = f.buttons[k].pressed;
              break;
            case 9:
              d.buttons.start = f.buttons[k].pressed;
              break;
            case 10:
              d.buttons.ls = f.buttons[k].pressed;
              break;
            case 11:
              d.buttons.rs = f.buttons[k].pressed;
              break;
            case 12:
              f.buttons[k].pressed && (d.hat += "up");
              break;
            case 13:
              f.buttons[k].pressed && (d.hat += "down");
              break;
            case 14:
              f.buttons[k].pressed && (d.hat += "left");
              break;
            case 15:
              f.buttons[k].pressed && (d.hat += "right");
              break;
            case 16:
              d.buttons.home = f.buttons[k].pressed;
          }
        }
        f.xbox = d;
        return f;
      }
    }
  };
  f.prototype.onDrawBackground = function(f) {
    if (!this.flags.collapsed) {
      var d = this._left_axis, k = this._right_axis;
      f.strokeStyle = "#88A";
      f.strokeRect(0.5 * (d[0] + 1) * this.size[0] - 4, 0.5 * (d[1] + 1) * this.size[1] - 4, 8, 8);
      f.strokeStyle = "#8A8";
      f.strokeRect(0.5 * (k[0] + 1) * this.size[0] - 4, 0.5 * (k[1] + 1) * this.size[1] - 4, 8, 8);
      d = this.size[1] / this._current_buttons.length;
      f.fillStyle = "#AEB";
      for (k = 0; k < this._current_buttons.length; ++k) {
        this._current_buttons[k] && f.fillRect(0, d * k, 6, d);
      }
    }
  };
  f.prototype.onGetOutputs = function() {
    return [["left_axis", "vec2"], ["right_axis", "vec2"], ["left_x_axis", "number"], ["left_y_axis", "number"], ["right_x_axis", "number"], ["right_y_axis", "number"], ["trigger_left", "number"], ["trigger_right", "number"], ["a_button", "number"], ["b_button", "number"], ["x_button", "number"], ["y_button", "number"], ["lb_button", "number"], ["rb_button", "number"], ["ls_button", "number"], ["rs_button", "number"], ["start", "number"], ["back", "number"], ["button_pressed", k.EVENT]];
  };
  k.registerNodeType("input/gamepad", f);
})(this);
(function(v) {
  function f() {
    this.addInput("in", "*");
    this.size = [60, 20];
  }
  function k() {
    this.addInput("in");
    this.addOutput("out");
    this.size = [60, 20];
  }
  function q() {
    this.addInput("in", "number", {locked:!0});
    this.addOutput("out", "number", {locked:!0});
    this.addProperty("in", 0);
    this.addProperty("in_min", 0);
    this.addProperty("in_max", 1);
    this.addProperty("out_min", 0);
    this.addProperty("out_max", 1);
    this.size = [80, 20];
  }
  function d() {
    this.addOutput("value", "number");
    this.addProperty("min", 0);
    this.addProperty("max", 1);
    this.size = [60, 20];
  }
  function t() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [60, 20];
    this.addProperty("min", 0);
    this.addProperty("max", 1);
  }
  function u() {
    this.properties = {f:0.5};
    this.addInput("A", "number");
    this.addInput("B", "number");
    this.addOutput("out", "number");
  }
  function x() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [60, 20];
  }
  function w() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [60, 20];
  }
  function h() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [60, 20];
  }
  function m() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [60, 20];
    this.properties = {A:0, B:1};
  }
  function b() {
    this.addInput("in", "number", {label:""});
    this.addOutput("out", "number", {label:""});
    this.size = [60, 20];
    this.addProperty("factor", 1);
  }
  function p() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [60, 20];
    this.addProperty("samples", 10);
    this._values = new Float32Array(10);
    this._current = 0;
  }
  function a() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.addProperty("factor", 0.1);
    this.size = [60, 20];
    this._value = null;
  }
  function c() {
    this.addInput("A", "number");
    this.addInput("B", "number");
    this.addOutput("=", "number");
    this.addProperty("A", 1);
    this.addProperty("B", 1);
    this.addProperty("OP", "+", "enum", {values:c.values});
  }
  function e() {
    this.addInput("A", "number");
    this.addInput("B", "number");
    this.addOutput("A==B", "boolean");
    this.addOutput("A!=B", "boolean");
    this.addProperty("A", 0);
    this.addProperty("B", 0);
  }
  function z() {
    this.addInput("A", "number");
    this.addInput("B", "number");
    this.addOutput("out", "boolean");
    this.addProperty("A", 1);
    this.addProperty("B", 1);
    this.addProperty("OP", ">", "string", {values:z.values});
    this.size = [60, 40];
  }
  function g() {
    this.addInput("inc", "number");
    this.addOutput("total", "number");
    this.addProperty("increment", 1);
    this.addProperty("value", 0);
  }
  function l() {
    this.addInput("v", "number");
    this.addOutput("sin", "number");
    this.addProperty("amplitude", 1);
    this.addProperty("offset", 0);
    this.bgImageUrl = "nodes/imgs/icon-sin.png";
  }
  function n() {
    this.addInput("x", "number");
    this.addInput("y", "number");
    this.addOutput("", "number");
    this.properties = {x:1.0, y:1.0, formula:"x+y"};
    this.addWidget("toggle", "allow", y.allow_scripts, function(a) {
      y.allow_scripts = a;
    });
    this._func = null;
  }
  function A() {
    this.addInput("vec2", "vec2");
    this.addOutput("x", "number");
    this.addOutput("y", "number");
  }
  function G() {
    this.addInputs([["x", "number"], ["y", "number"]]);
    this.addOutput("vec2", "vec2");
    this.properties = {x:0, y:0};
    this._data = new Float32Array(2);
  }
  function E() {
    this.addInput("vec3", "vec3");
    this.addOutput("x", "number");
    this.addOutput("y", "number");
    this.addOutput("z", "number");
  }
  function F() {
    this.addInputs([["x", "number"], ["y", "number"], ["z", "number"]]);
    this.addOutput("vec3", "vec3");
    this.properties = {x:0, y:0, z:0};
    this._data = new Float32Array(3);
  }
  function J() {
    this.addInput("vec4", "vec4");
    this.addOutput("x", "number");
    this.addOutput("y", "number");
    this.addOutput("z", "number");
    this.addOutput("w", "number");
  }
  function B() {
    this.addInputs([["x", "number"], ["y", "number"], ["z", "number"], ["w", "number"]]);
    this.addOutput("vec4", "vec4");
    this.properties = {x:0, y:0, z:0, w:0};
    this._data = new Float32Array(4);
  }
  var y = v.LiteGraph;
  f.title = "Converter";
  f.desc = "type A to type B";
  f.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (null != a && this.outputs) {
      for (var b = 0; b < this.outputs.length; b++) {
        var c = this.outputs[b];
        if (c.links && c.links.length) {
          var d = null;
          switch(c.name) {
            case "number":
              d = a.length ? a[0] : parseFloat(a);
              break;
            case "vec2":
            case "vec3":
            case "vec4":
              d = 1;
              switch(c.name) {
                case "vec2":
                  d = 2;
                  break;
                case "vec3":
                  d = 3;
                  break;
                case "vec4":
                  d = 4;
              }d = new Float32Array(d);
              if (a.length) {
                for (c = 0; c < a.length && c < d.length; c++) {
                  d[c] = a[c];
                }
              } else {
                d[0] = parseFloat(a);
              }
          }
          this.setOutputData(b, d);
        }
      }
    }
  };
  f.prototype.onGetOutputs = function() {
    return [["number", "number"], ["vec2", "vec2"], ["vec3", "vec3"], ["vec4", "vec4"]];
  };
  y.registerNodeType("math/converter", f);
  k.title = "Bypass";
  k.desc = "removes the type";
  k.prototype.onExecute = function() {
    var a = this.getInputData(0);
    this.setOutputData(0, a);
  };
  y.registerNodeType("math/bypass", k);
  q.title = "Range";
  q.desc = "Convert a number from one range to another";
  q.prototype.getTitle = function() {
    return this.flags.collapsed ? (this._last_v || 0).toFixed(2) : this.title;
  };
  q.prototype.onExecute = function() {
    if (this.inputs) {
      for (var a = 0; a < this.inputs.length; a++) {
        var b = this.inputs[a], c = this.getInputData(a);
        void 0 !== c && (this.properties[b.name] = c);
      }
    }
    c = this.properties["in"];
    if (void 0 === c || null === c || c.constructor !== Number) {
      c = 0;
    }
    a = this.properties.in_min;
    b = this.properties.out_min;
    this._last_v = (c - a) / (this.properties.in_max - a) * (this.properties.out_max - b) + b;
    this.setOutputData(0, this._last_v);
  };
  q.prototype.onDrawBackground = function(a) {
    this.outputs[0].label = this._last_v ? this._last_v.toFixed(3) : "?";
  };
  q.prototype.onGetInputs = function() {
    return [["in_min", "number"], ["in_max", "number"], ["out_min", "number"], ["out_max", "number"]];
  };
  y.registerNodeType("math/range", q);
  d.title = "Rand";
  d.desc = "Random number";
  d.prototype.onExecute = function() {
    if (this.inputs) {
      for (var a = 0; a < this.inputs.length; a++) {
        var b = this.inputs[a], c = this.getInputData(a);
        void 0 !== c && (this.properties[b.name] = c);
      }
    }
    a = this.properties.min;
    this._last_v = Math.random() * (this.properties.max - a) + a;
    this.setOutputData(0, this._last_v);
  };
  d.prototype.onDrawBackground = function(a) {
    this.outputs[0].label = this._last_v ? this._last_v.toFixed(3) : "?";
  };
  d.prototype.onGetInputs = function() {
    return [["min", "number"], ["max", "number"]];
  };
  y.registerNodeType("math/rand", d);
  t.title = "Clamp";
  t.desc = "Clamp number between min and max";
  t.filter = "shader";
  t.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (a = Math.max(this.properties.min, a), a = Math.min(this.properties.max, a), this.setOutputData(0, a));
  };
  t.prototype.getCode = function(a) {
    a = "";
    this.isInputConnected(0) && (a += "clamp({{0}}," + this.properties.min + "," + this.properties.max + ")");
    return a;
  };
  y.registerNodeType("math/clamp", t);
  u.title = "Lerp";
  u.desc = "Linear Interpolation";
  u.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = 0);
    var b = this.getInputData(1);
    null == b && (b = 0);
    var c = this.properties.f, d = this.getInputData(2);
    void 0 !== d && (c = d);
    this.setOutputData(0, a * (1 - c) + b * c);
  };
  u.prototype.onGetInputs = function() {
    return [["f", "number"]];
  };
  y.registerNodeType("math/lerp", u);
  x.title = "Abs";
  x.desc = "Absolute";
  x.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, Math.abs(a));
  };
  y.registerNodeType("math/abs", x);
  w.title = "Floor";
  w.desc = "Floor number to remove fractional part";
  w.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, Math.floor(a));
  };
  y.registerNodeType("math/floor", w);
  h.title = "Frac";
  h.desc = "Returns fractional part";
  h.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, a % 1);
  };
  y.registerNodeType("math/frac", h);
  m.title = "Smoothstep";
  m.desc = "Smoothstep";
  m.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (void 0 !== a) {
      var b = this.properties.A;
      a = Math.clamp((a - b) / (this.properties.B - b), 0.0, 1.0);
      this.setOutputData(0, a * a * (3 - 2 * a));
    }
  };
  y.registerNodeType("math/smoothstep", m);
  b.title = "Scale";
  b.desc = "v * factor";
  b.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, a * this.properties.factor);
  };
  y.registerNodeType("math/scale", b);
  p.title = "Average";
  p.desc = "Average Filter";
  p.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = 0);
    var b = this._values.length;
    this._values[this._current % b] = a;
    this._current += 1;
    this._current > b && (this._current = 0);
    for (var c = a = 0; c < b; ++c) {
      a += this._values[c];
    }
    this.setOutputData(0, a / b);
  };
  p.prototype.onPropertyChanged = function(a, b) {
    1 > b && (b = 1);
    this.properties.samples = Math.round(b);
    a = this._values;
    this._values = new Float32Array(this.properties.samples);
    a.length <= this._values.length ? this._values.set(a) : this._values.set(a.subarray(0, this._values.length));
  };
  y.registerNodeType("math/average", p);
  a.title = "TendTo";
  a.desc = "moves the output value always closer to the input";
  a.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = 0);
    var b = this.properties.factor;
    this._value = null == this._value ? a : this._value * (1 - b) + a * b;
    this.setOutputData(0, this._value);
  };
  y.registerNodeType("math/tendTo", a);
  c.values = "+-*/%^".split("");
  c.title = "Operation";
  c.desc = "Easy math operators";
  c["@OP"] = {type:"enum", title:"operation", values:c.values};
  c.prototype.getTitle = function() {
    return "A " + this.properties.OP + " B";
  };
  c.prototype.setValue = function(a) {
    "string" == typeof a && (a = parseFloat(a));
    this.properties.value = a;
  };
  c.prototype.onExecute = function() {
    var a = this.getInputData(0), b = this.getInputData(1);
    null != a ? this.properties.A = a : a = this.properties.A;
    null != b ? this.properties.B = b : b = this.properties.B;
    var c = 0;
    switch(this.properties.OP) {
      case "+":
        c = a + b;
        break;
      case "-":
        c = a - b;
        break;
      case "x":
      case "X":
      case "*":
        c = a * b;
        break;
      case "/":
        c = a / b;
        break;
      case "%":
        c = a % b;
        break;
      case "^":
        c = Math.pow(a, b);
        break;
      default:
        console.warn("Unknown operation: " + this.properties.OP);
    }
    this.setOutputData(0, c);
  };
  c.prototype.onDrawBackground = function(a) {
    this.flags.collapsed || (a.font = "40px Arial", a.fillStyle = "#CCC", a.textAlign = "center", a.fillText(this.properties.OP, 0.5 * this.size[0], 0.35 * this.size[1] + y.NODE_TITLE_HEIGHT), a.textAlign = "left");
  };
  y.registerNodeType("math/operation", c);
  e.title = "Compare";
  e.desc = "compares between two values";
  e.prototype.onExecute = function() {
    var a = this.getInputData(0), b = this.getInputData(1);
    void 0 !== a ? this.properties.A = a : a = this.properties.A;
    void 0 !== b ? this.properties.B = b : b = this.properties.B;
    for (var c = 0, d = this.outputs.length; c < d; ++c) {
      var e = this.outputs[c];
      if (e.links && e.links.length) {
        switch(e.name) {
          case "A==B":
            value = a == b;
            break;
          case "A!=B":
            value = a != b;
            break;
          case "A>B":
            value = a > b;
            break;
          case "A<B":
            value = a < b;
            break;
          case "A<=B":
            value = a <= b;
            break;
          case "A>=B":
            value = a >= b;
        }
        this.setOutputData(c, value);
      }
    }
  };
  e.prototype.onGetOutputs = function() {
    return [["A==B", "boolean"], ["A!=B", "boolean"], ["A>B", "boolean"], ["A<B", "boolean"], ["A>=B", "boolean"], ["A<=B", "boolean"]];
  };
  y.registerNodeType("math/compare", e);
  y.registerSearchboxExtra("math/compare", "==", {outputs:[["A==B", "boolean"]], title:"A==B"});
  y.registerSearchboxExtra("math/compare", "!=", {outputs:[["A!=B", "boolean"]], title:"A!=B"});
  y.registerSearchboxExtra("math/compare", ">", {outputs:[["A>B", "boolean"]], title:"A>B"});
  y.registerSearchboxExtra("math/compare", "<", {outputs:[["A<B", "boolean"]], title:"A<B"});
  y.registerSearchboxExtra("math/compare", ">=", {outputs:[["A>=B", "boolean"]], title:"A>=B"});
  y.registerSearchboxExtra("math/compare", "<=", {outputs:[["A<=B", "boolean"]], title:"A<=B"});
  z.values = "> < == != <= >=".split(" ");
  z["@OP"] = {type:"enum", title:"operation", values:z.values};
  z.title = "Condition";
  z.desc = "evaluates condition between A and B";
  z.prototype.onExecute = function() {
    var a = this.getInputData(0);
    void 0 === a ? a = this.properties.A : this.properties.A = a;
    var b = this.getInputData(1);
    void 0 === b ? b = this.properties.B : this.properties.B = b;
    var c = !0;
    switch(this.properties.OP) {
      case ">":
        c = a > b;
        break;
      case "<":
        c = a < b;
        break;
      case "==":
        c = a == b;
        break;
      case "!=":
        c = a != b;
        break;
      case "<=":
        c = a <= b;
        break;
      case ">=":
        c = a >= b;
    }
    this.setOutputData(0, c);
  };
  y.registerNodeType("math/condition", z);
  g.title = "Accumulate";
  g.desc = "Increments a value every time";
  g.prototype.onExecute = function() {
    null === this.properties.value && (this.properties.value = 0);
    var a = this.getInputData(0);
    this.properties.value = null !== a ? this.properties.value + a : this.properties.value + this.properties.increment;
    this.setOutputData(0, this.properties.value);
  };
  y.registerNodeType("math/accumulate", g);
  l.title = "Trigonometry";
  l.desc = "Sin Cos Tan";
  l.filter = "shader";
  l.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = 0);
    var b = this.properties.amplitude, c = this.findInputSlot("amplitude");
    -1 != c && (b = this.getInputData(c));
    var d = this.properties.offset;
    c = this.findInputSlot("offset");
    -1 != c && (d = this.getInputData(c));
    c = 0;
    for (var e = this.outputs.length; c < e; ++c) {
      switch(this.outputs[c].name) {
        case "sin":
          value = Math.sin(a);
          break;
        case "cos":
          value = Math.cos(a);
          break;
        case "tan":
          value = Math.tan(a);
          break;
        case "asin":
          value = Math.asin(a);
          break;
        case "acos":
          value = Math.acos(a);
          break;
        case "atan":
          value = Math.atan(a);
      }
      this.setOutputData(c, b * value + d);
    }
  };
  l.prototype.onGetInputs = function() {
    return [["v", "number"], ["amplitude", "number"], ["offset", "number"]];
  };
  l.prototype.onGetOutputs = function() {
    return [["sin", "number"], ["cos", "number"], ["tan", "number"], ["asin", "number"], ["acos", "number"], ["atan", "number"]];
  };
  y.registerNodeType("math/trigonometry", l);
  y.registerSearchboxExtra("math/trigonometry", "SIN()", {outputs:[["sin", "number"]], title:"SIN()"});
  y.registerSearchboxExtra("math/trigonometry", "COS()", {outputs:[["cos", "number"]], title:"COS()"});
  y.registerSearchboxExtra("math/trigonometry", "TAN()", {outputs:[["tan", "number"]], title:"TAN()"});
  n.title = "Formula";
  n.desc = "Compute formula";
  n.prototype.onExecute = function() {
    if (y.allow_scripts) {
      var a = this.getInputData(0), b = this.getInputData(1);
      null != a ? this.properties.x = a : a = this.properties.x;
      null != b ? this.properties.y = b : b = this.properties.y;
      this._func && this._func_code == this.properties.formula || (this._func = new Function("x", "y", "TIME", "return " + this.properties.formula), this._func_code = this.properties.formula);
      a = this._func(a, b, this.graph.globaltime);
      this.setOutputData(0, a);
    }
  };
  n.prototype.getTitle = function() {
    return this._func_code || "";
  };
  n.prototype.onDrawBackground = function() {
    var a = this.properties.formula;
    this.outputs && this.outputs.length && (this.outputs[0].label = a);
  };
  y.registerNodeType("math/formula", n);
  A.title = "Vec2->XY";
  A.desc = "vector 2 to components";
  A.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (this.setOutputData(0, a[0]), this.setOutputData(1, a[1]));
  };
  y.registerNodeType("math3d/vec2-to-xyz", A);
  G.title = "XY->Vec2";
  G.desc = "components to vector2";
  G.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = this.properties.x);
    var b = this.getInputData(1);
    null == b && (b = this.properties.y);
    var c = this._data;
    c[0] = a;
    c[1] = b;
    this.setOutputData(0, c);
  };
  y.registerNodeType("math3d/xy-to-vec2", G);
  E.title = "Vec3->XYZ";
  E.desc = "vector 3 to components";
  E.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (this.setOutputData(0, a[0]), this.setOutputData(1, a[1]), this.setOutputData(2, a[2]));
  };
  y.registerNodeType("math3d/vec3-to-xyz", E);
  F.title = "XYZ->Vec3";
  F.desc = "components to vector3";
  F.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = this.properties.x);
    var b = this.getInputData(1);
    null == b && (b = this.properties.y);
    var c = this.getInputData(2);
    null == c && (c = this.properties.z);
    var d = this._data;
    d[0] = a;
    d[1] = b;
    d[2] = c;
    this.setOutputData(0, d);
  };
  y.registerNodeType("math3d/xyz-to-vec3", F);
  J.title = "Vec4->XYZW";
  J.desc = "vector 4 to components";
  J.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (this.setOutputData(0, a[0]), this.setOutputData(1, a[1]), this.setOutputData(2, a[2]), this.setOutputData(3, a[3]));
  };
  y.registerNodeType("math3d/vec4-to-xyzw", J);
  B.title = "XYZW->Vec4";
  B.desc = "components to vector4";
  B.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = this.properties.x);
    var b = this.getInputData(1);
    null == b && (b = this.properties.y);
    var c = this.getInputData(2);
    null == c && (c = this.properties.z);
    var d = this.getInputData(3);
    null == d && (d = this.properties.w);
    var e = this._data;
    e[0] = a;
    e[1] = b;
    e[2] = c;
    e[3] = d;
    this.setOutputData(0, e);
  };
  y.registerNodeType("math3d/xyzw-to-vec4", B);
  if (v.glMatrix) {
    v = function() {
      this.addInputs([["A", "quat"], ["B", "quat"], ["factor", "number"]]);
      this.addOutput("slerp", "quat");
      this.addProperty("factor", 0.5);
      this._value = quat.create();
    };
    var H = function() {
      this.addInputs([["A", "quat"], ["B", "quat"]]);
      this.addOutput("A*B", "quat");
      this._value = quat.create();
    }, D = function() {
      this.addInputs([["vec3", "vec3"], ["quat", "quat"]]);
      this.addOutput("result", "vec3");
      this.properties = {vec:[0, 0, 1]};
    }, C = function() {
      this.addInputs([["degrees", "number"], ["axis", "vec3"]]);
      this.addOutput("quat", "quat");
      this.properties = {angle:90.0, axis:vec3.fromValues(0, 1, 0)};
      this._value = quat.create();
    }, I = function() {
      this.addOutput("quat", "quat");
      this.properties = {x:0, y:0, z:0, w:1};
      this._value = quat.create();
    };
    I.title = "Quaternion";
    I.desc = "quaternion";
    I.prototype.onExecute = function() {
      this._value[0] = this.properties.x;
      this._value[1] = this.properties.y;
      this._value[2] = this.properties.z;
      this._value[3] = this.properties.w;
      this.setOutputData(0, this._value);
    };
    y.registerNodeType("math3d/quaternion", I);
    C.title = "Rotation";
    C.desc = "quaternion rotation";
    C.prototype.onExecute = function() {
      var a = this.getInputData(0);
      null == a && (a = this.properties.angle);
      var b = this.getInputData(1);
      null == b && (b = this.properties.axis);
      a = quat.setAxisAngle(this._value, b, 0.0174532925 * a);
      this.setOutputData(0, a);
    };
    y.registerNodeType("math3d/rotation", C);
    D.title = "Rot. Vec3";
    D.desc = "rotate a point";
    D.prototype.onExecute = function() {
      var a = this.getInputData(0);
      null == a && (a = this.properties.vec);
      var b = this.getInputData(1);
      null == b ? this.setOutputData(a) : this.setOutputData(0, vec3.transformQuat(vec3.create(), a, b));
    };
    y.registerNodeType("math3d/rotate_vec3", D);
    H.title = "Mult. Quat";
    H.desc = "rotate quaternion";
    H.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (null != a) {
        var b = this.getInputData(1);
        null != b && (a = quat.multiply(this._value, a, b), this.setOutputData(0, a));
      }
    };
    y.registerNodeType("math3d/mult-quat", H);
    v.title = "Quat Slerp";
    v.desc = "quaternion spherical interpolation";
    v.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (null != a) {
        var b = this.getInputData(1);
        if (null != b) {
          var c = this.properties.factor;
          null != this.getInputData(2) && (c = this.getInputData(2));
          a = quat.slerp(this._value, a, b, c);
          this.setOutputData(0, a);
        }
      }
    };
    y.registerNodeType("math3d/quat-slerp", v);
  }
})(this);
(function(v) {
  function f() {
    this.addInput("sel", "boolean");
    this.addOutput("value", "number");
    this.properties = {A:0, B:1};
    this.size = [60, 20];
  }
  v = v.LiteGraph;
  f.title = "Selector";
  f.desc = "outputs A if selector is true, B if selector is false";
  f.prototype.onExecute = function() {
    var f = this.getInputData(0);
    if (void 0 !== f) {
      for (var q = 1; q < this.inputs.length; q++) {
        var d = this.inputs[q], t = this.getInputData(q);
        void 0 !== t && (this.properties[d.name] = t);
      }
      q = this.properties.A;
      d = this.properties.B;
      this.setOutputData(0, f ? q : d);
    }
  };
  f.prototype.onGetInputs = function() {
    return [["A", 0], ["B", 0]];
  };
  v.registerNodeType("logic/selector", f);
})(this);
(function(v) {
  function f() {
    this.addInput("A", "Number");
    this.addInput("B", "Number");
    this.addInput("C", "Number");
    this.addInput("D", "Number");
    this.values = [[], [], [], []];
    this.properties = {scale:2};
  }
  function k() {
    this.addOutput("frame", "image");
    this.properties = {url:""};
  }
  function q() {
    this.addInput("f", "number");
    this.addOutput("Color", "color");
    this.properties = {colorA:"#444444", colorB:"#44AAFF", colorC:"#44FFAA", colorD:"#FFFFFF"};
  }
  function d() {
    this.addInput("", "image");
    this.size = [200, 200];
  }
  function t() {
    this.addInputs([["img1", "image"], ["img2", "image"], ["fade", "number"]]);
    this.addOutput("", "image");
    this.properties = {fade:0.5, width:512, height:512};
  }
  function u() {
    this.addInput("", "image");
    this.addOutput("", "image");
    this.properties = {width:256, height:256, x:0, y:0, scale:1.0};
    this.size = [50, 20];
  }
  function x() {
    this.addInput("t", "number");
    this.addOutputs([["frame", "image"], ["t", "number"], ["d", "number"]]);
    this.properties = {url:"", use_proxy:!0};
  }
  function w() {
    this.addOutput("Webcam", "image");
    this.properties = {facingMode:"user"};
    this.boxcolor = "black";
    this.frame = 0;
  }
  var h = v.LiteGraph;
  f.title = "Plot";
  f.desc = "Plots data over time";
  f.colors = ["#FFF", "#F99", "#9F9", "#99F"];
  f.prototype.onExecute = function(d) {
    if (!this.flags.collapsed) {
      d = this.size;
      for (var b = 0; 4 > b; ++b) {
        var m = this.getInputData(b);
        if (null != m) {
          var a = this.values[b];
          a.push(m);
          a.length > d[0] && a.shift();
        }
      }
    }
  };
  f.prototype.onDrawBackground = function(d) {
    if (!this.flags.collapsed) {
      var b = this.size, m = 0.5 * b[1] / this.properties.scale, a = f.colors, c = 0.5 * b[1];
      d.fillStyle = "#000";
      d.fillRect(0, 0, b[0], b[1]);
      d.strokeStyle = "#555";
      d.beginPath();
      d.moveTo(0, c);
      d.lineTo(b[0], c);
      d.stroke();
      if (this.inputs) {
        for (var e = 0; 4 > e; ++e) {
          var h = this.values[e];
          if (this.inputs[e] && this.inputs[e].link) {
            d.strokeStyle = a[e];
            d.beginPath();
            var g = h[0] * m * -1 + c;
            d.moveTo(0, Math.clamp(g, 0, b[1]));
            for (var l = 1; l < h.length && l < b[0]; ++l) {
              g = h[l] * m * -1 + c, d.lineTo(l, Math.clamp(g, 0, b[1]));
            }
            d.stroke();
          }
        }
      }
    }
  };
  h.registerNodeType("graphics/plot", f);
  k.title = "Image";
  k.desc = "Image loader";
  k.widgets = [{name:"load", text:"Load", type:"button"}];
  k.supported_extensions = ["jpg", "jpeg", "png", "gif"];
  k.prototype.onAdded = function() {
    "" != this.properties.url && null == this.img && this.loadImage(this.properties.url);
  };
  k.prototype.onDrawBackground = function(d) {
    this.img && 5 < this.size[0] && 5 < this.size[1] && d.drawImage(this.img, 0, 0, this.size[0], this.size[1]);
  };
  k.prototype.onExecute = function() {
    this.img || (this.boxcolor = "#000");
    this.img && this.img.width ? this.setOutputData(0, this.img) : this.setOutputData(0, null);
    this.img && this.img.dirty && (this.img.dirty = !1);
  };
  k.prototype.onPropertyChanged = function(d, b) {
    this.properties[d] = b;
    "url" == d && "" != b && this.loadImage(b);
    return !0;
  };
  k.prototype.loadImage = function(d, b) {
    if ("" == d) {
      this.img = null;
    } else {
      this.img = document.createElement("img");
      "http" == d.substr(0, 4) && h.proxy && (d = h.proxy + d.substr(d.indexOf(":") + 3));
      this.img.src = d;
      this.boxcolor = "#F95";
      var f = this;
      this.img.onload = function() {
        b && b(this);
        f.trace("Image loaded, size: " + f.img.width + "x" + f.img.height);
        this.dirty = !0;
        f.boxcolor = "#9F9";
        f.setDirtyCanvas(!0);
      };
    }
  };
  k.prototype.onWidget = function(d, b) {
    "load" == b.name && this.loadImage(this.properties.url);
  };
  k.prototype.onDropFile = function(d) {
    var b = this;
    this._url && URL.revokeObjectURL(this._url);
    this._url = URL.createObjectURL(d);
    this.properties.url = this._url;
    this.loadImage(this._url, function(d) {
      b.size[1] = d.height / d.width * b.size[0];
    });
  };
  h.registerNodeType("graphics/image", k);
  q.title = "Palette";
  q.desc = "Generates a color";
  q.prototype.onExecute = function() {
    var d = [];
    null != this.properties.colorA && d.push(hex2num(this.properties.colorA));
    null != this.properties.colorB && d.push(hex2num(this.properties.colorB));
    null != this.properties.colorC && d.push(hex2num(this.properties.colorC));
    null != this.properties.colorD && d.push(hex2num(this.properties.colorD));
    var b = this.getInputData(0);
    null == b && (b = 0.5);
    1.0 < b ? b = 1.0 : 0.0 > b && (b = 0.0);
    if (0 != d.length) {
      var f = [0, 0, 0];
      if (0 == b) {
        f = d[0];
      } else {
        if (1 == b) {
          f = d[d.length - 1];
        } else {
          var a = (d.length - 1) * b;
          b = d[Math.floor(a)];
          d = d[Math.floor(a) + 1];
          a -= Math.floor(a);
          f[0] = b[0] * (1 - a) + d[0] * a;
          f[1] = b[1] * (1 - a) + d[1] * a;
          f[2] = b[2] * (1 - a) + d[2] * a;
        }
      }
      for (var c in f) {
        f[c] /= 255;
      }
      this.boxcolor = colorToString(f);
      this.setOutputData(0, f);
    }
  };
  h.registerNodeType("color/palette", q);
  d.title = "Frame";
  d.desc = "Frame viewerew";
  d.widgets = [{name:"resize", text:"Resize box", type:"button"}, {name:"view", text:"View Image", type:"button"}];
  d.prototype.onDrawBackground = function(d) {
    this.frame && d.drawImage(this.frame, 0, 0, this.size[0], this.size[1]);
  };
  d.prototype.onExecute = function() {
    this.frame = this.getInputData(0);
    this.setDirtyCanvas(!0);
  };
  d.prototype.onWidget = function(d, b) {
    "resize" == b.name && this.frame ? (d = this.frame.width, b = this.frame.height, d || null == this.frame.videoWidth || (d = this.frame.videoWidth, b = this.frame.videoHeight), d && b && (this.size = [d, b]), this.setDirtyCanvas(!0, !0)) : "view" == b.name && this.show();
  };
  d.prototype.show = function() {
    showElement && this.frame && showElement(this.frame);
  };
  h.registerNodeType("graphics/frame", d);
  t.title = "Image fade";
  t.desc = "Fades between images";
  t.widgets = [{name:"resizeA", text:"Resize to A", type:"button"}, {name:"resizeB", text:"Resize to B", type:"button"}];
  t.prototype.onAdded = function() {
    this.createCanvas();
    var d = this.canvas.getContext("2d");
    d.fillStyle = "#000";
    d.fillRect(0, 0, this.properties.width, this.properties.height);
  };
  t.prototype.createCanvas = function() {
    this.canvas = document.createElement("canvas");
    this.canvas.width = this.properties.width;
    this.canvas.height = this.properties.height;
  };
  t.prototype.onExecute = function() {
    var d = this.canvas.getContext("2d");
    this.canvas.width = this.canvas.width;
    var b = this.getInputData(0);
    null != b && d.drawImage(b, 0, 0, this.canvas.width, this.canvas.height);
    b = this.getInputData(2);
    null == b ? b = this.properties.fade : this.properties.fade = b;
    d.globalAlpha = b;
    b = this.getInputData(1);
    null != b && d.drawImage(b, 0, 0, this.canvas.width, this.canvas.height);
    d.globalAlpha = 1.0;
    this.setOutputData(0, this.canvas);
    this.setDirtyCanvas(!0);
  };
  h.registerNodeType("graphics/imagefade", t);
  u.title = "Crop";
  u.desc = "Crop Image";
  u.prototype.onAdded = function() {
    this.createCanvas();
  };
  u.prototype.createCanvas = function() {
    this.canvas = document.createElement("canvas");
    this.canvas.width = this.properties.width;
    this.canvas.height = this.properties.height;
  };
  u.prototype.onExecute = function() {
    var d = this.getInputData(0);
    d && (d.width ? (this.canvas.getContext("2d").drawImage(d, -this.properties.x, -this.properties.y, d.width * this.properties.scale, d.height * this.properties.scale), this.setOutputData(0, this.canvas)) : this.setOutputData(0, null));
  };
  u.prototype.onDrawBackground = function(d) {
    this.flags.collapsed || this.canvas && d.drawImage(this.canvas, 0, 0, this.canvas.width, this.canvas.height, 0, 0, this.size[0], this.size[1]);
  };
  u.prototype.onPropertyChanged = function(d, b) {
    this.properties[d] = b;
    "scale" == d ? (this.properties[d] = parseFloat(b), 0 == this.properties[d] && (this.trace("Error in scale"), this.properties[d] = 1.0)) : this.properties[d] = parseInt(b);
    this.createCanvas();
    return !0;
  };
  h.registerNodeType("graphics/cropImage", u);
  x.title = "Video";
  x.desc = "Video playback";
  x.widgets = [{name:"play", text:"PLAY", type:"minibutton"}, {name:"stop", text:"STOP", type:"minibutton"}, {name:"demo", text:"Demo video", type:"button"}, {name:"mute", text:"Mute video", type:"button"}];
  x.prototype.onExecute = function() {
    if (this.properties.url && (this.properties.url != this._video_url && this.loadVideo(this.properties.url), this._video && 0 != this._video.width)) {
      var d = this.getInputData(0);
      d && 0 <= d && 1.0 >= d && (this._video.currentTime = d * this._video.duration, this._video.pause());
      this._video.dirty = !0;
      this.setOutputData(0, this._video);
      this.setOutputData(1, this._video.currentTime);
      this.setOutputData(2, this._video.duration);
      this.setDirtyCanvas(!0);
    }
  };
  x.prototype.onStart = function() {
    this.play();
  };
  x.prototype.onStop = function() {
    this.stop();
  };
  x.prototype.loadVideo = function(d) {
    this._video_url = d;
    this.properties.use_proxy && "http" == d.substr(0, 4) && h.proxy && (d = h.proxy + d.substr(d.indexOf(":") + 3));
    this._video = document.createElement("video");
    this._video.src = d;
    this._video.type = "type=video/mp4";
    this._video.muted = !0;
    this._video.autoplay = !0;
    var b = this;
    this._video.addEventListener("loadedmetadata", function(d) {
      b.trace("Duration: " + this.duration + " seconds");
      b.trace("Size: " + this.videoWidth + "," + this.videoHeight);
      b.setDirtyCanvas(!0);
      this.width = this.videoWidth;
      this.height = this.videoHeight;
    });
    this._video.addEventListener("progress", function(b) {
    });
    this._video.addEventListener("error", function(d) {
      console.log("Error loading video: " + this.src);
      b.trace("Error loading video: " + this.src);
      if (this.error) {
        switch(this.error.code) {
          case this.error.MEDIA_ERR_ABORTED:
            b.trace("You stopped the video.");
            break;
          case this.error.MEDIA_ERR_NETWORK:
            b.trace("Network error - please try again later.");
            break;
          case this.error.MEDIA_ERR_DECODE:
            b.trace("Video is broken..");
            break;
          case this.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
            b.trace("Sorry, your browser can't play this video.");
        }
      }
    });
    this._video.addEventListener("ended", function(d) {
      b.trace("Ended.");
      this.play();
    });
  };
  x.prototype.onPropertyChanged = function(d, b) {
    this.properties[d] = b;
    "url" == d && "" != b && this.loadVideo(b);
    return !0;
  };
  x.prototype.play = function() {
    this._video && this._video.play();
  };
  x.prototype.playPause = function() {
    this._video && (this._video.paused ? this.play() : this.pause());
  };
  x.prototype.stop = function() {
    this._video && (this._video.pause(), this._video.currentTime = 0);
  };
  x.prototype.pause = function() {
    this._video && (this.trace("Video paused"), this._video.pause());
  };
  x.prototype.onWidget = function(d, b) {
  };
  h.registerNodeType("graphics/video", x);
  w.title = "Webcam";
  w.desc = "Webcam image";
  w.prototype.openStream = function() {
    if (navigator.getUserMedia) {
      this._waiting_confirmation = !0;
      navigator.mediaDevices.getUserMedia({audio:!1, video:{facingMode:this.properties.facingMode}}).then(this.streamReady.bind(this)).catch(function(b) {
        console.log("Webcam rejected", b);
        d._webcam_stream = !1;
        d.boxcolor = "red";
        d.trigger("stream_error");
      });
      var d = this;
    }
  };
  w.prototype.closeStream = function() {
    if (this._webcam_stream) {
      var d = this._webcam_stream.getTracks();
      if (d.length) {
        for (var b = 0; b < d.length; ++b) {
          d[b].stop();
        }
      }
      this._video = this._webcam_stream = null;
      this.boxcolor = "black";
      this.trigger("stream_closed");
    }
  };
  w.prototype.onPropertyChanged = function(d, b) {
    "facingMode" == d && (this.properties.facingMode = b, this.closeStream(), this.openStream());
  };
  w.prototype.onRemoved = function() {
    this.closeStream();
  };
  w.prototype.streamReady = function(d) {
    this._webcam_stream = d;
    this.boxcolor = "green";
    var b = this._video;
    b || (b = document.createElement("video"), b.autoplay = !0, b.srcObject = d, this._video = b, b.onloadedmetadata = function(b) {
      console.log(b);
    });
    this.trigger("stream_ready", b);
  };
  w.prototype.onExecute = function() {
    null != this._webcam_stream || this._waiting_confirmation || this.openStream();
    if (this._video && this._video.videoWidth) {
      this._video.frame = ++this.frame;
      this._video.width = this._video.videoWidth;
      this._video.height = this._video.videoHeight;
      this.setOutputData(0, this._video);
      for (var d = 1; d < this.outputs.length; ++d) {
        if (this.outputs[d]) {
          switch(this.outputs[d].name) {
            case "width":
              this.setOutputData(d, this._video.videoWidth);
              break;
            case "height":
              this.setOutputData(d, this._video.videoHeight);
          }
        }
      }
    }
  };
  w.prototype.getExtraMenuOptions = function(d) {
    var b = this;
    return [{content:b.properties.show ? "Hide Frame" : "Show Frame", callback:function() {
      b.properties.show = !b.properties.show;
    }}];
  };
  w.prototype.onDrawBackground = function(d) {
    this.flags.collapsed || 20 >= this.size[1] || !this.properties.show || !this._video || (d.save(), d.drawImage(this._video, 0, 0, this.size[0], this.size[1]), d.restore());
  };
  w.prototype.onGetOutputs = function() {
    return [["width", "number"], ["height", "number"], ["stream_ready", h.EVENT], ["stream_closed", h.EVENT], ["stream_error", h.EVENT]];
  };
  h.registerNodeType("graphics/webcam", w);
})(this);
(function(v) {
  var f = v.LiteGraph;
  v.LGraphTexture = null;
  if ("undefined" != typeof GL) {
    var k = function() {
      this.addOutput("Cubemap", "Cubemap");
      this.properties = {name:""};
      this.size = [r.image_preview_size, r.image_preview_size];
    }, q = function() {
      this.addInput("in", "Texture");
      this.addOutput("out", "Texture");
      this.properties = {key_color:vec3.fromValues(0., 1., 0.), threshold:0.8, slope:0.2, precision:r.DEFAULT};
    }, d = function() {
      this.addOutput("out", "Texture");
      this.properties = {code:"", width:512, height:512, precision:r.DEFAULT};
      this._temp_texture = this._func = null;
    }, t = function() {
      this.addOutput("out", "Texture");
      this.properties = {width:512, height:512, seed:0, persistence:0.1, octaves:8, scale:1, offset:[0, 0], amplitude:1, precision:r.DEFAULT};
      this._key = 0;
      this._uniforms = {u_persistence:0.1, u_seed:0, u_offset:vec2.create(), u_scale:1, u_viewport:vec2.create()};
    }, u = function() {
      this.addInput("in", "Texture");
      this.addInput("avg", "number");
      this.addOutput("out", "Texture");
      this.properties = {enabled:!0, scale:1, gamma:1, average_lum:1, lum_white:1, precision:r.LOW};
      this._uniforms = {u_texture:0, u_lumwhite2:1, u_igamma:1, u_scale:1, u_average_lum:1};
    }, x = function() {
      this.addInput("in", "Texture");
      this.addInput("exp", "number");
      this.addOutput("out", "Texture");
      this.properties = {exposition:1, precision:r.LOW};
      this._uniforms = {u_texture:0, u_exposition:1};
    }, w = function() {
      this.addInput("in", "Texture");
      this.addInput("f", "number");
      this.addOutput("out", "Texture");
      this.properties = {enabled:!0, factor:1, precision:r.LOW};
      this._uniforms = {u_texture:0, u_factor:1};
    }, h = function() {
      this.addOutput("Webcam", "Texture");
      this.properties = {texture_name:"", facingMode:"user"};
      this.boxcolor = "black";
      this.version = 0;
    }, m = function() {
      this.addInput("Texture", "Texture");
      this.addOutput("Filtered", "Texture");
      this.properties = {intensity:1, radius:5};
    }, b = function() {
      this.addInput("in", "Texture");
      this.addInput("dirt", "Texture");
      this.addOutput("out", "Texture");
      this.addOutput("glow", "Texture");
      this.properties = {enabled:!0, intensity:1, persistence:0.99, iterations:16, threshold:0, scale:1, dirt_factor:0.5, precision:r.DEFAULT};
      this._textures = [];
      this._uniforms = {u_intensity:1, u_texture:0, u_glow_texture:1, u_threshold:0, u_texel_size:vec2.create()};
    }, p = function() {
      this.addInput("Texture", "Texture");
      this.addInput("Iterations", "number");
      this.addInput("Intensity", "number");
      this.addOutput("Blurred", "Texture");
      this.properties = {intensity:1, iterations:1, preserve_aspect:!1, scale:[1, 1], precision:r.DEFAULT};
    }, a = function() {
      this.addInput("Texture", "Texture");
      this.addInput("Distance", "number");
      this.addInput("Range", "number");
      this.addOutput("Texture", "Texture");
      this.properties = {distance:100, range:50, only_depth:!1, high_precision:!1};
      this._uniforms = {u_texture:0, u_distance:100, u_range:50, u_camera_planes:null};
    }, c = function() {
      this.addInput("Tex.", "Texture");
      this.addOutput("Edges", "Texture");
      this.properties = {invert:!0, threshold:!1, factor:1, precision:r.DEFAULT};
      c._shader || (c._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, c.pixel_shader));
    }, e = function() {
      this.addInput("A", "Texture");
      this.addInput("B", "Texture");
      this.addInput("Mixer", "Texture");
      this.addOutput("Texture", "Texture");
      this.properties = {factor:0.5, precision:r.DEFAULT};
      this._uniforms = {u_textureA:0, u_textureB:1, u_textureMix:2, u_mix:vec4.create()};
    }, z = function() {
      this.addInput("A", "color");
      this.addInput("B", "color");
      this.addOutput("Texture", "Texture");
      this.properties = {angle:0, scale:1, A:[0, 0, 0], B:[1, 1, 1], texture_size:32};
      z._shader || (z._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, z.pixel_shader));
      this._uniforms = {u_angle:0, u_colorA:vec3.create(), u_colorB:vec3.create()};
    }, g = function() {
      this.addOutput("Texture", "Texture");
      this._tex_color = vec4.create();
      this.properties = {color:vec4.create(), precision:r.DEFAULT};
    }, l = function() {
      this.addInput("R", "Texture");
      this.addInput("G", "Texture");
      this.addInput("B", "Texture");
      this.addInput("A", "Texture");
      this.addOutput("Texture", "Texture");
      this.properties = {};
      l._shader || (l._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, l.pixel_shader));
    }, n = function() {
      this.addInput("Texture", "Texture");
      this.addOutput("R", "Texture");
      this.addOutput("G", "Texture");
      this.addOutput("B", "Texture");
      this.addOutput("A", "Texture");
      this.properties = {};
      n._shader || (n._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, n.pixel_shader));
    }, A = function() {
      this.addInput("Texture", "Texture");
      this.addInput("LUT", "Texture");
      this.addInput("Intensity", "number");
      this.addOutput("", "Texture");
      this.properties = {intensity:1, precision:r.DEFAULT, texture:null};
      A._shader || (A._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, A.pixel_shader));
    }, G = function() {
      this.addInput("Image", "image");
      this.addOutput("", "Texture");
      this.properties = {};
    }, E = function() {
      this.addInput("Texture", "Texture");
      this.addOutput("tex", "Texture");
      this.addOutput("avg", "vec4");
      this.addOutput("lum", "number");
      this.properties = {mipmap_offset:0, low_precision:!1};
      this._uniforms = {u_texture:0, u_mipmap_offset:this.properties.mipmap_offset};
      this._luminance = new Float32Array(4);
    }, F = function() {
      this.addInput("Texture", "Texture");
      this.addOutput("", "Texture");
      this.properties = {iterations:1, generate_mipmaps:!1, precision:r.DEFAULT};
    }, J = function() {
      this.addInput("Texture", "Texture");
      this.addOutput("", "Texture");
      this.properties = {size:0, generate_mipmaps:!1, precision:r.DEFAULT};
    }, B = function() {
      this.addInput("Texture", "Texture");
      this.properties = {additive:!1, antialiasing:!1, filter:!0, disable_alpha:!1, gamma:1.0};
      this.size[0] = 130;
    }, y = function() {
      this.addInput("in", "Texture");
      this.addInput("warp", "Texture");
      this.addInput("factor", "number");
      this.addOutput("out", "Texture");
      this.properties = {factor:0.01, precision:r.DEFAULT};
    }, H = function() {
      this.addInput("in", "Texture");
      this.addInput("scale", "vec2");
      this.addInput("offset", "vec2");
      this.addOutput("out", "Texture");
      this.properties = {offset:vec2.fromValues(0, 0), scale:vec2.fromValues(1, 1), precision:r.DEFAULT};
    }, D = function() {
      this.addOutput("out", "Texture");
      this.properties = {code:"", width:512, height:512, precision:r.DEFAULT};
      this.properties.code = "\nvoid main() {\n  vec2 uv = v_coord;\n  vec3 color = vec3(0.0);\n//your code here\n\ngl_FragColor = vec4(color, 1.0);\n}\n";
      this._uniforms = {in_texture:0, texSize:vec2.create(), time:0};
    }, C = function() {
      this.addInput("Texture", "Texture");
      this.addInput("TextureB", "Texture");
      this.addInput("value", "number");
      this.addOutput("Texture", "Texture");
      this.help = "<p>pixelcode must be vec3</p>\r\n\t\t\t<p>uvcode must be vec2, is optional</p>\r\n\t\t\t<p><strong>uv:</strong> tex. coords</p><p><strong>color:</strong> texture</p><p><strong>colorB:</strong> textureB</p><p><strong>time:</strong> scene time</p><p><strong>value:</strong> input value</p>";
      this.properties = {value:1, uvcode:"", pixelcode:"color + colorB * value", precision:r.DEFAULT};
    }, I = function() {
      this.addInput("Texture", "Texture");
      this.addOutput("", "Texture");
      this.properties = {name:""};
    }, K = function() {
      this.addInput("Texture", "Texture");
      this.properties = {flipY:!1};
      this.size = [r.image_preview_size, r.image_preview_size];
    }, r = function() {
      this.addOutput("Texture", "Texture");
      this.properties = {name:"", filter:!0};
      this.size = [r.image_preview_size, r.image_preview_size];
    };
    LGraphCanvas.link_type_colors.Texture = "#AEF";
    v.LGraphTexture = r;
    r.title = "Texture";
    r.desc = "Texture";
    r.widgets_info = {name:{widget:"texture"}, filter:{widget:"checkbox"}};
    r.loadTextureCallback = null;
    r.image_preview_size = 256;
    r.PASS_THROUGH = 1;
    r.COPY = 2;
    r.LOW = 3;
    r.HIGH = 4;
    r.REUSE = 5;
    r.DEFAULT = 2;
    r.MODE_VALUES = {"pass through":r.PASS_THROUGH, copy:r.COPY, low:r.LOW, high:r.HIGH, reuse:r.REUSE, "default":r.DEFAULT};
    r.getTexturesContainer = function() {
      return gl.textures;
    };
    r.loadTexture = function(a, b) {
      b = b || {};
      var c = a;
      "http://" == c.substr(0, 7) && f.proxy && (c = f.proxy + c.substr(7));
      return r.getTexturesContainer()[a] = GL.Texture.fromURL(c, b);
    };
    r.getTexture = function(a) {
      var b = this.getTexturesContainer();
      if (!b) {
        throw "Cannot load texture, container of textures not found";
      }
      b = b[a];
      return !b && a && ":" != a[0] ? this.loadTexture(a) : b;
    };
    r.getTargetTexture = function(a, b, c) {
      if (!a) {
        throw "LGraphTexture.getTargetTexture expects a reference texture";
      }
      switch(c) {
        case r.LOW:
          c = gl.UNSIGNED_BYTE;
          break;
        case r.HIGH:
          c = gl.HIGH_PRECISION_FORMAT;
          break;
        case r.REUSE:
          return a;
        default:
          c = a ? a.type : gl.UNSIGNED_BYTE;
      }
      b && b.width == a.width && b.height == a.height && b.type == c || (b = new GL.Texture(a.width, a.height, {type:c, format:gl.RGBA, filter:gl.LINEAR}));
      return b;
    };
    r.getTextureType = function(a, b) {
      b = b ? b.type : gl.UNSIGNED_BYTE;
      switch(a) {
        case r.HIGH:
          b = gl.HIGH_PRECISION_FORMAT;
          break;
        case r.LOW:
          b = gl.UNSIGNED_BYTE;
      }
      return b;
    };
    r.getNoiseTexture = function() {
      if (this._noise_texture) {
        return this._noise_texture;
      }
      for (var a = new Uint8Array(1048576), b = 0; 1048576 > b; ++b) {
        a[b] = 255 * Math.random();
      }
      return this._noise_texture = a = GL.Texture.fromMemory(512, 512, a, {format:gl.RGBA, wrap:gl.REPEAT, filter:gl.NEAREST});
    };
    r.prototype.onDropFile = function(a, b, c) {
      a ? ("string" == typeof a ? a = GL.Texture.fromURL(a) : -1 != b.toLowerCase().indexOf(".dds") ? a = GL.Texture.fromDDSInMemory(a) : (a = new Blob([c]), a = URL.createObjectURL(a), a = GL.Texture.fromURL(a)), this._drop_texture = a, this.properties.name = b) : (this._drop_texture = null, this.properties.name = "");
    };
    r.prototype.getExtraMenuOptions = function(a) {
      var b = this;
      if (this._drop_texture) {
        return [{content:"Clear", callback:function() {
          b._drop_texture = null;
          b.properties.name = "";
        }}];
      }
    };
    r.prototype.onExecute = function() {
      var a = null;
      this.isOutputConnected(1) && (a = this.getInputData(0));
      !a && this._drop_texture && (a = this._drop_texture);
      !a && this.properties.name && (a = r.getTexture(this.properties.name));
      if (a) {
        this._last_tex = a;
        !1 === this.properties.filter ? a.setParameter(gl.TEXTURE_MAG_FILTER, gl.NEAREST) : a.setParameter(gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        this.setOutputData(0, a);
        for (var b = 1; b < this.outputs.length; b++) {
          var c = this.outputs[b];
          if (c) {
            var d = null;
            "width" == c.name ? d = a.width : "height" == c.name ? d = a.height : "aspect" == c.name && (d = a.width / a.height);
            this.setOutputData(b, d);
          }
        }
      }
    };
    r.prototype.onResourceRenamed = function(a, b) {
      this.properties.name == a && (this.properties.name = b);
    };
    r.prototype.onDrawBackground = function(a) {
      if (!(this.flags.collapsed || 20 >= this.size[1])) {
        if (this._drop_texture && a.webgl) {
          a.drawImage(this._drop_texture, 0, 0, this.size[0], this.size[1]);
        } else {
          if (this._last_preview_tex != this._last_tex) {
            if (a.webgl) {
              this._canvas = this._last_tex;
            } else {
              var b = r.generateLowResTexturePreview(this._last_tex);
              if (!b) {
                return;
              }
              this._last_preview_tex = this._last_tex;
              this._canvas = cloneCanvas(b);
            }
          }
          this._canvas && (a.save(), a.webgl || (a.translate(0, this.size[1]), a.scale(1, -1)), a.drawImage(this._canvas, 0, 0, this.size[0], this.size[1]), a.restore());
        }
      }
    };
    r.generateLowResTexturePreview = function(a) {
      if (!a) {
        return null;
      }
      var b = r.image_preview_size, c = a;
      if (a.format == gl.DEPTH_COMPONENT) {
        return null;
      }
      if (a.width > b || a.height > b) {
        c = this._preview_temp_tex, this._preview_temp_tex || (this._preview_temp_tex = c = new GL.Texture(b, b, {minFilter:gl.NEAREST})), a.copyTo(c);
      }
      a = this._preview_canvas;
      a || (this._preview_canvas = a = createCanvas(b, b));
      c && c.toCanvas(a);
      return a;
    };
    r.prototype.getResources = function(a) {
      a[this.properties.name] = GL.Texture;
      return a;
    };
    r.prototype.onGetInputs = function() {
      return [["in", "Texture"]];
    };
    r.prototype.onGetOutputs = function() {
      return [["width", "number"], ["height", "number"], ["aspect", "number"]];
    };
    f.registerNodeType("texture/texture", r);
    K.title = "Preview";
    K.desc = "Show a texture in the graph canvas";
    K.allow_preview = !1;
    K.prototype.onDrawBackground = function(a) {
      if (!this.flags.collapsed && (a.webgl || K.allow_preview)) {
        var b = this.getInputData(0);
        b && (b = !b.handle && a.webgl ? b : r.generateLowResTexturePreview(b), a.save(), this.properties.flipY && (a.translate(0, this.size[1]), a.scale(1, -1)), a.drawImage(b, 0, 0, this.size[0], this.size[1]), a.restore());
      }
    };
    f.registerNodeType("texture/preview", K);
    I.title = "Save";
    I.desc = "Save a texture in the repository";
    I.prototype.onExecute = function() {
      var a = this.getInputData(0);
      a && (this.properties.name && (r.storeTexture ? r.storeTexture(this.properties.name, a) : r.getTexturesContainer()[this.properties.name] = a), this.setOutputData(0, a));
    };
    f.registerNodeType("texture/save", I);
    C.widgets_info = {uvcode:{widget:"textarea", height:100}, pixelcode:{widget:"textarea", height:100}, precision:{widget:"combo", values:r.MODE_VALUES}};
    C.title = "Operation";
    C.desc = "Texture shader operation";
    C.prototype.getExtraMenuOptions = function(a) {
      var b = this;
      return [{content:b.properties.show ? "Hide Texture" : "Show Texture", callback:function() {
        b.properties.show = !b.properties.show;
      }}];
    };
    C.prototype.onDrawBackground = function(a) {
      this.flags.collapsed || 20 >= this.size[1] || !this.properties.show || !this._tex || this._tex.gl != a || (a.save(), a.drawImage(this._tex, 0, 0, this.size[0], this.size[1]), a.restore());
    };
    C.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (this.isOutputConnected(0)) {
        if (this.properties.precision === r.PASS_THROUGH) {
          this.setOutputData(0, a);
        } else {
          var b = this.getInputData(1);
          if (this.properties.uvcode || this.properties.pixelcode) {
            var c = 512, d = 512;
            a ? (c = a.width, d = a.height) : b && (c = b.width, d = b.height);
            var e = r.getTextureType(this.properties.precision, a);
            this._tex = a || this._tex ? r.getTargetTexture(a || this._tex, this._tex, this.properties.precision) : new GL.Texture(c, d, {type:e, format:gl.RGBA, filter:gl.LINEAR});
            e = "";
            this.properties.uvcode && (e = "uv = " + this.properties.uvcode, -1 != this.properties.uvcode.indexOf(";") && (e = this.properties.uvcode));
            var g = "";
            this.properties.pixelcode && (g = "result = " + this.properties.pixelcode, -1 != this.properties.pixelcode.indexOf(";") && (g = this.properties.pixelcode));
            var l = this._shader;
            if (!l || this._shader_code != e + "|" + g) {
              try {
                this._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, C.pixel_shader, {UV_CODE:e, PIXEL_CODE:g}), this.boxcolor = "#00FF00";
              } catch (P) {
                console.log("Error compiling shader: ", P);
                this.boxcolor = "#FF0000";
                return;
              }
              this.boxcolor = "#FF0000";
              this._shader_code = e + "|" + g;
              l = this._shader;
            }
            if (l) {
              this.boxcolor = "green";
              var f = this.getInputData(2);
              null != f ? this.properties.value = f : f = parseFloat(this.properties.value);
              var h = this.graph.getTime();
              this._tex.drawTo(function() {
                gl.disable(gl.DEPTH_TEST);
                gl.disable(gl.CULL_FACE);
                gl.disable(gl.BLEND);
                a && a.bind(0);
                b && b.bind(1);
                var e = Mesh.getScreenQuad();
                l.uniforms({u_texture:0, u_textureB:1, value:f, texSize:[c, d], time:h}).draw(e);
              });
              this.setOutputData(0, this._tex);
            } else {
              this.boxcolor = "red";
            }
          }
        }
      }
    };
    C.pixel_shader = "precision highp float;\n\r\n\t\t\t\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_textureB;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform vec2 texSize;\n\r\n\t\t\tuniform float time;\n\r\n\t\t\tuniform float value;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 uv = v_coord;\n\r\n\t\t\t\tUV_CODE;\n\r\n\t\t\t\tvec4 color4 = texture2D(u_texture, uv);\n\r\n\t\t\t\tvec3 color = color4.rgb;\n\r\n\t\t\t\tvec4 color4B = texture2D(u_textureB, uv);\n\r\n\t\t\t\tvec3 colorB = color4B.rgb;\n\r\n\t\t\t\tvec3 result = color;\n\r\n\t\t\t\tfloat alpha = 1.0;\n\r\n\t\t\t\tPIXEL_CODE;\n\r\n\t\t\t\tgl_FragColor = vec4(result, alpha);\n\r\n\t\t\t}\n\r\n\t\t\t";
    f.registerNodeType("texture/operation", C);
    D.title = "Shader";
    D.desc = "Texture shader";
    D.widgets_info = {code:{type:"code"}, precision:{widget:"combo", values:r.MODE_VALUES}};
    D.prototype.onPropertyChanged = function(a, b) {
      if ("code" == a && (a = this.getShader())) {
        b = a.uniformInfo;
        if (this.inputs) {
          for (var c = {}, d = 0; d < this.inputs.length; ++d) {
            var e = this.getInputInfo(d);
            e && (b[e.name] && !c[e.name] ? c[e.name] = !0 : (this.removeInput(d), d--));
          }
        }
        for (d in b) {
          if (e = a.uniformInfo[d], null !== e.loc && "time" != d) {
            if (this._shader.samplers[d]) {
              b = "texture";
            } else {
              switch(e.size) {
                case 1:
                  b = "number";
                  break;
                case 2:
                  b = "vec2";
                  break;
                case 3:
                  b = "vec3";
                  break;
                case 4:
                  b = "vec4";
                  break;
                case 9:
                  b = "mat3";
                  break;
                case 16:
                  b = "mat4";
                  break;
                default:
                  continue;
              }
            }
            c = this.findInputSlot(d);
            if (-1 != c && (e = this.getInputInfo(c))) {
              if (e.type == b) {
                continue;
              }
              this.removeInput(c, b);
            }
            this.addInput(d, b);
          }
        }
      }
    };
    D.prototype.getShader = function() {
      if (this._shader && this._shader_code == this.properties.code) {
        return this._shader;
      }
      this._shader_code = this.properties.code;
      this._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, D.pixel_shader + this.properties.code), this.boxcolor = "green";
      return this._shader;
    };
    D.prototype.onExecute = function() {
      if (this.isOutputConnected(0)) {
        var a = this.getShader();
        if (a) {
          for (var b = 0, c = null, d = 0; d < this.inputs.length; ++d) {
            var e = this.getInputInfo(d), g = this.getInputData(d);
            null != g && (g.constructor === GL.Texture && (g.bind(b), c || (c = g), g = b, b++), a.setUniform(e.name, g));
          }
          var l = this._uniforms;
          b = r.getTextureType(this.properties.precision, c);
          d = this.properties.width | 0;
          e = this.properties.height | 0;
          0 == d && (d = c ? c.width : gl.canvas.width);
          0 == e && (e = c ? c.height : gl.canvas.height);
          l.texSize[0] = d;
          l.texSize[1] = e;
          l.time = this.graph.getTime();
          this._tex && this._tex.type == b && this._tex.width == d && this._tex.height == e || (this._tex = new GL.Texture(d, e, {type:b, format:gl.RGBA, filter:gl.LINEAR}));
          this._tex.drawTo(function() {
            a.uniforms(l).draw(GL.Mesh.getScreenQuad());
          });
          this.setOutputData(0, this._tex);
        }
      }
    };
    D.pixel_shader = "precision highp float;\n\r\n\t\t\t\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform float time;\n\r\n\t";
    f.registerNodeType("texture/shader", D);
    H.widgets_info = {precision:{widget:"combo", values:r.MODE_VALUES}};
    H.title = "Scale/Offset";
    H.desc = "Applies an scaling and offseting";
    H.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (this.isOutputConnected(0) && a) {
        if (this.properties.precision === r.PASS_THROUGH) {
          this.setOutputData(0, a);
        } else {
          var b = a.width, c = a.height, d = this.precision === r.LOW ? gl.UNSIGNED_BYTE : gl.HIGH_PRECISION_FORMAT;
          this.precision === r.DEFAULT && (d = a.type);
          this._tex && this._tex.width == b && this._tex.height == c && this._tex.type == d || (this._tex = new GL.Texture(b, c, {type:d, format:gl.RGBA, filter:gl.LINEAR}));
          var e = this._shader;
          e || (e = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, H.pixel_shader));
          var g = this.getInputData(1);
          g ? (this.properties.scale[0] = g[0], this.properties.scale[1] = g[1]) : g = this.properties.scale;
          var l = this.getInputData(2);
          l ? (this.properties.offset[0] = l[0], this.properties.offset[1] = l[1]) : l = this.properties.offset;
          this._tex.drawTo(function() {
            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);
            a.bind(0);
            var b = Mesh.getScreenQuad();
            e.uniforms({u_texture:0, u_scale:g, u_offset:l}).draw(b);
          });
          this.setOutputData(0, this._tex);
        }
      }
    };
    H.pixel_shader = "precision highp float;\n\r\n\t\t\t\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_textureB;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform vec2 u_scale;\n\r\n\t\t\tuniform vec2 u_offset;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 uv = v_coord;\n\r\n\t\t\t\tuv = uv / u_scale - u_offset;\n\r\n\t\t\t\tgl_FragColor = texture2D(u_texture, uv);\n\r\n\t\t\t}\n\r\n\t\t\t";
    f.registerNodeType("texture/scaleOffset", H);
    y.widgets_info = {precision:{widget:"combo", values:r.MODE_VALUES}};
    y.title = "Warp";
    y.desc = "Texture warp operation";
    y.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (this.isOutputConnected(0)) {
        if (this.properties.precision === r.PASS_THROUGH) {
          this.setOutputData(0, a);
        } else {
          var b = this.getInputData(1), c = 512, d = 512;
          a ? (c = a.width, d = a.height) : b && (c = b.width, d = b.height);
          this._tex = a || this._tex ? r.getTargetTexture(a || this._tex, this._tex, this.properties.precision) : new GL.Texture(c, d, {type:this.precision === r.LOW ? gl.UNSIGNED_BYTE : gl.HIGH_PRECISION_FORMAT, format:gl.RGBA, filter:gl.LINEAR});
          var e = this._shader;
          e || (e = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, y.pixel_shader));
          var g = this.getInputData(2);
          null != g ? this.properties.factor = g : g = parseFloat(this.properties.factor);
          this._tex.drawTo(function() {
            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);
            a && a.bind(0);
            b && b.bind(1);
            var c = Mesh.getScreenQuad();
            e.uniforms({u_texture:0, u_textureB:1, u_factor:g}).draw(c);
          });
          this.setOutputData(0, this._tex);
        }
      }
    };
    y.pixel_shader = "precision highp float;\n\r\n\t\t\t\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_textureB;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform float u_factor;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 uv = v_coord;\n\r\n\t\t\t\tuv += ( texture2D(u_textureB, uv).rg - vec2(0.5)) * u_factor;\n\r\n\t\t\t\tgl_FragColor = texture2D(u_texture, uv);\n\r\n\t\t\t}\n\r\n\t\t\t";
    f.registerNodeType("texture/warp", y);
    B.title = "to Viewport";
    B.desc = "Texture to viewport";
    B.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (a) {
        this.properties.disable_alpha ? gl.disable(gl.BLEND) : (gl.enable(gl.BLEND), this.properties.additive ? gl.blendFunc(gl.SRC_ALPHA, gl.ONE) : gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA));
        gl.disable(gl.DEPTH_TEST);
        var b = this.properties.gamma || 1.0;
        this.isInputConnected(1) && (b = this.getInputData(1));
        a.setParameter(gl.TEXTURE_MAG_FILTER, this.properties.filter ? gl.LINEAR : gl.NEAREST);
        if (this.properties.antialiasing) {
          B._shader || (B._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, B.aa_pixel_shader));
          gl.getViewport();
          var c = Mesh.getScreenQuad();
          a.bind(0);
          B._shader.uniforms({u_texture:0, uViewportSize:[a.width, a.height], u_igamma:1 / b, inverseVP:[1 / a.width, 1 / a.height]}).draw(c);
        } else {
          1.0 != b ? (B._gamma_shader || (B._gamma_shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, B.gamma_pixel_shader)), a.toViewport(B._gamma_shader, {u_texture:0, u_igamma:1 / b})) : a.toViewport();
        }
      }
    };
    B.prototype.onGetInputs = function() {
      return [["gamma", "number"]];
    };
    B.aa_pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 uViewportSize;\n\r\n\t\t\tuniform vec2 inverseVP;\n\r\n\t\t\tuniform float u_igamma;\n\r\n\t\t\t#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n\r\n\t\t\t#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n\r\n\t\t\t#define FXAA_SPAN_MAX     8.0\n\r\n\t\t\t\n\r\n\t\t\t/* from mitsuhiko/webgl-meincraft based on the code on geeks3d.com */\n\r\n\t\t\tvec4 applyFXAA(sampler2D tex, vec2 fragCoord)\n\r\n\t\t\t{\n\r\n\t\t\t\tvec4 color = vec4(0.0);\n\r\n\t\t\t\t/*vec2 inverseVP = vec2(1.0 / uViewportSize.x, 1.0 / uViewportSize.y);*/\n\r\n\t\t\t\tvec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * inverseVP).xyz;\n\r\n\t\t\t\tvec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * inverseVP).xyz;\n\r\n\t\t\t\tvec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * inverseVP).xyz;\n\r\n\t\t\t\tvec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * inverseVP).xyz;\n\r\n\t\t\t\tvec3 rgbM  = texture2D(tex, fragCoord  * inverseVP).xyz;\n\r\n\t\t\t\tvec3 luma = vec3(0.299, 0.587, 0.114);\n\r\n\t\t\t\tfloat lumaNW = dot(rgbNW, luma);\n\r\n\t\t\t\tfloat lumaNE = dot(rgbNE, luma);\n\r\n\t\t\t\tfloat lumaSW = dot(rgbSW, luma);\n\r\n\t\t\t\tfloat lumaSE = dot(rgbSE, luma);\n\r\n\t\t\t\tfloat lumaM  = dot(rgbM,  luma);\n\r\n\t\t\t\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\r\n\t\t\t\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\r\n\t\t\t\t\n\r\n\t\t\t\tvec2 dir;\n\r\n\t\t\t\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\r\n\t\t\t\tdir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\r\n\t\t\t\t\n\r\n\t\t\t\tfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\r\n\t\t\t\t\n\r\n\t\t\t\tfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\r\n\t\t\t\tdir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * inverseVP;\n\r\n\t\t\t\t\n\r\n\t\t\t\tvec3 rgbA = 0.5 * (texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz + \n\r\n\t\t\t\t\ttexture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n\r\n\t\t\t\tvec3 rgbB = rgbA * 0.5 + 0.25 * (texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz + \n\r\n\t\t\t\t\ttexture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\r\n\t\t\t\t\n\r\n\t\t\t\t//return vec4(rgbA,1.0);\n\r\n\t\t\t\tfloat lumaB = dot(rgbB, luma);\n\r\n\t\t\t\tif ((lumaB < lumaMin) || (lumaB > lumaMax))\n\r\n\t\t\t\t\tcolor = vec4(rgbA, 1.0);\n\r\n\t\t\t\telse\n\r\n\t\t\t\t\tcolor = vec4(rgbB, 1.0);\n\r\n\t\t\t\tif(u_igamma != 1.0)\n\r\n\t\t\t\t\tcolor.xyz = pow( color.xyz, vec3(u_igamma) );\n\r\n\t\t\t\treturn color;\n\r\n\t\t\t}\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t   gl_FragColor = applyFXAA( u_texture, v_coord * uViewportSize) ;\n\r\n\t\t\t}\n\r\n\t\t\t";
    B.gamma_pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform float u_igamma;\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D( u_texture, v_coord);\n\r\n\t\t\t\tcolor.xyz = pow(color.xyz, vec3(u_igamma) );\n\r\n\t\t\t   gl_FragColor = color;\n\r\n\t\t\t}\n\r\n\t\t\t";
    f.registerNodeType("texture/toviewport", B);
    J.title = "Copy";
    J.desc = "Copy Texture";
    J.widgets_info = {size:{widget:"combo", values:[0, 32, 64, 128, 256, 512, 1024, 2048]}, precision:{widget:"combo", values:r.MODE_VALUES}};
    J.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if ((a || this._temp_texture) && this.isOutputConnected(0)) {
        if (a) {
          var b = a.width, c = a.height;
          0 != this.properties.size && (c = b = this.properties.size);
          var d = this._temp_texture, e = a.type;
          this.properties.precision === r.LOW ? e = gl.UNSIGNED_BYTE : this.properties.precision === r.HIGH && (e = gl.HIGH_PRECISION_FORMAT);
          d && d.width == b && d.height == c && d.type == e || (d = gl.LINEAR, this.properties.generate_mipmaps && isPowerOfTwo(b) && isPowerOfTwo(c) && (d = gl.LINEAR_MIPMAP_LINEAR), this._temp_texture = new GL.Texture(b, c, {type:e, format:gl.RGBA, minFilter:d, magFilter:gl.LINEAR}));
          a.copyTo(this._temp_texture);
          this.properties.generate_mipmaps && (this._temp_texture.bind(0), gl.generateMipmap(this._temp_texture.texture_type), this._temp_texture.unbind(0));
        }
        this.setOutputData(0, this._temp_texture);
      }
    };
    f.registerNodeType("texture/copy", J);
    F.title = "Downsample";
    F.desc = "Downsample Texture";
    F.widgets_info = {iterations:{type:"number", step:1, precision:0, min:1}, precision:{widget:"combo", values:r.MODE_VALUES}};
    F.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if ((a || this._temp_texture) && this.isOutputConnected(0) && a && a.texture_type === GL.TEXTURE_2D) {
        var b = F._shader;
        b || (F._shader = b = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, F.pixel_shader));
        var c = a.width | 0, d = a.height | 0, e = a.type;
        this.properties.precision === r.LOW ? e = gl.UNSIGNED_BYTE : this.properties.precision === r.HIGH && (e = gl.HIGH_PRECISION_FORMAT);
        var g = this.properties.iterations || 1, l = a, f = [];
        e = {type:e, format:a.format};
        var h = vec2.create(), k = {u_offset:h};
        this._texture && GL.Texture.releaseTemporary(this._texture);
        for (var m = 0; m < g; ++m) {
          h[0] = 1 / c;
          h[1] = 1 / d;
          c = c >> 1 || 0;
          d = d >> 1 || 0;
          a = GL.Texture.getTemporary(c, d, e);
          f.push(a);
          l.setParameter(GL.TEXTURE_MAG_FILTER, GL.NEAREST);
          l.copyTo(a, b, k);
          if (1 == c && 1 == d) {
            break;
          }
          l = a;
        }
        this._texture = f.pop();
        for (m = 0; m < f.length; ++m) {
          GL.Texture.releaseTemporary(f[m]);
        }
        this.properties.generate_mipmaps && (this._texture.bind(0), gl.generateMipmap(this._texture.texture_type), this._texture.unbind(0));
        this.setOutputData(0, this._texture);
      }
    };
    F.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_offset;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord );\n\r\n\t\t\t\tcolor += texture2D(u_texture, v_coord + vec2( u_offset.x, 0.0 ) );\n\r\n\t\t\t\tcolor += texture2D(u_texture, v_coord + vec2( 0.0, u_offset.y ) );\n\r\n\t\t\t\tcolor += texture2D(u_texture, v_coord + vec2( u_offset.x, u_offset.y ) );\n\r\n\t\t\t   gl_FragColor = color * 0.25;\n\r\n\t\t\t}\n\r\n\t\t\t";
    f.registerNodeType("texture/downsample", F);
    E.title = "Average";
    E.desc = "Compute a partial average (32 random samples) of a texture and stores it as a 1x1 pixel texture";
    E.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (a && (this.isOutputConnected(0) || this.isOutputConnected(1) || this.isOutputConnected(2))) {
        if (!E._shader) {
          E._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, E.pixel_shader);
          for (var b = new Float32Array(32), c = 0; 32 > c; ++c) {
            b[c] = Math.random();
          }
          E._shader.uniforms({u_samples_a:b.subarray(0, 16), u_samples_b:b.subarray(16, 32)});
        }
        c = this._temp_texture;
        b = gl.UNSIGNED_BYTE;
        a.type != b && (b = gl.FLOAT);
        c && c.type == b || (this._temp_texture = new GL.Texture(1, 1, {type:b, format:gl.RGBA, filter:gl.NEAREST}));
        var d = E._shader, e = this._uniforms;
        e.u_mipmap_offset = this.properties.mipmap_offset;
        this._temp_texture.drawTo(function() {
          a.toViewport(d, e);
        });
        this.setOutputData(0, this._temp_texture);
        if (this.isOutputConnected(1) || this.isOutputConnected(2)) {
          if (c = this._temp_texture.getPixels()) {
            var g = this._luminance;
            b = this._temp_texture.type;
            g.set(c);
            b == gl.UNSIGNED_BYTE ? vec4.scale(g, g, 1 / 255) : (b == GL.HALF_FLOAT || b == GL.HALF_FLOAT_OES) && vec4.scale(g, g, 1 / 65025);
            this.setOutputData(1, g);
            this.setOutputData(2, (g[0] + g[1] + g[2]) / 3);
          }
        }
      }
    };
    E.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tuniform mat4 u_samples_a;\n\r\n\t\t\tuniform mat4 u_samples_b;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform float u_mipmap_offset;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = vec4(0.0);\n\r\n\t\t\t\tfor(int i = 0; i < 4; ++i)\n\r\n\t\t\t\t\tfor(int j = 0; j < 4; ++j)\n\r\n\t\t\t\t\t{\n\r\n\t\t\t\t\t\tcolor += texture2D(u_texture, vec2( u_samples_a[i][j], u_samples_b[i][j] ), u_mipmap_offset );\n\r\n\t\t\t\t\t\tcolor += texture2D(u_texture, vec2( 1.0 - u_samples_a[i][j], 1.0 - u_samples_b[i][j] ), u_mipmap_offset );\n\r\n\t\t\t\t\t}\n\r\n\t\t\t   gl_FragColor = color * 0.03125;\n\r\n\t\t\t}\n\r\n\t\t\t";
    f.registerNodeType("texture/average", E);
    G.title = "Image to Texture";
    G.desc = "Uploads an image to the GPU";
    G.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (a) {
        var b = a.videoWidth || a.width, c = a.videoHeight || a.height;
        if (a.gltexture) {
          this.setOutputData(0, a.gltexture);
        } else {
          var d = this._temp_texture;
          d && d.width == b && d.height == c || (this._temp_texture = new GL.Texture(b, c, {format:gl.RGBA, filter:gl.LINEAR}));
          try {
            this._temp_texture.uploadImage(a);
          } catch (N) {
            console.error("image comes from an unsafe location, cannot be uploaded to webgl: " + N);
            return;
          }
          this.setOutputData(0, this._temp_texture);
        }
      }
    };
    f.registerNodeType("texture/imageToTexture", G);
    A.widgets_info = {texture:{widget:"texture"}, precision:{widget:"combo", values:r.MODE_VALUES}};
    A.title = "LUT";
    A.desc = "Apply LUT to Texture";
    A.prototype.onExecute = function() {
      if (this.isOutputConnected(0)) {
        var a = this.getInputData(0);
        if (this.properties.precision === r.PASS_THROUGH) {
          this.setOutputData(0, a);
        } else {
          if (a) {
            var b = this.getInputData(1);
            b || (b = r.getTexture(this.properties.texture));
            if (b) {
              b.bind(0);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              gl.bindTexture(gl.TEXTURE_2D, null);
              var c = this.properties.intensity;
              this.isInputConnected(2) && (this.properties.intensity = c = this.getInputData(2));
              this._tex = r.getTargetTexture(a, this._tex, this.properties.precision);
              this._tex.drawTo(function() {
                b.bind(1);
                a.toViewport(A._shader, {u_texture:0, u_textureB:1, u_amount:c});
              });
              this.setOutputData(0, this._tex);
            } else {
              this.setOutputData(0, a);
            }
          }
        }
      }
    };
    A.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_textureB;\n\r\n\t\t\tuniform float u_amount;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\t lowp vec4 textureColor = clamp( texture2D(u_texture, v_coord), vec4(0.0), vec4(1.0) );\n\r\n\t\t\t\t mediump float blueColor = textureColor.b * 63.0;\n\r\n\t\t\t\t mediump vec2 quad1;\n\r\n\t\t\t\t quad1.y = floor(floor(blueColor) / 8.0);\n\r\n\t\t\t\t quad1.x = floor(blueColor) - (quad1.y * 8.0);\n\r\n\t\t\t\t mediump vec2 quad2;\n\r\n\t\t\t\t quad2.y = floor(ceil(blueColor) / 8.0);\n\r\n\t\t\t\t quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n\r\n\t\t\t\t highp vec2 texPos1;\n\r\n\t\t\t\t texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n\r\n\t\t\t\t texPos1.y = 1.0 - ((quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));\n\r\n\t\t\t\t highp vec2 texPos2;\n\r\n\t\t\t\t texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n\r\n\t\t\t\t texPos2.y = 1.0 - ((quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));\n\r\n\t\t\t\t lowp vec4 newColor1 = texture2D(u_textureB, texPos1);\n\r\n\t\t\t\t lowp vec4 newColor2 = texture2D(u_textureB, texPos2);\n\r\n\t\t\t\t lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n\r\n\t\t\t\t gl_FragColor = vec4( mix( textureColor.rgb, newColor.rgb, u_amount), textureColor.w);\n\r\n\t\t\t}\n\r\n\t\t\t";
    f.registerNodeType("texture/LUT", A);
    n.title = "Texture to Channels";
    n.desc = "Split texture channels";
    n.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (a) {
        this._channels || (this._channels = Array(4));
        for (var b = 0, c = 0; 4 > c; c++) {
          this.isOutputConnected(c) ? (this._channels[c] && this._channels[c].width == a.width && this._channels[c].height == a.height && this._channels[c].type == a.type || (this._channels[c] = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR})), b++) : this._channels[c] = null;
        }
        if (b) {
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          var d = Mesh.getScreenQuad(), e = n._shader, g = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
          for (c = 0; 4 > c; c++) {
            this._channels[c] && (this._channels[c].drawTo(function() {
              a.bind(0);
              e.uniforms({u_texture:0, u_mask:g[c]}).draw(d);
            }), this.setOutputData(c, this._channels[c]));
          }
        }
      }
    };
    n.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec4 u_mask;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t   gl_FragColor = vec4( vec3( length( texture2D(u_texture, v_coord) * u_mask )), 1.0 );\n\r\n\t\t\t}\n\r\n\t\t\t";
    f.registerNodeType("texture/textureChannels", n);
    l.title = "Channels to Texture";
    l.desc = "Split texture channels";
    l.prototype.onExecute = function() {
      var a = [this.getInputData(0), this.getInputData(1), this.getInputData(2), this.getInputData(3)];
      if (a[0] && a[1] && a[2] && a[3]) {
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        var b = Mesh.getScreenQuad(), c = l._shader;
        this._tex = r.getTargetTexture(a[0], this._tex);
        this._tex.drawTo(function() {
          a[0].bind(0);
          a[1].bind(1);
          a[2].bind(2);
          a[3].bind(3);
          c.uniforms({u_textureR:0, u_textureG:1, u_textureB:2, u_textureA:3}).draw(b);
        });
        this.setOutputData(0, this._tex);
      }
    };
    l.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_textureR;\n\r\n\t\t\tuniform sampler2D u_textureG;\n\r\n\t\t\tuniform sampler2D u_textureB;\n\r\n\t\t\tuniform sampler2D u_textureA;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t   gl_FragColor = vec4( \r\n\t\t\t\t\t\ttexture2D(u_textureR, v_coord).r,\r\n\t\t\t\t\t\ttexture2D(u_textureG, v_coord).r,\r\n\t\t\t\t\t\ttexture2D(u_textureB, v_coord).r,\r\n\t\t\t\t\t\ttexture2D(u_textureA, v_coord).r);\n\r\n\t\t\t}\n\r\n\t\t\t";
    f.registerNodeType("texture/channelsTexture", l);
    g.title = "Color";
    g.desc = "Generates a 1x1 texture with a constant color";
    g.widgets_info = {precision:{widget:"combo", values:r.MODE_VALUES}};
    g.prototype.onDrawBackground = function(a) {
      var b = this.properties.color;
      a.fillStyle = "rgb(" + Math.floor(255 * Math.clamp(b[0], 0, 1)) + "," + Math.floor(255 * Math.clamp(b[1], 0, 1)) + "," + Math.floor(255 * Math.clamp(b[2], 0, 1)) + ")";
      this.flags.collapsed ? this.boxcolor = a.fillStyle : a.fillRect(0, 0, this.size[0], this.size[1]);
    };
    g.prototype.onExecute = function() {
      var a = this.properties.precision == r.HIGH ? r.HIGH_PRECISION_FORMAT : gl.UNSIGNED_BYTE;
      this._tex && this._tex.type == a || (this._tex = new GL.Texture(1, 1, {format:gl.RGBA, type:a, minFilter:gl.NEAREST}));
      a = this.properties.color;
      if (this.inputs) {
        for (var b = 0; b < this.inputs.length; b++) {
          var c = this.inputs[b], d = this.getInputData(b);
          if (void 0 !== d) {
            switch(c.name) {
              case "RGB":
              case "RGBA":
                a.set(d);
                break;
              case "R":
                a[0] = d;
                break;
              case "G":
                a[1] = d;
                break;
              case "B":
                a[2] = d;
                break;
              case "A":
                a[3] = d;
            }
          }
        }
      }
      0.001 < vec4.sqrDist(this._tex_color, a) && (this._tex_color.set(a), this._tex.fill(a));
      this.setOutputData(0, this._tex);
    };
    g.prototype.onGetInputs = function() {
      return [["RGB", "vec3"], ["RGBA", "vec4"], ["R", "number"], ["G", "number"], ["B", "number"], ["A", "number"]];
    };
    f.registerNodeType("texture/color", g);
    z.title = "Gradient";
    z.desc = "Generates a gradient";
    z["@A"] = {type:"color"};
    z["@B"] = {type:"color"};
    z["@texture_size"] = {type:"enum", values:[32, 64, 128, 256, 512]};
    z.prototype.onExecute = function() {
      gl.disable(gl.BLEND);
      gl.disable(gl.DEPTH_TEST);
      var a = GL.Mesh.getScreenQuad(), b = z._shader, c = this.getInputData(0);
      c || (c = this.properties.A);
      var d = this.getInputData(1);
      d || (d = this.properties.B);
      for (var e = 2; e < this.inputs.length; e++) {
        var g = this.inputs[e], l = this.getInputData(e);
        void 0 !== l && (this.properties[g.name] = l);
      }
      var f = this._uniforms;
      this._uniforms.u_angle = this.properties.angle * DEG2RAD;
      this._uniforms.u_scale = this.properties.scale;
      vec3.copy(f.u_colorA, c);
      vec3.copy(f.u_colorB, d);
      c = parseInt(this.properties.texture_size);
      this._tex && this._tex.width == c || (this._tex = new GL.Texture(c, c, {format:gl.RGB, filter:gl.LINEAR}));
      this._tex.drawTo(function() {
        b.uniforms(f).draw(a);
      });
      this.setOutputData(0, this._tex);
    };
    z.prototype.onGetInputs = function() {
      return [["angle", "number"], ["scale", "number"]];
    };
    z.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform float u_angle;\n\r\n\t\t\tuniform float u_scale;\n\r\n\t\t\tuniform vec3 u_colorA;\n\r\n\t\t\tuniform vec3 u_colorB;\n\r\n\t\t\t\n\r\n\t\t\tvec2 rotate(vec2 v, float angle)\n\r\n\t\t\t{\n\r\n\t\t\t\tvec2 result;\n\r\n\t\t\t\tfloat _cos = cos(angle);\n\r\n\t\t\t\tfloat _sin = sin(angle);\n\r\n\t\t\t\tresult.x = v.x * _cos - v.y * _sin;\n\r\n\t\t\t\tresult.y = v.x * _sin + v.y * _cos;\n\r\n\t\t\t\treturn result;\n\r\n\t\t\t}\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tfloat f = (rotate(u_scale * (v_coord - vec2(0.5)), u_angle) + vec2(0.5)).x;\n\r\n\t\t\t\tvec3 color = mix(u_colorA,u_colorB,clamp(f,0.0,1.0));\n\r\n\t\t\t   gl_FragColor = vec4(color,1.0);\n\r\n\t\t\t}\n\r\n\t\t\t";
    f.registerNodeType("texture/gradient", z);
    e.title = "Mix";
    e.desc = "Generates a texture mixing two textures";
    e.widgets_info = {precision:{widget:"combo", values:r.MODE_VALUES}};
    e.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (this.isOutputConnected(0)) {
        if (this.properties.precision === r.PASS_THROUGH) {
          this.setOutputData(0, a);
        } else {
          var b = this.getInputData(1);
          if (a && b) {
            var c = this.getInputData(2), d = this.getInputData(3);
            this._tex = r.getTargetTexture(a, this._tex, this.properties.precision);
            gl.disable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST);
            var g = Mesh.getScreenQuad(), l = null, f = this._uniforms;
            c ? (l = e._shader_tex, l || (l = e._shader_tex = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, e.pixel_shader, {MIX_TEX:""}))) : (l = e._shader_factor, l || (l = e._shader_factor = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, e.pixel_shader)), d = null == d ? this.properties.factor : d, f.u_mix.set([d, d, d, d]));
            this._tex.drawTo(function() {
              a.bind(0);
              b.bind(1);
              c && c.bind(2);
              l.uniforms(f).draw(g);
            });
            this.setOutputData(0, this._tex);
          }
        }
      }
    };
    e.prototype.onGetInputs = function() {
      return [["factor", "number"]];
    };
    e.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_textureA;\n\r\n\t\t\tuniform sampler2D u_textureB;\n\r\n\t\t\t#ifdef MIX_TEX\n\r\n\t\t\t\tuniform sampler2D u_textureMix;\n\r\n\t\t\t#else\n\r\n\t\t\t\tuniform vec4 u_mix;\n\r\n\t\t\t#endif\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\t#ifdef MIX_TEX\n\r\n\t\t\t\t   vec4 f = texture2D(u_textureMix, v_coord);\n\r\n\t\t\t\t#else\n\r\n\t\t\t\t   vec4 f = u_mix;\n\r\n\t\t\t\t#endif\n\r\n\t\t\t   gl_FragColor = mix( texture2D(u_textureA, v_coord), texture2D(u_textureB, v_coord), f );\n\r\n\t\t\t}\n\r\n\t\t\t";
    f.registerNodeType("texture/mix", e);
    c.title = "Edges";
    c.desc = "Detects edges";
    c.widgets_info = {precision:{widget:"combo", values:r.MODE_VALUES}};
    c.prototype.onExecute = function() {
      if (this.isOutputConnected(0)) {
        var a = this.getInputData(0);
        if (this.properties.precision === r.PASS_THROUGH) {
          this.setOutputData(0, a);
        } else {
          if (a) {
            this._tex = r.getTargetTexture(a, this._tex, this.properties.precision);
            gl.disable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST);
            var b = Mesh.getScreenQuad(), d = c._shader, e = this.properties.invert, g = this.properties.factor, l = this.properties.threshold ? 1 : 0;
            this._tex.drawTo(function() {
              a.bind(0);
              d.uniforms({u_texture:0, u_isize:[1 / a.width, 1 / a.height], u_factor:g, u_threshold:l, u_invert:e ? 1 : 0}).draw(b);
            });
            this.setOutputData(0, this._tex);
          }
        }
      }
    };
    c.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_isize;\n\r\n\t\t\tuniform int u_invert;\n\r\n\t\t\tuniform float u_factor;\n\r\n\t\t\tuniform float u_threshold;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 center = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tvec4 up = texture2D(u_texture, v_coord + u_isize * vec2(0.0,1.0) );\n\r\n\t\t\t\tvec4 down = texture2D(u_texture, v_coord + u_isize * vec2(0.0,-1.0) );\n\r\n\t\t\t\tvec4 left = texture2D(u_texture, v_coord + u_isize * vec2(1.0,0.0) );\n\r\n\t\t\t\tvec4 right = texture2D(u_texture, v_coord + u_isize * vec2(-1.0,0.0) );\n\r\n\t\t\t\tvec4 diff = abs(center - up) + abs(center - down) + abs(center - left) + abs(center - right);\n\r\n\t\t\t\tdiff *= u_factor;\n\r\n\t\t\t\tif(u_invert == 1)\n\r\n\t\t\t\t\tdiff.xyz = vec3(1.0) - diff.xyz;\n\r\n\t\t\t\tif( u_threshold == 0.0 )\n\r\n\t\t\t\t\tgl_FragColor = vec4( diff.xyz, center.a );\n\r\n\t\t\t\telse\n\r\n\t\t\t\t\tgl_FragColor = vec4( diff.x > 0.5 ? 1.0 : 0.0, diff.y > 0.5 ? 1.0 : 0.0, diff.z > 0.5 ? 1.0 : 0.0, center.a );\n\r\n\t\t\t}\n\r\n\t\t\t";
    f.registerNodeType("texture/edges", c);
    a.title = "Depth Range";
    a.desc = "Generates a texture with a depth range";
    a.prototype.onExecute = function() {
      if (this.isOutputConnected(0)) {
        var b = this.getInputData(0);
        if (b) {
          var c = gl.UNSIGNED_BYTE;
          this.properties.high_precision && (c = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT);
          this._temp_texture && this._temp_texture.type == c && this._temp_texture.width == b.width && this._temp_texture.height == b.height || (this._temp_texture = new GL.Texture(b.width, b.height, {type:c, format:gl.RGBA, filter:gl.LINEAR}));
          var d = this._uniforms;
          c = this.properties.distance;
          this.isInputConnected(1) && (c = this.getInputData(1), this.properties.distance = c);
          var e = this.properties.range;
          this.isInputConnected(2) && (e = this.getInputData(2), this.properties.range = e);
          d.u_distance = c;
          d.u_range = e;
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          var g = Mesh.getScreenQuad();
          a._shader || (a._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, a.pixel_shader), a._shader_onlydepth = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, a.pixel_shader, {ONLY_DEPTH:""}));
          var l = this.properties.only_depth ? a._shader_onlydepth : a._shader;
          c = null;
          c = b.near_far_planes ? b.near_far_planes : window.LS && LS.Renderer._main_camera ? LS.Renderer._main_camera._uniforms.u_camera_planes : [0.1, 1000];
          d.u_camera_planes = c;
          this._temp_texture.drawTo(function() {
            b.bind(0);
            l.uniforms(d).draw(g);
          });
          this._temp_texture.near_far_planes = c;
          this.setOutputData(0, this._temp_texture);
        }
      }
    };
    a.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform float u_distance;\n\r\n\t\t\tuniform float u_range;\n\r\n\t\t\t\n\r\n\t\t\tfloat LinearDepth()\n\r\n\t\t\t{\n\r\n\t\t\t\tfloat zNear = u_camera_planes.x;\n\r\n\t\t\t\tfloat zFar = u_camera_planes.y;\n\r\n\t\t\t\tfloat depth = texture2D(u_texture, v_coord).x;\n\r\n\t\t\t\tdepth = depth * 2.0 - 1.0;\n\r\n\t\t\t\treturn zNear * (depth + 1.0) / (zFar + zNear - depth * (zFar - zNear));\n\r\n\t\t\t}\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tfloat depth = LinearDepth();\n\r\n\t\t\t\t#ifdef ONLY_DEPTH\n\r\n\t\t\t\t   gl_FragColor = vec4(depth);\n\r\n\t\t\t\t#else\n\r\n\t\t\t\t\tfloat diff = abs(depth * u_camera_planes.y - u_distance);\n\r\n\t\t\t\t\tfloat dof = 1.0;\n\r\n\t\t\t\t\tif(diff <= u_range)\n\r\n\t\t\t\t\t\tdof = diff / u_range;\n\r\n\t\t\t\t   gl_FragColor = vec4(dof);\n\r\n\t\t\t\t#endif\n\r\n\t\t\t}\n\r\n\t\t\t";
    f.registerNodeType("texture/depth_range", a);
    p.title = "Blur";
    p.desc = "Blur a texture";
    p.widgets_info = {precision:{widget:"combo", values:r.MODE_VALUES}};
    p.max_iterations = 20;
    p.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (a && this.isOutputConnected(0)) {
        var b = this._final_texture;
        b && b.width == a.width && b.height == a.height && b.type == a.type || (b = this._final_texture = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR}));
        var c = this.properties.iterations;
        this.isInputConnected(1) && (c = this.getInputData(1), this.properties.iterations = c);
        c = Math.min(Math.floor(c), p.max_iterations);
        if (0 == c) {
          this.setOutputData(0, a);
        } else {
          var d = this.properties.intensity;
          this.isInputConnected(2) && (d = this.getInputData(2), this.properties.intensity = d);
          var e = f.camera_aspect;
          e || void 0 === window.gl || (e = gl.canvas.height / gl.canvas.width);
          e || (e = 1);
          e = this.properties.preserve_aspect ? e : 1;
          var g = this.properties.scale || [1, 1];
          a.applyBlur(e * g[0], g[1], d, b);
          for (a = 1; a < c; ++a) {
            b.applyBlur(e * g[0] * (a + 1), g[1] * (a + 1), d);
          }
          this.setOutputData(0, b);
        }
      }
    };
    f.registerNodeType("texture/blur", p);
    b.title = "Glow";
    b.desc = "Filters a texture giving it a glow effect";
    b.weights = new Float32Array([0.5, 0.4, 0.3, 0.2]);
    b.widgets_info = {iterations:{type:"number", min:0, max:16, step:1, precision:0}, threshold:{type:"number", min:0, max:10, step:0.01, precision:2}, precision:{widget:"combo", values:r.MODE_VALUES}};
    b.prototype.onGetInputs = function() {
      return [["enabled", "boolean"], ["threshold", "number"], ["intensity", "number"], ["persistence", "number"], ["iterations", "number"], ["dirt_factor", "number"]];
    };
    b.prototype.onGetOutputs = function() {
      return [["average", "Texture"]];
    };
    b.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (a && this.isAnyOutputConnected()) {
        if (this.properties.precision === r.PASS_THROUGH || !1 === this.getInputOrProperty("enabled")) {
          this.setOutputData(0, a);
        } else {
          var c = a.width, d = a.height, e = {format:a.format, type:a.type, minFilter:GL.LINEAR, magFilter:GL.LINEAR, wrap:gl.CLAMP_TO_EDGE}, g = r.getTextureType(this.properties.precision, a), l = this._uniforms, f = this._textures, h = b._cut_shader;
          h || (h = b._cut_shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, b.cut_pixel_shader));
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.BLEND);
          l.u_threshold = this.getInputOrProperty("threshold");
          var k = f[0] = GL.Texture.getTemporary(c, d, e);
          a.blit(k, h.uniforms(l));
          var m = k, n = this.getInputOrProperty("iterations");
          n = Math.clamp(n, 1, 16) | 0;
          var p = l.u_texel_size, q = this.getInputOrProperty("intensity");
          l.u_intensity = 1;
          l.u_delta = this.properties.scale;
          h = b._shader;
          h || (h = b._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, b.scale_pixel_shader));
          for (var u = 1; u < n; u++) {
            c >>= 1;
            1 < (d | 0) && (d >>= 1);
            if (2 > c) {
              break;
            }
            k = f[u] = GL.Texture.getTemporary(c, d, e);
            p[0] = 1 / m.width;
            p[1] = 1 / m.height;
            m.blit(k, h.uniforms(l));
            m = k;
          }
          this.isOutputConnected(2) && (c = this._average_texture, c && c.type == a.type && c.format == a.format || (c = this._average_texture = new GL.Texture(1, 1, {type:a.type, format:a.format, filter:gl.LINEAR})), p[0] = 1 / m.width, p[1] = 1 / m.height, l.u_intensity = q, l.u_delta = 1, m.blit(c, h.uniforms(l)), this.setOutputData(2, c));
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.ONE, gl.ONE);
          l.u_intensity = this.getInputOrProperty("persistence");
          l.u_delta = 0.5;
          for (u -= 2; 0 <= u; u--) {
            k = f[u], f[u] = null, p[0] = 1 / m.width, p[1] = 1 / m.height, m.blit(k, h.uniforms(l)), GL.Texture.releaseTemporary(m), m = k;
          }
          gl.disable(gl.BLEND);
          this.isOutputConnected(1) && (f = this._glow_texture, f && f.width == a.width && f.height == a.height && f.type == g && f.format == a.format || (f = this._glow_texture = new GL.Texture(a.width, a.height, {type:g, format:a.format, filter:gl.LINEAR})), m.blit(f), this.setOutputData(1, f));
          if (this.isOutputConnected(0)) {
            f = this._final_texture;
            f && f.width == a.width && f.height == a.height && f.type == g && f.format == a.format || (f = this._final_texture = new GL.Texture(a.width, a.height, {type:g, format:a.format, filter:gl.LINEAR}));
            var t = this.getInputData(1), v = this.getInputOrProperty("dirt_factor");
            l.u_intensity = q;
            h = t ? b._dirt_final_shader : b._final_shader;
            h || (h = t ? b._dirt_final_shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, b.final_pixel_shader, {USE_DIRT:""}) : b._final_shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, b.final_pixel_shader));
            f.drawTo(function() {
              a.bind(0);
              m.bind(1);
              t && (h.setUniform("u_dirt_factor", v), h.setUniform("u_dirt_texture", t.bind(2)));
              h.toViewport(l);
            });
            this.setOutputData(0, f);
          }
          GL.Texture.releaseTemporary(m);
        }
      }
    };
    b.cut_pixel_shader = "precision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform float u_threshold;\n\r\n\t\tvoid main() {\n\r\n\t\t\tgl_FragColor = max( texture2D( u_texture, v_coord ) - vec4( u_threshold ), vec4(0.0) );\n\r\n\t\t}";
    b.scale_pixel_shader = "precision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform vec2 u_texel_size;\n\r\n\t\tuniform float u_delta;\n\r\n\t\tuniform float u_intensity;\n\r\n\t\t\n\r\n\t\tvec4 sampleBox(vec2 uv) {\n\r\n\t\t\tvec4 o = u_texel_size.xyxy * vec2(-u_delta, u_delta).xxyy;\n\r\n\t\t\tvec4 s = texture2D( u_texture, uv + o.xy ) + texture2D( u_texture, uv + o.zy) + texture2D( u_texture, uv + o.xw) + texture2D( u_texture, uv + o.zw);\n\r\n\t\t\treturn s * 0.25;\n\r\n\t\t}\n\r\n\t\tvoid main() {\n\r\n\t\t\tgl_FragColor = u_intensity * sampleBox( v_coord );\n\r\n\t\t}";
    b.final_pixel_shader = "precision highp float;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tuniform sampler2D u_glow_texture;\n\r\n\t\t#ifdef USE_DIRT\n\r\n\t\t\tuniform sampler2D u_dirt_texture;\n\r\n\t\t#endif\n\r\n\t\tuniform vec2 u_texel_size;\n\r\n\t\tuniform float u_delta;\n\r\n\t\tuniform float u_intensity;\n\r\n\t\tuniform float u_dirt_factor;\n\r\n\t\t\n\r\n\t\tvec4 sampleBox(vec2 uv) {\n\r\n\t\t\tvec4 o = u_texel_size.xyxy * vec2(-u_delta, u_delta).xxyy;\n\r\n\t\t\tvec4 s = texture2D( u_glow_texture, uv + o.xy ) + texture2D( u_glow_texture, uv + o.zy) + texture2D( u_glow_texture, uv + o.xw) + texture2D( u_glow_texture, uv + o.zw);\n\r\n\t\t\treturn s * 0.25;\n\r\n\t\t}\n\r\n\t\tvoid main() {\n\r\n\t\t\tvec4 glow = sampleBox( v_coord );\n\r\n\t\t\t#ifdef USE_DIRT\n\r\n\t\t\t\tglow = mix( glow, glow * texture2D( u_dirt_texture, v_coord ), u_dirt_factor );\n\r\n\t\t\t#endif\n\r\n\t\t\tgl_FragColor = texture2D( u_texture, v_coord ) + u_intensity * glow;\n\r\n\t\t}";
    f.registerNodeType("texture/glow", b);
    m.title = "Kuwahara Filter";
    m.desc = "Filters a texture giving an artistic oil canvas painting";
    m.max_radius = 10;
    m._shaders = [];
    m.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (a && this.isOutputConnected(0)) {
        var b = this._temp_texture;
        b && b.width == a.width && b.height == a.height && b.type == a.type || (this._temp_texture = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR}));
        b = this.properties.radius;
        b = Math.min(Math.floor(b), m.max_radius);
        if (0 == b) {
          this.setOutputData(0, a);
        } else {
          var c = this.properties.intensity, d = f.camera_aspect;
          d || void 0 === window.gl || (d = gl.canvas.height / gl.canvas.width);
          d || (d = 1);
          d = this.properties.preserve_aspect ? d : 1;
          m._shaders[b] || (m._shaders[b] = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, m.pixel_shader, {RADIUS:b.toFixed(0)}));
          var e = m._shaders[b], g = GL.Mesh.getScreenQuad();
          a.bind(0);
          this._temp_texture.drawTo(function() {
            e.uniforms({u_texture:0, u_intensity:c, u_resolution:[a.width, a.height], u_iResolution:[1 / a.width, 1 / a.height]}).draw(g);
          });
          this.setOutputData(0, this._temp_texture);
        }
      }
    };
    m.pixel_shader = "\n\r\n\tprecision highp float;\n\r\n\tvarying vec2 v_coord;\n\r\n\tuniform sampler2D u_texture;\n\r\n\tuniform float u_intensity;\n\r\n\tuniform vec2 u_resolution;\n\r\n\tuniform vec2 u_iResolution;\n\r\n\t#ifndef RADIUS\n\r\n\t\t#define RADIUS 7\n\r\n\t#endif\n\r\n\tvoid main() {\n\r\n\t\n\r\n\t\tconst int radius = RADIUS;\n\r\n\t\tvec2 fragCoord = v_coord;\n\r\n\t\tvec2 src_size = u_iResolution;\n\r\n\t\tvec2 uv = v_coord;\n\r\n\t\tfloat n = float((radius + 1) * (radius + 1));\n\r\n\t\tint i;\n\r\n\t\tint j;\n\r\n\t\tvec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n\r\n\t\tvec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n\r\n\t\tvec3 c;\n\r\n\t\t\n\r\n\t\tfor (int j = -radius; j <= 0; ++j)  {\n\r\n\t\t\tfor (int i = -radius; i <= 0; ++i)  {\n\r\n\t\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\r\n\t\t\t\tm0 += c;\n\r\n\t\t\t\ts0 += c * c;\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tfor (int j = -radius; j <= 0; ++j)  {\n\r\n\t\t\tfor (int i = 0; i <= radius; ++i)  {\n\r\n\t\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\r\n\t\t\t\tm1 += c;\n\r\n\t\t\t\ts1 += c * c;\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tfor (int j = 0; j <= radius; ++j)  {\n\r\n\t\t\tfor (int i = 0; i <= radius; ++i)  {\n\r\n\t\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\r\n\t\t\t\tm2 += c;\n\r\n\t\t\t\ts2 += c * c;\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tfor (int j = 0; j <= radius; ++j)  {\n\r\n\t\t\tfor (int i = -radius; i <= 0; ++i)  {\n\r\n\t\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\r\n\t\t\t\tm3 += c;\n\r\n\t\t\t\ts3 += c * c;\n\r\n\t\t\t}\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tfloat min_sigma2 = 1e+2;\n\r\n\t\tm0 /= n;\n\r\n\t\ts0 = abs(s0 / n - m0 * m0);\n\r\n\t\t\n\r\n\t\tfloat sigma2 = s0.r + s0.g + s0.b;\n\r\n\t\tif (sigma2 < min_sigma2) {\n\r\n\t\t\tmin_sigma2 = sigma2;\n\r\n\t\t\tgl_FragColor = vec4(m0, 1.0);\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tm1 /= n;\n\r\n\t\ts1 = abs(s1 / n - m1 * m1);\n\r\n\t\t\n\r\n\t\tsigma2 = s1.r + s1.g + s1.b;\n\r\n\t\tif (sigma2 < min_sigma2) {\n\r\n\t\t\tmin_sigma2 = sigma2;\n\r\n\t\t\tgl_FragColor = vec4(m1, 1.0);\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tm2 /= n;\n\r\n\t\ts2 = abs(s2 / n - m2 * m2);\n\r\n\t\t\n\r\n\t\tsigma2 = s2.r + s2.g + s2.b;\n\r\n\t\tif (sigma2 < min_sigma2) {\n\r\n\t\t\tmin_sigma2 = sigma2;\n\r\n\t\t\tgl_FragColor = vec4(m2, 1.0);\n\r\n\t\t}\n\r\n\t\t\n\r\n\t\tm3 /= n;\n\r\n\t\ts3 = abs(s3 / n - m3 * m3);\n\r\n\t\t\n\r\n\t\tsigma2 = s3.r + s3.g + s3.b;\n\r\n\t\tif (sigma2 < min_sigma2) {\n\r\n\t\t\tmin_sigma2 = sigma2;\n\r\n\t\t\tgl_FragColor = vec4(m3, 1.0);\n\r\n\t\t}\n\r\n\t}\n\r\n\t";
    f.registerNodeType("texture/kuwahara", m);
    h.title = "Webcam";
    h.desc = "Webcam texture";
    h.prototype.openStream = function() {
      if (navigator.getUserMedia) {
        this._waiting_confirmation = !0;
        navigator.mediaDevices.getUserMedia({audio:!1, video:{facingMode:this.properties.facingMode}}).then(this.streamReady.bind(this)).catch(function(b) {
          console.log("Webcam rejected", b);
          a._webcam_stream = !1;
          a.boxcolor = "red";
          a.trigger("stream_error");
        });
        var a = this;
      }
    };
    h.prototype.closeStream = function() {
      if (this._webcam_stream) {
        var a = this._webcam_stream.getTracks();
        if (a.length) {
          for (var b = 0; b < a.length; ++b) {
            a[b].stop();
          }
        }
        this._video = this._webcam_stream = null;
        this.boxcolor = "black";
        this.trigger("stream_closed");
      }
    };
    h.prototype.streamReady = function(a) {
      this._webcam_stream = a;
      this.boxcolor = "green";
      var b = this._video;
      b || (b = document.createElement("video"), b.autoplay = !0, b.srcObject = a, this._video = b, b.onloadedmetadata = function(a) {
        console.log(a);
      });
      this.trigger("stream_ready", b);
    };
    h.prototype.onPropertyChanged = function(a, b) {
      "facingMode" == a && (this.properties.facingMode = b, this.closeStream(), this.openStream());
    };
    h.prototype.onRemoved = function() {
      if (this._webcam_stream) {
        var a = this._webcam_stream.getTracks();
        if (a.length) {
          for (var b = 0; b < a.length; ++b) {
            a[b].stop();
          }
        }
        this._video = this._webcam_stream = null;
      }
    };
    h.prototype.onDrawBackground = function(a) {
      this.flags.collapsed || 20 >= this.size[1] || !this._video || (a.save(), a.webgl ? this._video_texture && a.drawImage(this._video_texture, 0, 0, this.size[0], this.size[1]) : a.drawImage(this._video, 0, 0, this.size[0], this.size[1]), a.restore());
    };
    h.prototype.onExecute = function() {
      null != this._webcam_stream || this._waiting_confirmation || this.openStream();
      if (this._video && this._video.videoWidth) {
        var a = this._video.videoWidth, b = this._video.videoHeight, c = this._video_texture;
        c && c.width == a && c.height == b || (this._video_texture = new GL.Texture(a, b, {format:gl.RGB, filter:gl.LINEAR}));
        this._video_texture.uploadImage(this._video);
        this._video_texture.version = ++this.version;
        this.properties.texture_name && (r.getTexturesContainer()[this.properties.texture_name] = this._video_texture);
        this.setOutputData(0, this._video_texture);
        for (a = 1; a < this.outputs.length; ++a) {
          if (this.outputs[a]) {
            switch(this.outputs[a].name) {
              case "width":
                this.setOutputData(a, this._video.videoWidth);
                break;
              case "height":
                this.setOutputData(a, this._video.videoHeight);
            }
          }
        }
      }
    };
    h.prototype.onGetOutputs = function() {
      return [["width", "number"], ["height", "number"], ["stream_ready", f.EVENT], ["stream_closed", f.EVENT], ["stream_error", f.EVENT]];
    };
    f.registerNodeType("texture/webcam", h);
    w.title = "Lens FX";
    w.desc = "distortion and chromatic aberration";
    w.widgets_info = {precision:{widget:"combo", values:r.MODE_VALUES}};
    w.prototype.onGetInputs = function() {
      return [["enabled", "boolean"]];
    };
    w.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (a && this.isOutputConnected(0)) {
        if (this.properties.precision === r.PASS_THROUGH || !1 === this.getInputOrProperty("enabled")) {
          this.setOutputData(0, a);
        } else {
          var b = this._temp_texture;
          b && b.width == a.width && b.height == a.height && b.type == a.type || (b = this._temp_texture = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR}));
          var c = w._shader;
          c || (c = w._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, w.pixel_shader));
          var d = this.getInputData(1);
          null == d && (d = this.properties.factor);
          var e = this._uniforms;
          e.u_factor = d;
          gl.disable(gl.DEPTH_TEST);
          b.drawTo(function() {
            a.bind(0);
            c.uniforms(e).draw(GL.Mesh.getScreenQuad());
          });
          this.setOutputData(0, b);
        }
      }
    };
    w.pixel_shader = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform float u_factor;\n\r\n\t\t\tvec2 barrelDistortion(vec2 coord, float amt) {\n\r\n\t\t\t\tvec2 cc = coord - 0.5;\n\r\n\t\t\t\tfloat dist = dot(cc, cc);\n\r\n\t\t\t\treturn coord + cc * dist * amt;\n\r\n\t\t\t}\n\r\n\t\t\t\n\r\n\t\t\tfloat sat( float t )\n\r\n\t\t\t{\n\r\n\t\t\t\treturn clamp( t, 0.0, 1.0 );\n\r\n\t\t\t}\n\r\n\t\t\t\n\r\n\t\t\tfloat linterp( float t ) {\n\r\n\t\t\t\treturn sat( 1.0 - abs( 2.0*t - 1.0 ) );\n\r\n\t\t\t}\n\r\n\t\t\t\n\r\n\t\t\tfloat remap( float t, float a, float b ) {\n\r\n\t\t\t\treturn sat( (t - a) / (b - a) );\n\r\n\t\t\t}\n\r\n\t\t\t\n\r\n\t\t\tvec4 spectrum_offset( float t ) {\n\r\n\t\t\t\tvec4 ret;\n\r\n\t\t\t\tfloat lo = step(t,0.5);\n\r\n\t\t\t\tfloat hi = 1.0-lo;\n\r\n\t\t\t\tfloat w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );\n\r\n\t\t\t\tret = vec4(lo,1.0,hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);\n\r\n\t\t\t\n\r\n\t\t\t\treturn pow( ret, vec4(1.0/2.2) );\n\r\n\t\t\t}\n\r\n\t\t\t\n\r\n\t\t\tconst float max_distort = 2.2;\n\r\n\t\t\tconst int num_iter = 12;\n\r\n\t\t\tconst float reci_num_iter_f = 1.0 / float(num_iter);\n\r\n\t\t\t\n\r\n\t\t\tvoid main()\n\r\n\t\t\t{\t\n\r\n\t\t\t\tvec2 uv=v_coord;\n\r\n\t\t\t\tvec4 sumcol = vec4(0.0);\n\r\n\t\t\t\tvec4 sumw = vec4(0.0);\t\n\r\n\t\t\t\tfor ( int i=0; i<num_iter;++i )\n\r\n\t\t\t\t{\n\r\n\t\t\t\t\tfloat t = float(i) * reci_num_iter_f;\n\r\n\t\t\t\t\tvec4 w = spectrum_offset( t );\n\r\n\t\t\t\t\tsumw += w;\n\r\n\t\t\t\t\tsumcol += w * texture2D( u_texture, barrelDistortion(uv, .6 * max_distort*t * u_factor ) );\n\r\n\t\t\t\t}\n\r\n\t\t\t\tgl_FragColor = sumcol / sumw;\n\r\n\t\t\t}";
    f.registerNodeType("texture/lensfx", w);
    x.title = "Exposition";
    x.desc = "Controls texture exposition";
    x.widgets_info = {exposition:{widget:"slider", min:0, max:3}, precision:{widget:"combo", values:r.MODE_VALUES}};
    x.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (a && this.isOutputConnected(0)) {
        var b = this._temp_texture;
        b && b.width == a.width && b.height == a.height && b.type == a.type || (b = this._temp_texture = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR}));
        var c = x._shader;
        c || (c = x._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, x.pixel_shader));
        var d = this.getInputData(1);
        null != d && (this.properties.exposition = d);
        var e = this._uniforms;
        b.drawTo(function() {
          gl.disable(gl.DEPTH_TEST);
          a.bind(0);
          c.uniforms(e).draw(GL.Mesh.getScreenQuad());
        });
        this.setOutputData(0, b);
      }
    };
    x.pixel_shader = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform float u_exposition;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D( u_texture, v_coord );\n\r\n\t\t\t\tgl_FragColor = vec4( color.xyz * u_exposition, color.a );\n\r\n\t\t\t}";
    f.registerNodeType("texture/exposition", x);
    u.title = "Tone Mapping";
    u.desc = "Applies Tone Mapping to convert from high to low";
    u.widgets_info = {precision:{widget:"combo", values:r.MODE_VALUES}};
    u.prototype.onGetInputs = function() {
      return [["enabled", "boolean"]];
    };
    u.prototype.onExecute = function() {
      var a = this.getInputData(0);
      if (a && this.isOutputConnected(0)) {
        if (this.properties.precision === r.PASS_THROUGH || !1 === this.getInputOrProperty("enabled")) {
          this.setOutputData(0, a);
        } else {
          var b = this._temp_texture;
          b && b.width == a.width && b.height == a.height && b.type == a.type || (b = this._temp_texture = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR}));
          var c = u._shader;
          c || (c = u._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, u.pixel_shader));
          var d = this.getInputData(1);
          null != d && (this.properties.average_lum = d);
          var e = this._uniforms;
          e.u_lumwhite2 = this.properties.lum_white * this.properties.lum_white;
          e.u_scale = this.properties.scale;
          e.u_average_lum = this.properties.average_lum;
          e.u_igamma = 1 / this.properties.gamma;
          gl.disable(gl.DEPTH_TEST);
          b.drawTo(function() {
            a.bind(0);
            c.uniforms(e).draw(GL.Mesh.getScreenQuad());
          });
          this.setOutputData(0, this._temp_texture);
        }
      }
    };
    u.pixel_shader = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform float u_scale;\n\r\n\t\t\tuniform float u_average_lum;\n\r\n\t\t\tuniform float u_lumwhite2;\n\r\n\t\t\tuniform float u_igamma;\n\r\n\t\t\tvec3 RGB2xyY (vec3 rgb)\n\r\n\t\t\t{\n\r\n\t\t\t\t const mat3 RGB2XYZ = mat3(0.4124, 0.3576, 0.1805,\n\r\n\t\t\t\t\t\t\t\t\t\t   0.2126, 0.7152, 0.0722,\n\r\n\t\t\t\t\t\t\t\t\t\t   0.0193, 0.1192, 0.9505);\n\r\n\t\t\t\tvec3 XYZ = RGB2XYZ * rgb;\n\r\n\t\t\t\t\n\r\n\t\t\t\tfloat f = (XYZ.x + XYZ.y + XYZ.z);\n\r\n\t\t\t\treturn vec3(XYZ.x / f,\n\r\n\t\t\t\t\t\t\tXYZ.y / f,\n\r\n\t\t\t\t\t\t\tXYZ.y);\n\r\n\t\t\t}\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D( u_texture, v_coord );\n\r\n\t\t\t\tvec3 rgb = color.xyz;\n\r\n\t\t\t\t//Ld - this part of the code is the same for both versions\n\r\n\t\t\t\tfloat lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));\n\r\n\t\t\t\tfloat L = (u_scale / u_average_lum) * lum;\n\r\n\t\t\t\tfloat Ld = (L * (1.0 + L / u_lumwhite2)) / (1.0 + L);\n\r\n\t\t\t\t//first\n\r\n\t\t\t\t//vec3 xyY = RGB2xyY(rgb);\n\r\n\t\t\t\t//xyY.z *= Ld;\n\r\n\t\t\t\t//rgb = xyYtoRGB(xyY);\n\r\n\t\t\t\t//second\n\r\n\t\t\t\trgb = (rgb / lum) * Ld;\n\r\n\t\t\t\trgb = pow( rgb, vec3( u_igamma ) );\n\r\n\t\t\t\tgl_FragColor = vec4( rgb, color.a );\n\r\n\t\t\t}";
    f.registerNodeType("texture/tonemapping", u);
    t.title = "Perlin";
    t.desc = "Generates a perlin noise texture";
    t.widgets_info = {precision:{widget:"combo", values:r.MODE_VALUES}, width:{type:"Number", precision:0, step:1}, height:{type:"Number", precision:0, step:1}, octaves:{type:"Number", precision:0, step:1, min:1, max:50}};
    t.prototype.onExecute = function() {
      if (this.isOutputConnected(0)) {
        var a = this.properties.width | 0, b = this.properties.height | 0;
        0 == a && (a = gl.viewport_data[2]);
        0 == b && (b = gl.viewport_data[3]);
        var c = r.getTextureType(this.properties.precision), d = this._temp_texture;
        d && d.width == a && d.height == b && d.type == c || (d = this._temp_texture = new GL.Texture(a, b, {type:c, format:gl.RGB, filter:gl.LINEAR}));
        c = a + b + c + this.properties.persistence + this.properties.octaves + this.properties.scale + this.properties.seed + this.properties.offset[0] + this.properties.offset[1] + this.properties.amplitude;
        if (c != this._key) {
          this._key = c;
          var e = this._uniforms;
          e.u_persistence = this.properties.persistence;
          e.u_octaves = this.properties.octaves;
          e.u_offset[0] = this.properties.offset[0];
          e.u_offset[1] = this.properties.offset[1];
          e.u_scale = this.properties.scale;
          e.u_amplitude = this.properties.amplitude;
          e.u_viewport[0] = a;
          e.u_viewport[1] = b;
          e.u_seed = 128 * this.properties.seed;
          var g = t._shader;
          g || (g = t._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, t.pixel_shader));
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          d.drawTo(function() {
            g.uniforms(e).draw(GL.Mesh.getScreenQuad());
          });
        }
        this.setOutputData(0, d);
      }
    };
    t.pixel_shader = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform vec2 u_offset;\n\r\n\t\t\tuniform float u_scale;\n\r\n\t\t\tuniform float u_persistence;\n\r\n\t\t\tuniform int u_octaves;\n\r\n\t\t\tuniform float u_amplitude;\n\r\n\t\t\tuniform vec2 u_viewport;\n\r\n\t\t\tuniform float u_seed;\n\r\n\t\t\t#define M_PI 3.14159265358979323846\n\r\n\t\t\t\n\r\n\t\t\tfloat rand(vec2 c){\treturn fract(sin(dot(c.xy ,vec2( 12.9898 + u_seed,78.233 + u_seed))) * 43758.5453); }\n\r\n\t\t\t\n\r\n\t\t\tfloat noise(vec2 p, float freq ){\n\r\n\t\t\t\tfloat unit = u_viewport.x/freq;\n\r\n\t\t\t\tvec2 ij = floor(p/unit);\n\r\n\t\t\t\tvec2 xy = mod(p,unit)/unit;\n\r\n\t\t\t\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\r\n\t\t\t\txy = .5*(1.-cos(M_PI*xy));\n\r\n\t\t\t\tfloat a = rand((ij+vec2(0.,0.)));\n\r\n\t\t\t\tfloat b = rand((ij+vec2(1.,0.)));\n\r\n\t\t\t\tfloat c = rand((ij+vec2(0.,1.)));\n\r\n\t\t\t\tfloat d = rand((ij+vec2(1.,1.)));\n\r\n\t\t\t\tfloat x1 = mix(a, b, xy.x);\n\r\n\t\t\t\tfloat x2 = mix(c, d, xy.x);\n\r\n\t\t\t\treturn mix(x1, x2, xy.y);\n\r\n\t\t\t}\n\r\n\t\t\t\n\r\n\t\t\tfloat pNoise(vec2 p, int res){\n\r\n\t\t\t\tfloat persistance = u_persistence;\n\r\n\t\t\t\tfloat n = 0.;\n\r\n\t\t\t\tfloat normK = 0.;\n\r\n\t\t\t\tfloat f = 4.;\n\r\n\t\t\t\tfloat amp = 1.0;\n\r\n\t\t\t\tint iCount = 0;\n\r\n\t\t\t\tfor (int i = 0; i<50; i++){\n\r\n\t\t\t\t\tn+=amp*noise(p, f);\n\r\n\t\t\t\t\tf*=2.;\n\r\n\t\t\t\t\tnormK+=amp;\n\r\n\t\t\t\t\tamp*=persistance;\n\r\n\t\t\t\t\tif (iCount >= res)\n\r\n\t\t\t\t\t\tbreak;\n\r\n\t\t\t\t\tiCount++;\n\r\n\t\t\t\t}\n\r\n\t\t\t\tfloat nf = n/normK;\n\r\n\t\t\t\treturn nf*nf*nf*nf;\n\r\n\t\t\t}\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 uv = v_coord * u_scale * u_viewport + u_offset * u_scale;\n\r\n\t\t\t\tvec4 color = vec4( pNoise( uv, u_octaves ) * u_amplitude );\n\r\n\t\t\t\tgl_FragColor = color;\n\r\n\t\t\t}";
    f.registerNodeType("texture/perlin", t);
    d.title = "Canvas2D";
    d.desc = "Executes Canvas2D code inside a texture or the viewport";
    d.widgets_info = {precision:{widget:"combo", values:r.MODE_VALUES}, code:{type:"code"}, width:{type:"Number", precision:0, step:1}, height:{type:"Number", precision:0, step:1}};
    d.prototype.onPropertyChanged = function(a, b) {
      if ("code" == a && f.allow_scripts) {
        this._func = null;
        try {
          this._func = new Function("canvas", "ctx", "time", "script", b), this.boxcolor = "#00FF00";
        } catch (M) {
          this.boxcolor = "#FF0000", console.error("Error parsing script"), console.error(M);
        }
      }
    };
    d.prototype.onExecute = function() {
      var a = this._func;
      if (a && this.isOutputConnected(0)) {
        if (v.enableWebGLCanvas) {
          var b = this.properties.width || gl.canvas.width, c = this.properties.height || gl.canvas.height, d = this._temp_texture;
          d && d.width == b && d.height == c || (d = this._temp_texture = new GL.Texture(b, c, {format:gl.RGBA, filter:gl.LINEAR}));
          var e = this, g = this.graph.getTime();
          d.drawTo(function() {
            gl.start2D();
            try {
              a.draw ? a.draw.call(e, gl.canvas, gl, g, a) : a.call(e, gl.canvas, gl, g, a), e.boxcolor = "#00FF00";
            } catch (O) {
              e.boxcolor = "#FF0000", console.error("Error executing script"), console.error(O);
            }
            gl.finish2D();
          });
          this.setOutputData(0, d);
        } else {
          console.warn("cannot use LGraphTextureCanvas2D if Canvas2DtoWebGL is not included");
        }
      }
    };
    f.registerNodeType("texture/canvas2D", d);
    q.title = "Matte";
    q.desc = "Extracts background";
    q.widgets_info = {key_color:{widget:"color"}, precision:{widget:"combo", values:r.MODE_VALUES}};
    q.prototype.onExecute = function() {
      if (this.isOutputConnected(0)) {
        var a = this.getInputData(0);
        if (this.properties.precision === r.PASS_THROUGH) {
          this.setOutputData(0, a);
        } else {
          if (a) {
            this._tex = r.getTargetTexture(a, this._tex, this.properties.precision);
            gl.disable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST);
            this._uniforms || (this._uniforms = {u_texture:0, u_key_color:this.properties.key_color, u_threshold:1, u_slope:1});
            var b = this._uniforms, c = Mesh.getScreenQuad(), d = q._shader;
            d || (d = q._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, q.pixel_shader));
            b.u_key_color = this.properties.key_color;
            b.u_threshold = this.properties.threshold;
            b.u_slope = this.properties.slope;
            this._tex.drawTo(function() {
              a.bind(0);
              d.uniforms(b).draw(c);
            });
            this.setOutputData(0, this._tex);
          }
        }
      }
    };
    q.pixel_shader = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec3 u_key_color;\n\r\n\t\t\tuniform float u_threshold;\n\r\n\t\t\tuniform float u_slope;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec3 color = texture2D( u_texture, v_coord ).xyz;\n\r\n\t\t\t\tfloat diff = length( normalize(color) - normalize(u_key_color) );\n\r\n\t\t\t\tfloat edge = u_threshold * (1.0 - u_slope);\n\r\n\t\t\t\tfloat alpha = smoothstep( edge, u_threshold, diff);\n\r\n\t\t\t\tgl_FragColor = vec4( color, alpha );\n\r\n\t\t\t}";
    f.registerNodeType("texture/matte", q);
    k.title = "Cubemap";
    k.prototype.onDropFile = function(a, b, c) {
      a ? (this._drop_texture = "string" == typeof a ? GL.Texture.fromURL(a) : GL.Texture.fromDDSInMemory(a), this.properties.name = b) : (this._drop_texture = null, this.properties.name = "");
    };
    k.prototype.onExecute = function() {
      if (this._drop_texture) {
        this.setOutputData(0, this._drop_texture);
      } else {
        if (this.properties.name) {
          var a = r.getTexture(this.properties.name);
          a && (this._last_tex = a, this.setOutputData(0, a));
        }
      }
    };
    k.prototype.onDrawBackground = function(a) {
      this.flags.collapsed || 20 >= this.size[1] || !a.webgl || gl.meshes.cube || (gl.meshes.cube = GL.Mesh.cube({size:1}));
    };
    f.registerNodeType("texture/cubemap", k);
  }
})(this);
(function(v) {
  var f = v.LiteGraph;
  if ("undefined" != typeof GL) {
    var k = function() {
      this.addInput("Tex.", "Texture");
      this.addInput("intensity", "number");
      this.addOutput("Texture", "Texture");
      this.properties = {intensity:1, invert:!1, precision:LGraphTexture.DEFAULT};
      k._shader || (k._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, k.pixel_shader));
    }, q = function() {
      this.addInput("Texture", "Texture");
      this.addInput("value1", "number");
      this.addInput("value2", "number");
      this.addOutput("Texture", "Texture");
      this.properties = {fx:"halftone", value1:1, value2:1, precision:LGraphTexture.DEFAULT};
    }, d = function() {
      this.addInput("Texture", "Texture");
      this.addInput("Blurred", "Texture");
      this.addInput("Mask", "Texture");
      this.addInput("Threshold", "number");
      this.addOutput("Texture", "Texture");
      this.properties = {shape:"", size:10, alpha:1.0, threshold:1.0, high_precision:!1};
    }, t = function() {
      this.addInput("Texture", "Texture");
      this.addInput("Aberration", "number");
      this.addInput("Distortion", "number");
      this.addInput("Blur", "number");
      this.addOutput("Texture", "Texture");
      this.properties = {aberration:1.0, distortion:1.0, blur:1.0, precision:LGraphTexture.DEFAULT};
      t._shader || (t._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, t.pixel_shader), t._texture = new GL.Texture(3, 1, {format:gl.RGB, wrap:gl.CLAMP_TO_EDGE, magFilter:gl.LINEAR, minFilter:gl.LINEAR, pixel_data:[255, 0, 0, 0, 255, 0, 0, 0, 255]}));
    };
    t.title = "Lens";
    t.desc = "Camera Lens distortion";
    t.widgets_info = {precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
    t.prototype.onExecute = function() {
      var d = this.getInputData(0);
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, d);
      } else {
        if (d) {
          this._tex = LGraphTexture.getTargetTexture(d, this._tex, this.properties.precision);
          var f = this.properties.aberration;
          this.isInputConnected(1) && (f = this.getInputData(1), this.properties.aberration = f);
          var k = this.properties.distortion;
          this.isInputConnected(2) && (k = this.getInputData(2), this.properties.distortion = k);
          var h = this.properties.blur;
          this.isInputConnected(3) && (h = this.getInputData(3), this.properties.blur = h);
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          var m = Mesh.getScreenQuad(), b = t._shader;
          this._tex.drawTo(function() {
            d.bind(0);
            b.uniforms({u_texture:0, u_aberration:f, u_distortion:k, u_blur:h}).draw(m);
          });
          this.setOutputData(0, this._tex);
        }
      }
    };
    t.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform float u_aberration;\n\r\n\t\t\tuniform float u_distortion;\n\r\n\t\t\tuniform float u_blur;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 coord = v_coord;\n\r\n\t\t\t\tfloat dist = distance(vec2(0.5), coord);\n\r\n\t\t\t\tvec2 dist_coord = coord - vec2(0.5);\n\r\n\t\t\t\tfloat percent = 1.0 + ((0.5 - dist) / 0.5) * u_distortion;\n\r\n\t\t\t\tdist_coord *= percent;\n\r\n\t\t\t\tcoord = dist_coord + vec2(0.5);\n\r\n\t\t\t\tvec4 color = texture2D(u_texture,coord, u_blur * dist);\n\r\n\t\t\t\tcolor.r = texture2D(u_texture,vec2(0.5) + dist_coord * (1.0+0.01*u_aberration), u_blur * dist ).r;\n\r\n\t\t\t\tcolor.b = texture2D(u_texture,vec2(0.5) + dist_coord * (1.0-0.01*u_aberration), u_blur * dist ).b;\n\r\n\t\t\t\tgl_FragColor = color;\n\r\n\t\t\t}\n\r\n\t\t\t";
    f.registerNodeType("fx/lens", t);
    v.LGraphFXLens = t;
    d.title = "Bokeh";
    d.desc = "applies an Bokeh effect";
    d.widgets_info = {shape:{widget:"texture"}};
    d.prototype.onExecute = function() {
      var f = this.getInputData(0), k = this.getInputData(1), q = this.getInputData(2);
      if (f && q && this.properties.shape) {
        k || (k = f);
        var h = LGraphTexture.getTexture(this.properties.shape);
        if (h) {
          var m = this.properties.threshold;
          this.isInputConnected(3) && (m = this.getInputData(3), this.properties.threshold = m);
          var b = gl.UNSIGNED_BYTE;
          this.properties.high_precision && (b = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT);
          this._temp_texture && this._temp_texture.type == b && this._temp_texture.width == f.width && this._temp_texture.height == f.height || (this._temp_texture = new GL.Texture(f.width, f.height, {type:b, format:gl.RGBA, filter:gl.LINEAR}));
          var p = d._first_shader;
          p || (p = d._first_shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, d._first_pixel_shader));
          var a = d._second_shader;
          a || (a = d._second_shader = new GL.Shader(d._second_vertex_shader, d._second_pixel_shader));
          var c = this._points_mesh;
          c && c._width == f.width && c._height == f.height && 2 == c._spacing || (c = this.createPointsMesh(f.width, f.height, 2));
          var e = Mesh.getScreenQuad(), t = this.properties.size, g = this.properties.alpha;
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.BLEND);
          this._temp_texture.drawTo(function() {
            f.bind(0);
            k.bind(1);
            q.bind(2);
            p.uniforms({u_texture:0, u_texture_blur:1, u_mask:2, u_texsize:[f.width, f.height]}).draw(e);
          });
          this._temp_texture.drawTo(function() {
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.ONE, gl.ONE);
            f.bind(0);
            h.bind(3);
            a.uniforms({u_texture:0, u_mask:2, u_shape:3, u_alpha:g, u_threshold:m, u_pointSize:t, u_itexsize:[1.0 / f.width, 1.0 / f.height]}).draw(c, gl.POINTS);
          });
          this.setOutputData(0, this._temp_texture);
        }
      } else {
        this.setOutputData(0, f);
      }
    };
    d.prototype.createPointsMesh = function(d, f, k) {
      for (var h = Math.round(d / k), m = Math.round(f / k), b = new Float32Array(h * m * 2), p = -1, a = 2 / d * k, c = 2 / f * k, e = 0; e < m; ++e) {
        for (var q = -1, g = 0; g < h; ++g) {
          var l = e * h * 2 + 2 * g;
          b[l] = q;
          b[l + 1] = p;
          q += a;
        }
        p += c;
      }
      this._points_mesh = GL.Mesh.load({vertices2D:b});
      this._points_mesh._width = d;
      this._points_mesh._height = f;
      this._points_mesh._spacing = k;
      return this._points_mesh;
    };
    d._first_pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_texture_blur;\n\r\n\t\t\tuniform sampler2D u_mask;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tvec4 blurred_color = texture2D(u_texture_blur, v_coord);\n\r\n\t\t\t\tfloat mask = texture2D(u_mask, v_coord).x;\n\r\n\t\t\t   gl_FragColor = mix(color, blurred_color, mask);\n\r\n\t\t\t}\n\r\n\t\t\t";
    d._second_vertex_shader = "precision highp float;\n\r\n\t\t\tattribute vec2 a_vertex2D;\n\r\n\t\t\tvarying vec4 v_color;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_mask;\n\r\n\t\t\tuniform vec2 u_itexsize;\n\r\n\t\t\tuniform float u_pointSize;\n\r\n\t\t\tuniform float u_threshold;\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 coord = a_vertex2D * 0.5 + 0.5;\n\r\n\t\t\t\tv_color = texture2D( u_texture, coord );\n\r\n\t\t\t\tv_color += texture2D( u_texture, coord + vec2(u_itexsize.x, 0.0) );\n\r\n\t\t\t\tv_color += texture2D( u_texture, coord + vec2(0.0, u_itexsize.y));\n\r\n\t\t\t\tv_color += texture2D( u_texture, coord + u_itexsize);\n\r\n\t\t\t\tv_color *= 0.25;\n\r\n\t\t\t\tfloat mask = texture2D(u_mask, coord).x;\n\r\n\t\t\t\tfloat luminance = length(v_color) * mask;\n\r\n\t\t\t\t/*luminance /= (u_pointSize*u_pointSize)*0.01 */;\n\r\n\t\t\t\tluminance -= u_threshold;\n\r\n\t\t\t\tif(luminance < 0.0)\n\r\n\t\t\t\t{\n\r\n\t\t\t\t\tgl_Position.x = -100.0;\n\r\n\t\t\t\t\treturn;\n\r\n\t\t\t\t}\n\r\n\t\t\t\tgl_PointSize = u_pointSize;\n\r\n\t\t\t\tgl_Position = vec4(a_vertex2D,0.0,1.0);\n\r\n\t\t\t}\n\r\n\t\t\t";
    d._second_pixel_shader = "precision highp float;\n\r\n\t\t\tvarying vec4 v_color;\n\r\n\t\t\tuniform sampler2D u_shape;\n\r\n\t\t\tuniform float u_alpha;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D( u_shape, gl_PointCoord );\n\r\n\t\t\t\tcolor *= v_color * u_alpha;\n\r\n\t\t\t\tgl_FragColor = color;\n\r\n\t\t\t}\n";
    f.registerNodeType("fx/bokeh", d);
    v.LGraphFXBokeh = d;
    q.title = "FX";
    q.desc = "applies an FX from a list";
    q.widgets_info = {fx:{widget:"combo", values:["halftone", "pixelate", "lowpalette", "noise", "gamma"]}, precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
    q.shaders = {};
    q.prototype.onExecute = function() {
      if (this.isOutputConnected(0)) {
        var d = this.getInputData(0);
        if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
          this.setOutputData(0, d);
        } else {
          if (d) {
            this._tex = LGraphTexture.getTargetTexture(d, this._tex, this.properties.precision);
            var f = this.properties.value1;
            this.isInputConnected(1) && (f = this.getInputData(1), this.properties.value1 = f);
            var k = this.properties.value2;
            this.isInputConnected(2) && (k = this.getInputData(2), this.properties.value2 = k);
            var h = this.properties.fx, m = q.shaders[h];
            if (!m) {
              var b = q["pixel_shader_" + h];
              if (!b) {
                return;
              }
              m = q.shaders[h] = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, b);
            }
            gl.disable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST);
            var p = Mesh.getScreenQuad();
            camera_planes = v.LS && LS.Renderer._current_camera ? [LS.Renderer._current_camera.near, LS.Renderer._current_camera.far] : [1, 100];
            var a = null;
            "noise" == h && (a = LGraphTexture.getNoiseTexture());
            this._tex.drawTo(function() {
              d.bind(0);
              "noise" == h && a.bind(1);
              m.uniforms({u_texture:0, u_noise:1, u_size:[d.width, d.height], u_rand:[Math.random(), Math.random()], u_value1:f, u_value2:k, u_camera_planes:camera_planes}).draw(p);
            });
            this.setOutputData(0, this._tex);
          }
        }
      }
    };
    q.pixel_shader_halftone = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform vec2 u_size;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\tuniform float u_value2;\n\r\n\t\t\t\n\r\n\t\t\tfloat pattern() {\n\r\n\t\t\t\tfloat s = sin(u_value1 * 3.1415), c = cos(u_value1 * 3.1415);\n\r\n\t\t\t\tvec2 tex = v_coord * u_size.xy;\n\r\n\t\t\t\tvec2 point = vec2(\n\r\n\t\t\t\t   c * tex.x - s * tex.y ,\n\r\n\t\t\t\t   s * tex.x + c * tex.y \n\r\n\t\t\t\t) * u_value2;\n\r\n\t\t\t\treturn (sin(point.x) * sin(point.y)) * 4.0;\n\r\n\t\t\t}\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tfloat average = (color.r + color.g + color.b) / 3.0;\n\r\n\t\t\t\tgl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n\r\n\t\t\t}\n";
    q.pixel_shader_pixelate = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform vec2 u_size;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\tuniform float u_value2;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 coord = vec2( floor(v_coord.x * u_value1) / u_value1, floor(v_coord.y * u_value2) / u_value2 );\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, coord);\n\r\n\t\t\t\tgl_FragColor = color;\n\r\n\t\t\t}\n";
    q.pixel_shader_lowpalette = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform vec2 u_size;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\tuniform float u_value2;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tgl_FragColor = floor(color * u_value1) / u_value1;\n\r\n\t\t\t}\n";
    q.pixel_shader_noise = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_noise;\n\r\n\t\t\tuniform vec2 u_size;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\tuniform float u_value2;\n\r\n\t\t\tuniform vec2 u_rand;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tvec3 noise = texture2D(u_noise, v_coord * vec2(u_size.x / 512.0, u_size.y / 512.0) + u_rand).xyz - vec3(0.5);\n\r\n\t\t\t\tgl_FragColor = vec4( color.xyz + noise * u_value1, color.a );\n\r\n\t\t\t}\n";
    q.pixel_shader_gamma = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tfloat gamma = 1.0 / u_value1;\n\r\n\t\t\t\tgl_FragColor = vec4( pow( color.xyz, vec3(gamma) ), color.a );\n\r\n\t\t\t}\n";
    f.registerNodeType("fx/generic", q);
    v.LGraphFXGeneric = q;
    k.title = "Vigneting";
    k.desc = "Vigneting";
    k.widgets_info = {precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
    k.prototype.onExecute = function() {
      var d = this.getInputData(0);
      if (this.properties.precision === LGraphTexture.PASS_THROUGH) {
        this.setOutputData(0, d);
      } else {
        if (d) {
          this._tex = LGraphTexture.getTargetTexture(d, this._tex, this.properties.precision);
          var f = this.properties.intensity;
          this.isInputConnected(1) && (f = this.getInputData(1), this.properties.intensity = f);
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          var q = Mesh.getScreenQuad(), h = k._shader, m = this.properties.invert;
          this._tex.drawTo(function() {
            d.bind(0);
            h.uniforms({u_texture:0, u_intensity:f, u_isize:[1 / d.width, 1 / d.height], u_invert:m ? 1 : 0}).draw(q);
          });
          this.setOutputData(0, this._tex);
        }
      }
    };
    k.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform float u_intensity;\n\r\n\t\t\tuniform int u_invert;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tfloat luminance = 1.0 - length( v_coord - vec2(0.5) ) * 1.414;\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tif(u_invert == 1)\n\r\n\t\t\t\t\tluminance = 1.0 - luminance;\n\r\n\t\t\t\tluminance = mix(1.0, luminance, u_intensity);\n\r\n\t\t\t   gl_FragColor = vec4( luminance * color.xyz, color.a);\n\r\n\t\t\t}\n\r\n\t\t\t";
    f.registerNodeType("fx/vigneting", k);
    v.LGraphFXVigneting = k;
  }
})(this);
(function(v) {
  function f(d) {
    this.cmd = this.channel = 0;
    d ? this.setup(d) : this.data = [0, 0, 0];
  }
  function k(d, b) {
    navigator.requestMIDIAccess ? (this.on_ready = d, this.state = {note:[], cc:[]}, navigator.requestMIDIAccess().then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this))) : (this.error = "not suppoorted", b ? b("Not supported") : console.error("MIDI NOT SUPPORTED, enable by chrome://flags"));
  }
  function q() {
    this.addOutput("on_midi", h.EVENT);
    this.addOutput("out", "midi");
    this.properties = {port:0};
    this._current_midi_event = this._last_midi_event = null;
    var d = this;
    new k(function(b) {
      d._midi = b;
      if (d._waiting) {
        d.onStart();
      }
      d._waiting = !1;
    });
  }
  function d() {
    this.addInput("send", h.EVENT);
    this.properties = {port:0};
    var d = this;
    new k(function(b) {
      d._midi = b;
    });
  }
  function t() {
    this.addInput("on_midi", h.EVENT);
    this._str = "";
    this.size = [200, 40];
  }
  function u() {
    this.properties = {channel:-1, cmd:-1, min_value:-1, max_value:-1};
    this.addInput("in", h.EVENT);
    this.addOutput("on_midi", h.EVENT);
  }
  function x() {
    this.properties = {channel:0, cmd:"CC", value1:1, value2:1};
    this.addInput("send", h.EVENT);
    this.addInput("assign", h.EVENT);
    this.addOutput("on_midi", h.EVENT);
  }
  function w() {
    this.properties = {cc:1, value:0};
    this.addOutput("value", "number");
  }
  var h = v.LiteGraph;
  f.prototype.setup = function(d) {
    this.data = d;
    this.status = d = d[0];
    var b = d & 240;
    this.cmd = 240 <= d ? d : b;
    this.cmd == f.NOTEON && 0 == this.velocity && (this.cmd = f.NOTEOFF);
    this.cmd_str = f.commands[this.cmd] || "";
    if (b >= f.NOTEON || b <= f.NOTEOFF) {
      this.channel = d & 15;
    }
  };
  Object.defineProperty(f.prototype, "velocity", {get:function() {
    return this.cmd == f.NOTEON ? this.data[2] : -1;
  }, set:function(d) {
    this.data[2] = d;
  }, enumerable:!0});
  f.notes = "A A# B C C# D D# E F F# G G#".split(" ");
  f.prototype.getPitch = function() {
    return 440 * Math.pow(2, (this.data[1] - 69) / 12);
  };
  f.computePitch = function(d) {
    return 440 * Math.pow(2, (d - 69) / 12);
  };
  f.prototype.getCC = function() {
    return this.data[1];
  };
  f.prototype.getCCValue = function() {
    return this.data[2];
  };
  f.prototype.getPitchBend = function() {
    return this.data[1] + (this.data[2] << 7) - 8192;
  };
  f.computePitchBend = function(d, b) {
    return d + (b << 7) - 8192;
  };
  f.prototype.setCommandFromString = function(d) {
    this.cmd = f.computeCommandFromString(d);
  };
  f.computeCommandFromString = function(d) {
    if (!d) {
      return 0;
    }
    if (d && d.constructor === Number) {
      return d;
    }
    d = d.toUpperCase();
    switch(d) {
      case "NOTE ON":
      case "NOTEON":
        return f.NOTEON;
      case "NOTE OFF":
      case "NOTEOFF":
        return f.NOTEON;
      case "KEY PRESSURE":
      case "KEYPRESSURE":
        return f.KEYPRESSURE;
      case "CONTROLLER CHANGE":
      case "CONTROLLERCHANGE":
      case "CC":
        return f.CONTROLLERCHANGE;
      case "PROGRAM CHANGE":
      case "PROGRAMCHANGE":
      case "PC":
        return f.PROGRAMCHANGE;
      case "CHANNEL PRESSURE":
      case "CHANNELPRESSURE":
        return f.CHANNELPRESSURE;
      case "PITCH BEND":
      case "PITCHBEND":
        return f.PITCHBEND;
      case "TIME TICK":
      case "TIMETICK":
        return f.TIMETICK;
      default:
        return Number(d);
    }
  };
  f.toNoteString = function(d) {
    var b = (d - 21) % 12;
    0 > b && (b = 12 + b);
    return f.notes[b] + Math.floor((d - 24) / 12 + 1);
  };
  f.prototype.toString = function() {
    var d = "" + this.channel + ". ";
    switch(this.cmd) {
      case f.NOTEON:
        d += "NOTEON " + f.toNoteString(this.data[1]);
        break;
      case f.NOTEOFF:
        d += "NOTEOFF " + f.toNoteString(this.data[1]);
        break;
      case f.CONTROLLERCHANGE:
        d += "CC " + this.data[1] + " " + this.data[2];
        break;
      case f.PROGRAMCHANGE:
        d += "PC " + this.data[1];
        break;
      case f.PITCHBEND:
        d += "PITCHBEND " + this.getPitchBend();
        break;
      case f.KEYPRESSURE:
        d += "KEYPRESS " + this.data[1];
    }
    return d;
  };
  f.prototype.toHexString = function() {
    for (var d = "", b = 0; b < this.data.length; b++) {
      d += this.data[b].toString(16) + " ";
    }
  };
  f.NOTEOFF = 128;
  f.NOTEON = 144;
  f.KEYPRESSURE = 160;
  f.CONTROLLERCHANGE = 176;
  f.PROGRAMCHANGE = 192;
  f.CHANNELPRESSURE = 208;
  f.PITCHBEND = 224;
  f.TIMETICK = 248;
  f.commands = {128:"note off", 144:"note on", 160:"key pressure", 176:"controller change", 192:"program change", 208:"channel pressure", 224:"pitch bend", 240:"system", 242:"Song pos", 243:"Song select", 246:"Tune request", 248:"time tick", 250:"Start Song", 251:"Continue Song", 252:"Stop Song", 254:"Sensing", 255:"Reset"};
  k.input = null;
  k.MIDIEvent = f;
  k.prototype.onMIDISuccess = function(d) {
    console.log("MIDI ready!");
    console.log(d);
    this.midi = d;
    this.updatePorts();
    if (this.on_ready) {
      this.on_ready(this);
    }
  };
  k.prototype.updatePorts = function() {
    var d = this.midi;
    this.input_ports = d.inputs;
    for (var b = 0, f = this.input_ports.values(), a = f.next(); a && !1 === a.done;) {
      a = a.value, console.log("Input port [type:'" + a.type + "'] id:'" + a.id + "' manufacturer:'" + a.manufacturer + "' name:'" + a.name + "' version:'" + a.version + "'"), b++, a = f.next();
    }
    this.num_input_ports = b;
    b = 0;
    this.output_ports = d.outputs;
    f = this.output_ports.values();
    for (a = f.next(); a && !1 === a.done;) {
      a = a.value, console.log("Output port [type:'" + a.type + "'] id:'" + a.id + "' manufacturer:'" + a.manufacturer + "' name:'" + a.name + "' version:'" + a.version + "'"), b++, a = f.next();
    }
    this.num_output_ports = b;
  };
  k.prototype.onMIDIFailure = function(d) {
    console.error("Failed to get MIDI access - " + d);
  };
  k.prototype.openInputPort = function(d, b) {
    d = this.input_ports.get("input-" + d);
    if (!d) {
      return !1;
    }
    k.input = this;
    var h = this;
    d.onmidimessage = function(a) {
      var c = new f(a.data);
      h.updateState(c);
      b && b(a.data, c);
      if (k.on_message) {
        k.on_message(a.data, c);
      }
    };
    console.log("port open: ", d);
    return !0;
  };
  k.parseMsg = function(d) {
  };
  k.prototype.updateState = function(d) {
    switch(d.cmd) {
      case f.NOTEON:
        this.state.note[d.value1 | 0] = d.value2;
        break;
      case f.NOTEOFF:
        this.state.note[d.value1 | 0] = 0;
        break;
      case f.CONTROLLERCHANGE:
        this.state.cc[d.getCC()] = d.getCCValue();
    }
  };
  k.prototype.sendMIDI = function(d, b) {
    b && (d = this.output_ports.get("output-" + d)) && (k.output = this, b.constructor === f ? d.send(b.data) : d.send(b));
  };
  q.MIDIInterface = k;
  q.title = "MIDI Input";
  q.desc = "Reads MIDI from a input port";
  q.prototype.getPropertyInfo = function(d) {
    if (this._midi && "port" == d) {
      d = {};
      for (var b = 0; b < this._midi.input_ports.size; ++b) {
        var f = this._midi.input_ports.get("input-" + b);
        d[b] = b + ".- " + f.name + " version:" + f.version;
      }
      return {type:"enum", values:d};
    }
  };
  q.prototype.onStart = function() {
    this._midi ? this._midi.openInputPort(this.properties.port, this.onMIDIEvent.bind(this)) : this._waiting = !0;
  };
  q.prototype.onMIDIEvent = function(d, b) {
    this._last_midi_event = b;
    this.trigger("on_midi", b);
    b.cmd == f.NOTEON ? this.trigger("on_noteon", b) : b.cmd == f.NOTEOFF ? this.trigger("on_noteoff", b) : b.cmd == f.CONTROLLERCHANGE ? this.trigger("on_cc", b) : b.cmd == f.PROGRAMCHANGE ? this.trigger("on_pc", b) : b.cmd == f.PITCHBEND && this.trigger("on_pitchbend", b);
  };
  q.prototype.onExecute = function() {
    if (this.outputs) {
      for (var d = this._last_midi_event, b = 0; b < this.outputs.length; ++b) {
        switch(this.outputs[b].name) {
          case "midi":
            var f = this._midi;
            break;
          case "last_midi":
            f = d;
            break;
          default:
            continue;
        }
        this.setOutputData(b, f);
      }
    }
  };
  q.prototype.onGetOutputs = function() {
    return [["last_midi", "midi"], ["on_midi", h.EVENT], ["on_noteon", h.EVENT], ["on_noteoff", h.EVENT], ["on_cc", h.EVENT], ["on_pc", h.EVENT], ["on_pitchbend", h.EVENT]];
  };
  h.registerNodeType("midi/input", q);
  d.MIDIInterface = k;
  d.title = "MIDI Output";
  d.desc = "Sends MIDI to output channel";
  d.prototype.getPropertyInfo = function(d) {
    if (this._midi && "port" == d) {
      d = {};
      for (var b = 0; b < this._midi.output_ports.size; ++b) {
        var f = this._midi.output_ports.get(b);
        d[b] = b + ".- " + f.name + " version:" + f.version;
      }
      return {type:"enum", values:d};
    }
  };
  d.prototype.onAction = function(d, b) {
    console.log(b);
    this._midi && ("send" == d && this._midi.sendMIDI(this.port, b), this.trigger("midi", b));
  };
  d.prototype.onGetInputs = function() {
    return [["send", h.ACTION]];
  };
  d.prototype.onGetOutputs = function() {
    return [["on_midi", h.EVENT]];
  };
  h.registerNodeType("midi/output", d);
  t.title = "MIDI Show";
  t.desc = "Shows MIDI in the graph";
  t.prototype.onAction = function(d, b) {
    b && (this._str = b.constructor === f ? b.toString() : "???");
  };
  t.prototype.onDrawForeground = function(d) {
    this._str && (d.font = "30px Arial", d.fillText(this._str, 10, 0.8 * this.size[1]));
  };
  t.prototype.onGetInputs = function() {
    return [["in", h.ACTION]];
  };
  t.prototype.onGetOutputs = function() {
    return [["on_midi", h.EVENT]];
  };
  h.registerNodeType("midi/show", t);
  u.title = "MIDI Filter";
  u.desc = "Filters MIDI messages";
  u.prototype.onAction = function(d, b) {
    !b || b.constructor !== f || -1 != this.properties.channel && b.channel != this.properties.channel || -1 != this.properties.cmd && b.cmd != this.properties.cmd || -1 != this.properties.min_value && b.data[1] < this.properties.min_value || -1 != this.properties.max_value && b.data[1] > this.properties.max_value || this.trigger("on_midi", b);
  };
  h.registerNodeType("midi/filter", u);
  x.title = "MIDIEvent";
  x.desc = "Create a MIDI Event";
  x.prototype.onAction = function(d, b) {
    "assign" == d ? (this.properties.channel = b.channel, this.properties.cmd = b.cmd, this.properties.value1 = b.data[1], this.properties.value2 = b.data[2]) : (b = new f, b.channel = this.properties.channel, this.properties.cmd && this.properties.cmd.constructor === String ? b.setCommandFromString(this.properties.cmd) : b.cmd = this.properties.cmd, b.data[0] = b.cmd | b.channel, b.data[1] = Number(this.properties.value1), b.data[2] = Number(this.properties.value2), this.trigger("on_midi", b));
  };
  x.prototype.onExecute = function() {
    var d = this.properties;
    if (this.outputs) {
      for (var b = 0; b < this.outputs.length; ++b) {
        switch(this.outputs[b].name) {
          case "midi":
            var h = new f;
            h.setup([d.cmd, d.value1, d.value2]);
            h.channel = d.channel;
            break;
          case "command":
            h = d.cmd;
            break;
          case "cc":
            h = d.value1;
            break;
          case "cc_value":
            h = d.value2;
            break;
          case "note":
            h = d.cmd == f.NOTEON || d.cmd == f.NOTEOFF ? d.value1 : null;
            break;
          case "velocity":
            h = d.cmd == f.NOTEON ? d.value2 : null;
            break;
          case "pitch":
            h = d.cmd == f.NOTEON ? f.computePitch(d.value1) : null;
            break;
          case "pitchbend":
            h = d.cmd == f.PITCHBEND ? f.computePitchBend(d.value1, d.value2) : null;
            break;
          default:
            continue;
        }
        null !== h && this.setOutputData(b, h);
      }
    }
  };
  x.prototype.onPropertyChanged = function(d, b) {
    "cmd" == d && (this.properties.cmd = f.computeCommandFromString(b));
  };
  x.prototype.onGetOutputs = function() {
    return [["midi", "midi"], ["on_midi", h.EVENT], ["command", "number"], ["note", "number"], ["velocity", "number"], ["cc", "number"], ["cc_value", "number"], ["pitch", "number"], ["pitchbend", "number"]];
  };
  h.registerNodeType("midi/event", x);
  w.title = "MIDICC";
  w.desc = "gets a Controller Change";
  w.prototype.onExecute = function() {
    k.input && (this.properties.value = k.input.state.cc[this.properties.cc]);
    this.setOutputData(0, this.properties.value);
  };
  h.registerNodeType("midi/cc", w);
})(this);
(function(v) {
  function f() {
    this.properties = {src:"", gain:0.5, loop:!0, autoplay:!0, playbackRate:1};
    this._loading_audio = !1;
    this._audiobuffer = null;
    this._audionodes = [];
    this._last_sourcenode = null;
    this.addOutput("out", "audio");
    this.addInput("gain", "number");
    this.audionode = g.getAudioContext().createGain();
    this.audionode.graphnode = this;
    this.audionode.gain.value = this.properties.gain;
    this.properties.src && this.loadSound(this.properties.src);
  }
  function k() {
    this.properties = {gain:0.5};
    this._audionodes = [];
    this._media_stream = null;
    this.addOutput("out", "audio");
    this.addInput("gain", "number");
    this.audionode = g.getAudioContext().createGain();
    this.audionode.graphnode = this;
    this.audionode.gain.value = this.properties.gain;
  }
  function q() {
    this.properties = {fftSize:2048, minDecibels:-100, maxDecibels:-10, smoothingTimeConstant:0.5};
    this.audionode = g.getAudioContext().createAnalyser();
    this.audionode.graphnode = this;
    this.audionode.fftSize = this.properties.fftSize;
    this.audionode.minDecibels = this.properties.minDecibels;
    this.audionode.maxDecibels = this.properties.maxDecibels;
    this.audionode.smoothingTimeConstant = this.properties.smoothingTimeConstant;
    this.addInput("in", "audio");
    this.addOutput("freqs", "array");
    this.addOutput("samples", "array");
    this._time_bin = this._freq_bin = null;
  }
  function d() {
    this.properties = {gain:1};
    this.audionode = g.getAudioContext().createGain();
    this.addInput("in", "audio");
    this.addInput("gain", "number");
    this.addOutput("out", "audio");
  }
  function t() {
    this.properties = {impulse_src:"", normalize:!0};
    this.audionode = g.getAudioContext().createConvolver();
    this.addInput("in", "audio");
    this.addOutput("out", "audio");
  }
  function u() {
    this.properties = {threshold:-50, knee:40, ratio:12, reduction:-20, attack:0, release:0.25};
    this.audionode = g.getAudioContext().createDynamicsCompressor();
    this.addInput("in", "audio");
    this.addOutput("out", "audio");
  }
  function x() {
    this.properties = {};
    this.audionode = g.getAudioContext().createWaveShaper();
    this.addInput("in", "audio");
    this.addInput("shape", "waveshape");
    this.addOutput("out", "audio");
  }
  function w() {
    this.properties = {gain1:0.5, gain2:0.5};
    this.audionode = g.getAudioContext().createGain();
    this.audionode1 = g.getAudioContext().createGain();
    this.audionode1.gain.value = this.properties.gain1;
    this.audionode2 = g.getAudioContext().createGain();
    this.audionode2.gain.value = this.properties.gain2;
    this.audionode1.connect(this.audionode);
    this.audionode2.connect(this.audionode);
    this.addInput("in1", "audio");
    this.addInput("in1 gain", "number");
    this.addInput("in2", "audio");
    this.addInput("in2 gain", "number");
    this.addOutput("out", "audio");
  }
  function h() {
    this.properties = {delayTime:0.5};
    this.audionode = g.getAudioContext().createDelay(10);
    this.audionode.delayTime.value = this.properties.delayTime;
    this.addInput("in", "audio");
    this.addInput("time", "number");
    this.addOutput("out", "audio");
  }
  function m() {
    this.properties = {frequency:350, detune:0, Q:1};
    this.addProperty("type", "lowpass", "enum", {values:"lowpass highpass bandpass lowshelf highshelf peaking notch allpass".split(" ")});
    this.audionode = g.getAudioContext().createBiquadFilter();
    this.addInput("in", "audio");
    this.addOutput("out", "audio");
  }
  function b() {
    this.properties = {frequency:440, detune:0, type:"sine"};
    this.addProperty("type", "sine", "enum", {values:["sine", "square", "sawtooth", "triangle", "custom"]});
    this.audionode = g.getAudioContext().createOscillator();
    this.addOutput("out", "audio");
  }
  function p() {
    this.properties = {continuous:!0, mark:-1};
    this.addInput("data", "array");
    this.addInput("mark", "number");
    this.size = [300, 200];
    this._last_buffer = null;
  }
  function a() {
    this.properties = {band:440, amplitude:1};
    this.addInput("freqs", "array");
    this.addOutput("signal", "number");
  }
  function c() {
    if (!c.default_code) {
      var a = c.default_function.toString(), b = a.indexOf("{") + 1, d = a.lastIndexOf("}");
      c.default_code = a.substr(b, d - b);
    }
    this.properties = {code:c.default_code};
    a = g.getAudioContext();
    a.createScriptProcessor ? this.audionode = a.createScriptProcessor(4096, 1, 1) : (console.warn("ScriptProcessorNode deprecated"), this.audionode = a.createGain());
    this.processCode();
    c._bypass_function || (c._bypass_function = this.audionode.onaudioprocess);
    this.addInput("in", "audio");
    this.addOutput("out", "audio");
  }
  function e() {
    this.audionode = g.getAudioContext().destination;
    this.addInput("in", "audio");
  }
  var z = v.LiteGraph, g = {};
  v.LGAudio = g;
  g.getAudioContext = function() {
    if (!this._audio_context) {
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      if (!window.AudioContext) {
        return console.error("AudioContext not supported by browser"), null;
      }
      this._audio_context = new AudioContext;
      this._audio_context.onmessage = function(a) {
        console.log("msg", a);
      };
      this._audio_context.onended = function(a) {
        console.log("ended", a);
      };
      this._audio_context.oncomplete = function(a) {
        console.log("complete", a);
      };
    }
    return this._audio_context;
  };
  g.connect = function(a, b) {
    try {
      a.connect(b);
    } catch (A) {
      console.warn("LGraphAudio:", A);
    }
  };
  g.disconnect = function(a, b) {
    try {
      a.disconnect(b);
    } catch (A) {
      console.warn("LGraphAudio:", A);
    }
  };
  g.changeAllAudiosConnections = function(a, b) {
    if (a.inputs) {
      for (var c = 0; c < a.inputs.length; ++c) {
        var d = a.graph.links[a.inputs[c].link];
        if (d) {
          var e = a.graph.getNodeById(d.origin_id);
          e = e.getAudioNodeInOutputSlot ? e.getAudioNodeInOutputSlot(d.origin_slot) : e.audionode;
          d = a.getAudioNodeInInputSlot ? a.getAudioNodeInInputSlot(c) : a.audionode;
          b ? g.connect(e, d) : g.disconnect(e, d);
        }
      }
    }
    if (a.outputs) {
      for (c = 0; c < a.outputs.length; ++c) {
        for (var f = a.outputs[c], l = 0; l < f.links.length; ++l) {
          if (d = a.graph.links[f.links[l]]) {
            e = a.getAudioNodeInOutputSlot ? a.getAudioNodeInOutputSlot(c) : a.audionode;
            var h = a.graph.getNodeById(d.target_id);
            d = h.getAudioNodeInInputSlot ? h.getAudioNodeInInputSlot(d.target_slot) : h.audionode;
            b ? g.connect(e, d) : g.disconnect(e, d);
          }
        }
      }
    }
  };
  g.onConnectionsChange = function(a, b, c, d) {
    a == z.OUTPUT && (a = null, d && (a = this.graph.getNodeById(d.target_id)), a && (b = this.getAudioNodeInOutputSlot ? this.getAudioNodeInOutputSlot(b) : this.audionode, d = a.getAudioNodeInInputSlot ? a.getAudioNodeInInputSlot(d.target_slot) : a.audionode, c ? g.connect(b, d) : g.disconnect(b, d)));
  };
  g.createAudioNodeWrapper = function(a) {
    var b = a.prototype.onPropertyChanged;
    a.prototype.onPropertyChanged = function(a, c) {
      b && b.call(this, a, c);
      this.audionode && void 0 !== this.audionode[a] && (void 0 !== this.audionode[a].value ? this.audionode[a].value = c : this.audionode[a] = c);
    };
    a.prototype.onConnectionsChange = g.onConnectionsChange;
  };
  g.cached_audios = {};
  g.loadSound = function(a, b, c) {
    function d(a) {
      console.log("Audio loading sample error:", a);
      c && c(a);
    }
    if (g.cached_audios[a] && -1 == a.indexOf("blob:")) {
      b && b(g.cached_audios[a]);
    } else {
      g.onProcessAudioURL && (a = g.onProcessAudioURL(a));
      var e = new XMLHttpRequest;
      e.open("GET", a, !0);
      e.responseType = "arraybuffer";
      var f = g.getAudioContext();
      e.onload = function() {
        console.log("AudioSource loaded");
        f.decodeAudioData(e.response, function(c) {
          console.log("AudioSource decoded");
          g.cached_audios[a] = c;
          b && b(c);
        }, d);
      };
      e.send();
      return e;
    }
  };
  f["@src"] = {widget:"resource"};
  f.supported_extensions = ["wav", "ogg", "mp3"];
  f.prototype.onAdded = function(a) {
    if (a.status === LGraph.STATUS_RUNNING) {
      this.onStart();
    }
  };
  f.prototype.onStart = function() {
    this._audiobuffer && this.properties.autoplay && this.playBuffer(this._audiobuffer);
  };
  f.prototype.onStop = function() {
    this.stopAllSounds();
  };
  f.prototype.onPause = function() {
    this.pauseAllSounds();
  };
  f.prototype.onUnpause = function() {
    this.unpauseAllSounds();
  };
  f.prototype.onRemoved = function() {
    this.stopAllSounds();
    this._dropped_url && URL.revokeObjectURL(this._url);
  };
  f.prototype.stopAllSounds = function() {
    for (var a = 0; a < this._audionodes.length; ++a) {
      this._audionodes[a].started && (this._audionodes[a].started = !1, this._audionodes[a].stop());
    }
    this._audionodes.length = 0;
  };
  f.prototype.pauseAllSounds = function() {
    g.getAudioContext().suspend();
  };
  f.prototype.unpauseAllSounds = function() {
    g.getAudioContext().resume();
  };
  f.prototype.onExecute = function() {
    if (this.inputs) {
      for (var a = 0; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        if (null != b.link) {
          var c = this.getInputData(a);
          if (void 0 !== c) {
            if ("gain" == b.name) {
              this.audionode.gain.value = c;
            } else {
              if ("playbackRate" == b.name) {
                for (this.properties.playbackRate = c, b = 0; b < this._audionodes.length; ++b) {
                  this._audionodes[b].playbackRate.value = c;
                }
              }
            }
          }
        }
      }
    }
    if (this.outputs) {
      for (a = 0; a < this.outputs.length; ++a) {
        "buffer" == this.outputs[a].name && this._audiobuffer && this.setOutputData(a, this._audiobuffer);
      }
    }
  };
  f.prototype.onAction = function(a) {
    this._audiobuffer && ("Play" == a ? this.playBuffer(this._audiobuffer) : "Stop" == a && this.stopAllSounds());
  };
  f.prototype.onPropertyChanged = function(a, b) {
    if ("src" == a) {
      this.loadSound(b);
    } else {
      if ("gain" == a) {
        this.audionode.gain.value = b;
      } else {
        if ("playbackRate" == a) {
          for (a = 0; a < this._audionodes.length; ++a) {
            this._audionodes[a].playbackRate.value = b;
          }
        }
      }
    }
  };
  f.prototype.playBuffer = function(a) {
    var b = this, c = g.getAudioContext().createBufferSource();
    this._last_sourcenode = c;
    c.graphnode = this;
    c.buffer = a;
    c.loop = this.properties.loop;
    c.playbackRate.value = this.properties.playbackRate;
    this._audionodes.push(c);
    c.connect(this.audionode);
    this._audionodes.push(c);
    c.onended = function() {
      b.trigger("ended");
      var a = b._audionodes.indexOf(c);
      -1 != a && b._audionodes.splice(a, 1);
    };
    c.started || (c.started = !0, c.start());
    return c;
  };
  f.prototype.loadSound = function(a) {
    var b = this;
    this._request && (this._request.abort(), this._request = null);
    this._audiobuffer = null;
    this._loading_audio = !1;
    a && (this._request = g.loadSound(a, function(a) {
      this.boxcolor = z.NODE_DEFAULT_BOXCOLOR;
      b._audiobuffer = a;
      b._loading_audio = !1;
      if (b.graph && b.graph.status === LGraph.STATUS_RUNNING) {
        b.onStart();
      }
    }), this._loading_audio = !0, this.boxcolor = "#AA4");
  };
  f.prototype.onConnectionsChange = g.onConnectionsChange;
  f.prototype.onGetInputs = function() {
    return [["playbackRate", "number"], ["Play", z.ACTION], ["Stop", z.ACTION]];
  };
  f.prototype.onGetOutputs = function() {
    return [["buffer", "audiobuffer"], ["ended", z.EVENT]];
  };
  f.prototype.onDropFile = function(a) {
    this._dropped_url && URL.revokeObjectURL(this._dropped_url);
    a = URL.createObjectURL(a);
    this.properties.src = a;
    this.loadSound(a);
    this._dropped_url = a;
  };
  f.title = "Source";
  f.desc = "Plays audio";
  z.registerNodeType("audio/source", f);
  k.prototype.onAdded = function(a) {
    if (a.status === LGraph.STATUS_RUNNING) {
      this.onStart();
    }
  };
  k.prototype.onStart = function() {
    null != this._media_stream || this._waiting_confirmation || this.openStream();
  };
  k.prototype.onStop = function() {
    this.audionode.gain.value = 0;
  };
  k.prototype.onPause = function() {
    this.audionode.gain.value = 0;
  };
  k.prototype.onUnpause = function() {
    this.audionode.gain.value = this.properties.gain;
  };
  k.prototype.onRemoved = function() {
    this.audionode.gain.value = 0;
    this.audiosource_node && (this.audiosource_node.disconnect(this.audionode), this.audiosource_node = null);
    if (this._media_stream) {
      var a = this._media_stream.getTracks();
      a.length && a[0].stop();
    }
  };
  k.prototype.openStream = function() {
    if (navigator.mediaDevices) {
      this._waiting_confirmation = !0;
      navigator.mediaDevices.getUserMedia({audio:!0, video:!1}).then(this.streamReady.bind(this)).catch(function(b) {
        console.log("Media rejected", b);
        a._media_stream = !1;
        a.boxcolor = "red";
      });
      var a = this;
    } else {
      console.log("getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags");
    }
  };
  k.prototype.streamReady = function(a) {
    this._media_stream = a;
    this.audiosource_node && this.audiosource_node.disconnect(this.audionode);
    this.audiosource_node = g.getAudioContext().createMediaStreamSource(a);
    this.audiosource_node.graphnode = this;
    this.audiosource_node.connect(this.audionode);
    this.boxcolor = "white";
  };
  k.prototype.onExecute = function() {
    null != this._media_stream || this._waiting_confirmation || this.openStream();
    if (this.inputs) {
      for (var a = 0; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        if (null != b.link) {
          var c = this.getInputData(a);
          void 0 !== c && "gain" == b.name && (this.audionode.gain.value = this.properties.gain = c);
        }
      }
    }
  };
  k.prototype.onAction = function(a) {
    "Play" == a ? this.audionode.gain.value = this.properties.gain : "Stop" == a && (this.audionode.gain.value = 0);
  };
  k.prototype.onPropertyChanged = function(a, b) {
    "gain" == a && (this.audionode.gain.value = b);
  };
  k.prototype.onConnectionsChange = g.onConnectionsChange;
  k.prototype.onGetInputs = function() {
    return [["playbackRate", "number"], ["Play", z.ACTION], ["Stop", z.ACTION]];
  };
  k.title = "MediaSource";
  k.desc = "Plays microphone";
  z.registerNodeType("audio/media_source", k);
  q.prototype.onPropertyChanged = function(a, b) {
    this.audionode[a] = b;
  };
  q.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.audionode.frequencyBinCount;
      this._freq_bin && this._freq_bin.length == a || (this._freq_bin = new Uint8Array(a));
      this.audionode.getByteFrequencyData(this._freq_bin);
      this.setOutputData(0, this._freq_bin);
    }
    this.isOutputConnected(1) && (a = this.audionode.frequencyBinCount, this._time_bin && this._time_bin.length == a || (this._time_bin = new Uint8Array(a)), this.audionode.getByteTimeDomainData(this._time_bin), this.setOutputData(1, this._time_bin));
    for (a = 1; a < this.inputs.length; ++a) {
      var b = this.inputs[a];
      if (null != b.link) {
        var c = this.getInputData(a);
        void 0 !== c && (this.audionode[b.name].value = c);
      }
    }
  };
  q.prototype.onGetInputs = function() {
    return [["minDecibels", "number"], ["maxDecibels", "number"], ["smoothingTimeConstant", "number"]];
  };
  q.prototype.onGetOutputs = function() {
    return [["freqs", "array"], ["samples", "array"]];
  };
  q.title = "Analyser";
  q.desc = "Audio Analyser";
  z.registerNodeType("audio/analyser", q);
  d.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var a = 1; a < this.inputs.length; ++a) {
        var b = this.inputs[a], c = this.getInputData(a);
        void 0 !== c && (this.audionode[b.name].value = c);
      }
    }
  };
  g.createAudioNodeWrapper(d);
  d.title = "Gain";
  d.desc = "Audio gain";
  z.registerNodeType("audio/gain", d);
  g.createAudioNodeWrapper(t);
  t.prototype.onRemove = function() {
    this._dropped_url && URL.revokeObjectURL(this._dropped_url);
  };
  t.prototype.onPropertyChanged = function(a, b) {
    "impulse_src" == a ? this.loadImpulse(b) : "normalize" == a && (this.audionode.normalize = b);
  };
  t.prototype.onDropFile = function(a) {
    this._dropped_url && URL.revokeObjectURL(this._dropped_url);
    this._dropped_url = URL.createObjectURL(a);
    this.properties.impulse_src = this._dropped_url;
    this.loadImpulse(this._dropped_url);
  };
  t.prototype.loadImpulse = function(a) {
    var b = this;
    this._request && (this._request.abort(), this._request = null);
    this._impulse_buffer = null;
    this._loading_impulse = !1;
    a && (this._request = g.loadSound(a, function(a) {
      b._impulse_buffer = a;
      b.audionode.buffer = a;
      console.log("Impulse signal set");
      b._loading_impulse = !1;
    }), this._loading_impulse = !0);
  };
  t.title = "Convolver";
  t.desc = "Convolves the signal (used for reverb)";
  z.registerNodeType("audio/convolver", t);
  g.createAudioNodeWrapper(u);
  u.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var a = 1; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        if (null != b.link) {
          var c = this.getInputData(a);
          void 0 !== c && (this.audionode[b.name].value = c);
        }
      }
    }
  };
  u.prototype.onGetInputs = function() {
    return [["threshold", "number"], ["knee", "number"], ["ratio", "number"], ["reduction", "number"], ["attack", "number"], ["release", "number"]];
  };
  u.title = "DynamicsCompressor";
  u.desc = "Dynamics Compressor";
  z.registerNodeType("audio/dynamicsCompressor", u);
  x.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      var a = this.getInputData(1);
      void 0 !== a && (this.audionode.curve = a);
    }
  };
  x.prototype.setWaveShape = function(a) {
    this.audionode.curve = a;
  };
  g.createAudioNodeWrapper(x);
  w.prototype.getAudioNodeInInputSlot = function(a) {
    if (0 == a) {
      return this.audionode1;
    }
    if (2 == a) {
      return this.audionode2;
    }
  };
  w.prototype.onPropertyChanged = function(a, b) {
    "gain1" == a ? this.audionode1.gain.value = b : "gain2" == a && (this.audionode2.gain.value = b);
  };
  w.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var a = 1; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        null != b.link && "audio" != b.type && (b = this.getInputData(a), void 0 !== b && (1 == a ? this.audionode1.gain.value = b : 3 == a && (this.audionode2.gain.value = b)));
      }
    }
  };
  g.createAudioNodeWrapper(w);
  w.title = "Mixer";
  w.desc = "Audio mixer";
  z.registerNodeType("audio/mixer", w);
  g.createAudioNodeWrapper(h);
  h.prototype.onExecute = function() {
    var a = this.getInputData(1);
    void 0 !== a && (this.audionode.delayTime.value = a);
  };
  h.title = "Delay";
  h.desc = "Audio delay";
  z.registerNodeType("audio/delay", h);
  m.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var a = 1; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        if (null != b.link) {
          var c = this.getInputData(a);
          void 0 !== c && (this.audionode[b.name].value = c);
        }
      }
    }
  };
  m.prototype.onGetInputs = function() {
    return [["frequency", "number"], ["detune", "number"], ["Q", "number"]];
  };
  g.createAudioNodeWrapper(m);
  m.title = "BiquadFilter";
  m.desc = "Audio filter";
  z.registerNodeType("audio/biquadfilter", m);
  b.prototype.onStart = function() {
    this.audionode.started || (this.audionode.started = !0, this.audionode.start());
  };
  b.prototype.onStop = function() {
    this.audionode.started && (this.audionode.started = !1, this.audionode.stop());
  };
  b.prototype.onPause = function() {
    this.onStop();
  };
  b.prototype.onUnpause = function() {
    this.onStart();
  };
  b.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var a = 0; a < this.inputs.length; ++a) {
        var b = this.inputs[a];
        if (null != b.link) {
          var c = this.getInputData(a);
          void 0 !== c && (this.audionode[b.name].value = c);
        }
      }
    }
  };
  b.prototype.onGetInputs = function() {
    return [["frequency", "number"], ["detune", "number"], ["type", "string"]];
  };
  g.createAudioNodeWrapper(b);
  b.title = "Oscillator";
  b.desc = "Oscillator";
  z.registerNodeType("audio/oscillator", b);
  p.prototype.onExecute = function() {
    this._last_buffer = this.getInputData(0);
    var a = this.getInputData(1);
    void 0 !== a && (this.properties.mark = a);
    this.setDirtyCanvas(!0, !1);
  };
  p.prototype.onDrawForeground = function(a) {
    if (this._last_buffer) {
      var b = this._last_buffer, c = b.length / this.size[0], d = this.size[1];
      a.fillStyle = "black";
      a.fillRect(0, 0, this.size[0], this.size[1]);
      a.strokeStyle = "white";
      a.beginPath();
      var e = 0;
      if (this.properties.continuous) {
        a.moveTo(e, d);
        for (var f = 0; f < b.length; f += c) {
          a.lineTo(e, d - b[f | 0] / 255 * d), e++;
        }
      } else {
        for (f = 0; f < b.length; f += c) {
          a.moveTo(e + 0.5, d), a.lineTo(e + 0.5, d - b[f | 0] / 255 * d), e++;
        }
      }
      a.stroke();
      0 <= this.properties.mark && (b = g.getAudioContext().sampleRate / b.length, e = this.properties.mark / b * 2 / c, e >= this.size[0] && (e = this.size[0] - 1), a.strokeStyle = "red", a.beginPath(), a.moveTo(e, d), a.lineTo(e, 0), a.stroke());
    }
  };
  p.title = "Visualization";
  p.desc = "Audio Visualization";
  z.registerNodeType("audio/visualization", p);
  a.prototype.onExecute = function() {
    if (this._freqs = this.getInputData(0)) {
      var a = this.properties.band, b = this.getInputData(1);
      void 0 !== b && (a = b);
      b = g.getAudioContext().sampleRate / this._freqs.length;
      b = a / b * 2;
      b >= this._freqs.length ? b = this._freqs[this._freqs.length - 1] : (a = b | 0, b -= a, b = this._freqs[a] * (1 - b) + this._freqs[a + 1] * b);
      this.setOutputData(0, b / 255 * this.properties.amplitude);
    }
  };
  a.prototype.onGetInputs = function() {
    return [["band", "number"]];
  };
  a.title = "Signal";
  a.desc = "extract the signal of some frequency";
  z.registerNodeType("audio/signal", a);
  c.prototype.onAdded = function(a) {
    a.status == LGraph.STATUS_RUNNING && (this.audionode.onaudioprocess = this._callback);
  };
  c["@code"] = {widget:"code"};
  c.prototype.onStart = function() {
    this.audionode.onaudioprocess = this._callback;
  };
  c.prototype.onStop = function() {
    this.audionode.onaudioprocess = c._bypass_function;
  };
  c.prototype.onPause = function() {
    this.audionode.onaudioprocess = c._bypass_function;
  };
  c.prototype.onUnpause = function() {
    this.audionode.onaudioprocess = this._callback;
  };
  c.prototype.onExecute = function() {
  };
  c.prototype.onRemoved = function() {
    this.audionode.onaudioprocess = c._bypass_function;
  };
  c.prototype.processCode = function() {
    try {
      this._script = new (new Function("properties", this.properties.code))(this.properties), this._old_code = this.properties.code, this._callback = this._script.onaudioprocess;
    } catch (l) {
      console.error("Error in onaudioprocess code", l), this._callback = c._bypass_function, this.audionode.onaudioprocess = this._callback;
    }
  };
  c.prototype.onPropertyChanged = function(a, b) {
    "code" == a && (this.properties.code = b, this.processCode(), this.graph && this.graph.status == LGraph.STATUS_RUNNING && (this.audionode.onaudioprocess = this._callback));
  };
  c.default_function = function() {
    this.onaudioprocess = function(a) {
      var b = a.inputBuffer;
      a = a.outputBuffer;
      for (var c = 0; c < a.numberOfChannels; c++) {
        for (var d = b.getChannelData(c), e = a.getChannelData(c), g = 0; g < b.length; g++) {
          e[g] = d[g];
        }
      }
    };
  };
  g.createAudioNodeWrapper(c);
  c.title = "Script";
  c.desc = "apply script to signal";
  z.registerNodeType("audio/script", c);
  e.title = "Destination";
  e.desc = "Audio output";
  z.registerNodeType("audio/destination", e);
})(this);
(function(v) {
  function f() {
    this.size = [60, 20];
    this.addInput("send", q.ACTION);
    this.addOutput("received", q.EVENT);
    this.addInput("in", 0);
    this.addOutput("out", 0);
    this.properties = {url:"", room:"lgraph"};
    this._ws = null;
    this._last_data = [];
  }
  function k() {
    this.size = [60, 20];
    this.addInput("send", q.ACTION);
    this.addOutput("received", q.EVENT);
    this.addInput("in", 0);
    this.addOutput("out", 0);
    this.properties = {url:"tamats.com:55000", room:"lgraph", save_bandwidth:!0};
    this._server = null;
    this.createSocket();
    this._last_input_data = [];
    this._last_output_data = [];
  }
  var q = v.LiteGraph;
  f.title = "WebSocket";
  f.desc = "Send data through a websocket";
  f.prototype.onPropertyChanged = function(d, f) {
    "url" == d && this.createSocket();
  };
  f.prototype.onExecute = function() {
    !this._ws && this.properties.url && this.createSocket();
    if (this._ws && this._ws.readyState == WebSocket.OPEN) {
      for (var d = this.properties.room, f = 1; f < this.inputs.length; ++f) {
        var k = this.getInputData(f);
        if (null != k) {
          try {
            var q = JSON.stringify({type:0, room:d, channel:f, data:k});
          } catch (w) {
            continue;
          }
          this._ws.send(q);
        }
      }
      for (f = 1; f < this.outputs.length; ++f) {
        this.setOutputData(f, this._last_data[f]);
      }
    }
  };
  f.prototype.createSocket = function() {
    var d = this, f = this.properties.url;
    "ws" != f.substr(0, 2) && (f = "ws://" + f);
    this._ws = new WebSocket(f);
    this._ws.onopen = function() {
      console.log("ready");
      d.boxcolor = "#8E8";
    };
    this._ws.onmessage = function(f) {
      var k = JSON.parse(f.data);
      k.room && k.room != this.properties.room || (1 == f.data.type ? d.triggerSlot(0, k) : d._last_data[f.data.channel || 0] = k.data);
    };
    this._ws.onerror = function(f) {
      console.log("couldnt connect to websocket");
      d.boxcolor = "#E88";
    };
    this._ws.onclose = function(f) {
      console.log("connection closed");
      d.boxcolor = "#000";
    };
  };
  f.prototype.send = function(d) {
    this._ws && this._ws.readyState == WebSocket.OPEN && this._ws.send(JSON.stringify({type:1, msg:d}));
  };
  f.prototype.onAction = function(d, f) {
    this._ws && this._ws.readyState == WebSocket.OPEN && this._ws.send({type:1, room:this.properties.room, action:d, data:f});
  };
  f.prototype.onGetInputs = function() {
    return [["in", 0]];
  };
  f.prototype.onGetOutputs = function() {
    return [["out", 0]];
  };
  q.registerNodeType("network/websocket", f);
  k.title = "SillyClient";
  k.desc = "Connects to SillyServer to broadcast messages";
  k.prototype.onPropertyChanged = function(d, f) {
    d = this.properties.url + "/" + this.properties.room;
    this._server && this._final_url != d && (this._server.connect(this.properties.url, this.properties.room), this._final_url = d);
  };
  k.prototype.onExecute = function() {
    if (this._server && this._server.is_connected) {
      for (var d = this.properties.save_bandwidth, f = 1; f < this.inputs.length; ++f) {
        var k = this.getInputData(f);
        null == k || d && this._last_input_data[f] == k || (this._server.sendMessage({type:0, channel:f, data:k}), this._last_input_data[f] = k);
      }
      for (f = 1; f < this.outputs.length; ++f) {
        this.setOutputData(f, this._last_output_data[f]);
      }
    }
  };
  k.prototype.createSocket = function() {
    var d = this;
    "undefined" == typeof SillyClient ? (this._error || console.error("SillyClient node cannot be used, you must include SillyServer.js"), this._error = !0) : (this._server = new SillyClient, this._server.on_ready = function() {
      console.log("ready");
      d.boxcolor = "#8E8";
    }, this._server.on_message = function(f, k) {
      f = null;
      try {
        f = JSON.parse(k);
      } catch (x) {
        return;
      }
      1 == f.type ? d.triggerSlot(0, f) : d._last_output_data[f.channel || 0] = f.data;
    }, this._server.on_error = function(f) {
      console.log("couldnt connect to websocket");
      d.boxcolor = "#E88";
    }, this._server.on_close = function(f) {
      console.log("connection closed");
      d.boxcolor = "#000";
    }, this.properties.url && this.properties.room && (this._server.connect(this.properties.url, this.properties.room), this._final_url = this.properties.url + "/" + this.properties.room));
  };
  k.prototype.send = function(d) {
    this._server && this._server.is_connected && this._server.sendMessage({type:1, data:d});
  };
  k.prototype.onAction = function(d, f) {
    this._server && this._server.is_connected && this._server.sendMessage({type:1, action:d, data:f});
  };
  k.prototype.onGetInputs = function() {
    return [["in", 0]];
  };
  k.prototype.onGetOutputs = function() {
    return [["out", 0]];
  };
  q.registerNodeType("network/sillyclient", k);
})(this);

